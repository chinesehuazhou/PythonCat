<!DOCTYPE html>



  


<html class="theme-next muse use-motion" lang="zh-Hans">
<head><meta name="generator" content="Hexo 3.8.0">
  <meta charset="UTF-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
<meta name="theme-color" content="#222">









<meta http-equiv="Cache-Control" content="no-transform">
<meta http-equiv="Cache-Control" content="no-siteapp">
















  
  
  <link href="/lib/fancybox/source/jquery.fancybox.css?v=2.1.5" rel="stylesheet" type="text/css">







<link href="/lib/font-awesome/css/font-awesome.min.css?v=4.6.2" rel="stylesheet" type="text/css">

<link href="/css/main.css?v=5.1.4" rel="stylesheet" type="text/css">


  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png?v=5.1.4">


  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png?v=5.1.4">


  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png?v=5.1.4">


  <link rel="mask-icon" href="/images/logo.svg?v=5.1.4" color="#222">





  <meta name="keywords" content="Hexo, NexT">










<meta property="og:type" content="website">
<meta property="og:title" content="豌豆花下猫">
<meta property="og:url" content="https://chinesehuazhou.github.io/page/4/index.html">
<meta property="og:site_name" content="豌豆花下猫">
<meta property="og:locale" content="zh-Hans">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="豌豆花下猫">



<script type="text/javascript" id="hexo.configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '/',
    scheme: 'Muse',
    version: '5.1.4',
    sidebar: {"position":"left","display":"post","offset":12,"b2t":false,"scrollpercent":false,"onmobile":false},
    fancybox: true,
    tabs: true,
    motion: {"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},
    duoshuo: {
      userId: '0',
      author: '博主'
    },
    algolia: {
      applicationID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    }
  };
</script>



  <link rel="canonical" href="https://chinesehuazhou.github.io/page/4/">





  <title>豌豆花下猫</title>
  








</head>

<body itemscope itemtype="http://schema.org/WebPage" lang="zh-Hans">

  
  
    
  

  <div class="container sidebar-position-left 
  page-home">
    <div class="headband"></div>

    <header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-wrapper">
  <div class="site-meta ">
    

    <div class="custom-logo-site-title">
      <a href="/" class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">豌豆花下猫</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
      
        <p class="site-subtitle"></p>
      
  </div>

  <div class="site-nav-toggle">
    <button>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
    </button>
  </div>
</div>

<nav class="site-nav">
  

  
    <ul id="menu" class="menu">
      
        
        <li class="menu-item menu-item-home">
          <a href="/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-home"></i> <br>
            
            首页
          </a>
        </li>
      
        
        <li class="menu-item menu-item-archives">
          <a href="/archives/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-archive"></i> <br>
            
            归档
          </a>
        </li>
      

      
    </ul>
  

  
</nav>



 </div>
    </header>

    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          <div id="content" class="content">
            
  <section id="posts" class="posts-expand">
    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://chinesehuazhou.github.io/2019/05/03/Python进阶/再谈文件读写：判断文件的几种方法及其优劣对比/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="John Doe">
      <meta itemprop="description" content>
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="豌豆花下猫">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2019/05/03/Python进阶/再谈文件读写：判断文件的几种方法及其优劣对比/" itemprop="url">未命名</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2019-05-03T21:21:22+08:00">
                2019-05-03
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h2 id="再谈文件读写：判断文件的几种方法及其优劣对比"><a href="#再谈文件读写：判断文件的几种方法及其优劣对比" class="headerlink" title="再谈文件读写：判断文件的几种方法及其优劣对比"></a>再谈文件读写：判断文件的几种方法及其优劣对比</h2><hr>
<p>上周，猫猫写了一篇<a href="https://mp.weixin.qq.com/s/Md07VoaULda7qnMO4ob7Ww" target="_blank" rel="noopener">给Python学习者的文件读写指南</a>，跟大家一起详尽地学习了文件读写的基础内容，以及with语句与上下文管理器的进阶知识。</p>
<p>这份指南虽然写得很用心，但是因为只关注了文件读写的核心内容，所以也有美中不足不处，有些在实战中所需的知识点没有谈到，例如，为了能够进行文件读写，首先得找到文件、文件得可读写才行。</p>
<p>我们知道当文件不存在的时候，open()方法的写模式与追加模式都会新建文件，但是对文件进行判断的场景还有很多，比如，在爬虫下载图片的时候，可能需要判断文件是否存在，以免重复下载；又比如，创建新文件的时候，可能需要判断文件是否存在，存在就先做个备份……所以，学习判断文件是否存在，还是很有必要的。</p>
<p>学习是循序渐进的过程，若能建立知识点间的联系，进行系统性的学习，那将更有助于效果。阅读这篇文章，你将读到如下内容：</p>
<p>1、判断文件的方法（try语句、os模块、pathlib模块）<br>2、以上几种方法的优劣对比</p>
<h2 id="懒人的try语句"><a href="#懒人的try语句" class="headerlink" title="懒人的try语句"></a>懒人的try语句</h2><p>我们之前学过，要用with语句来处理文件读写，但with语句也不是万能的，所以还得关注一些异常情况。例如，当使用open()方法的时候，如果文件不存在，程序会抛出FileNotFoundError异常，而如果权限不足的话，就会抛出PersmissionError异常。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">with open(&quot;python.log&quot;, &quot;r&quot;) as f:</span><br><span class="line">    ...:     f.read()</span><br><span class="line">-----------------------</span><br><span class="line">...(略)</span><br><span class="line">FileNotFoundError: [Errno 2] No such file or directory: &apos;python.log&apos;</span><br></pre></td></tr></table></figure></p>
<p>为了避免这些异常导致程序中断，我们可以用try…except…语句来捕捉异常，然后在except子句进行异常的处理。</p>
<p>不过，在猫猫看来，这个方法不值得推荐。原因有二，一是这种方法很被动，程序的健康受制于不可预测的异常；二是当文件不存在的时候，我们可能需要去创建文件，这些逻辑如果写在except子句里，可读性太差了。</p>
<h2 id="传统的os模块"><a href="#传统的os模块" class="headerlink" title="传统的os模块"></a>传统的os模块</h2><p>顾名思义，Python内置的os模块是用来与OS（操作系统）进行交互的模块，它可以实现很多在命令行下做的操作，例如，获取操作系统信息、获取/修改环境变量、进行目录操作（创建、删除、遍历）和各种文件操作等等。</p>
<p>下面，我们要学习的是跟文件判断密切相关的几个方法。</p>
<p>1、os.path.exists()用于判断文件及文件夹是否存在（注意：因为两者都能判断，为了有效区分文件和文件夹，最好保证文件是带后缀的。）：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">import os</span><br><span class="line"># 文件存在 VS 不存在</span><br><span class="line">os.path.exists(&quot;test.txt&quot;) &gt;&gt;&gt;True</span><br><span class="line">os.path.exists(&quot;cat.txt&quot;) &gt;&gt;&gt;False</span><br><span class="line"># 文件夹存在 VS 不存在</span><br><span class="line">os.path.exists(&quot;cat/images&quot;) &gt;&gt;&gt;True</span><br><span class="line">os.path.exists(&quot;cat/image&quot;) &gt;&gt;&gt;False</span><br></pre></td></tr></table></figure></p>
<p>2、os.path.isfile()、os.path.isdir() 判断给定路径是文件还是文件夹：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">os.path.isfile(&quot;cat/images&quot;) &gt;&gt;&gt;False</span><br><span class="line">os.path.isdir(&quot;cat/images&quot;) &gt;&gt;&gt;True</span><br><span class="line">os.path.isfile(&quot;test.txt&quot;) &gt;&gt;&gt;True</span><br></pre></td></tr></table></figure></p>
<p>3、os.access()检测文件路径的访问权限，语法：os.access(path, mode)；其中path指的是文件或者文件夹，mode指的是要检测的模式：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">os.access(&quot;cat/images&quot;, os.F_OK) &gt;&gt;&gt;True # path存在</span><br><span class="line">os.access(&quot;cat/images&quot;, os.R_OK) &gt;&gt;&gt;True # path可读</span><br><span class="line">os.access(&quot;cat/images&quot;, os.W_OK) &gt;&gt;&gt;True # path可写</span><br><span class="line">os.access(&quot;cat/images&quot;, os.X_OK) &gt;&gt;&gt;True # path可执行</span><br></pre></td></tr></table></figure></p>
<p>4、os模块中其它常用方法：</p>
<p>os.mkdir()创建目录、os.rmdir()删除目录、os.rename()重命名、os.remove()删除文件、os.path.join()连接目录与文件名、os.path.split()分割目录与文件名……（不一一举例了，今后有机会再作介绍）</p>
<h2 id="时尚的pathlib模块"><a href="#时尚的pathlib模块" class="headerlink" title="时尚的pathlib模块"></a>时尚的pathlib模块</h2><p>pathlib模块是python3.4才加入的模块，官方介绍它是面向对象的文件系统路径（Object-oriented filesystem paths），这是一个很强大的模块，文末附录了官方文档地址。</p>
<p>这里主要介绍几个基本的用法：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">import pathlib</span><br><span class="line">file_obj = pathlib.Path(&quot;test.txt&quot;)</span><br><span class="line"></span><br><span class="line">file_obj.name &gt;&gt;&gt;&apos;test.txt&apos; # 文件名</span><br><span class="line">file_obj.exists() &gt;&gt;&gt; True # 是否存在</span><br><span class="line">file_obj.is_dir() &gt;&gt;&gt;False # 是否文件夹</span><br><span class="line">file_obj.is_file() &gt;&gt;&gt;True # 是否文件</span><br></pre></td></tr></table></figure>
<h2 id="几种方法优劣对比"><a href="#几种方法优劣对比" class="headerlink" title="几种方法优劣对比"></a>几种方法优劣对比</h2><p>围绕文件操作的知识很多，限于篇幅，本文主要对判断文件作了介绍，今后也许还会对其它具体话题进行学习。</p>
<p>现在知道了几种判断文件是否存在的方法，猫猫试着根据自己的理解，对它们做一下评判。</p>
<p>首先，try语句的缺点是没有主动做判断，不方便根据文件是否存在而做针对性的处理，它把必要的逻辑交给异常捕获，多少显得“不负责任”；try语句也有优点，一是不需要引入模块，不需要区分各种使用方法，二是将其它可能存在的异常都打包，避免多样系统或使用场景的遗漏。</p>
<p>os模块是传统的老模块了，在使用上和维护上都会比较顺畅；它的主要缺点在于有的方法比较繁琐，由于使用字符串来表示文件路径，这会导致路径拼接上的麻烦，另外，不同操作系统在路径分隔符上的差异（Windows使用\分隔符，Linux和Mac使用/分隔符），也可能导致难以发现的错误。</p>
<p>相对来说，pathlib功能最强大，但普及度比较低，有一定的学习门槛；它主要的优点是面向对象，同时，因为对不同操作系统的特性做了封装，能有效避免字符串表示文件路径的难题。它的不足之处是没有像os.access()可以检测访问权限的方法，虽然这个方法基本不会使用到。</p>
<p>下面比较了三种拼接文件路径的方法，方法一未对分隔符做处理，不能保证在每个操作系统都能找到；方法二需要反复使用os.path.join；方法三只用“/“就能拼接路径，而且肯定支持多操作系统。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"># 错误拼接：未处理分隔符</span><br><span class="line">data_folder = &quot;source_data/text_files/&quot;</span><br><span class="line">file_to_open = data_folder + &quot;test.txt&quot;</span><br><span class="line"></span><br><span class="line"># os模块拼接</span><br><span class="line">import os</span><br><span class="line">data_folder = os.path.join(&quot;source_data&quot;, &quot;text_files&quot;)</span><br><span class="line">file_to_open = os.path.join(data_folder, &quot;test.txt&quot;)</span><br><span class="line"></span><br><span class="line"># pathlib模块拼接</span><br><span class="line">from pathlib import Path</span><br><span class="line">data_folder = Path(&quot;source_data/text_files/&quot;)</span><br><span class="line">file_to_open = data_folder / &quot;test.txt&quot;</span><br></pre></td></tr></table></figure>
<p>总结一下，如果文件路径简单，仅仅要用到exists()、is_dir()、is_file() 这几个方法的话，os.path模块和pathlib.Path模块不分伯仲，都很好用，但是如果考虑到繁复的路径拼接的话，pathlib.Path就会胜出一筹。</p>
<p>喵喵，今天的分享就到这啦，小伙伴们觉得有用的话，麻烦帮忙点赞、转发给其他童靴哦<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">另外，为了回馈各位好学的胖友们，猫猫精选了20本电子书，现在去后台回复【爱学习】，即可免费获得哦喵</span><br></pre></td></tr></table></figure></p>
<p>扩展阅读：<br>给Python学习者的文件读写指南<br><a href="https://mp.weixin.qq.com/s/Md07VoaULda7qnMO4ob7Ww" target="_blank" rel="noopener">https://mp.weixin.qq.com/s/Md07VoaULda7qnMO4ob7Ww</a><br>菜鸟教程：os模块<br><a href="http://www.runoob.com/python/os-file-methods.html" target="_blank" rel="noopener">http://www.runoob.com/python/os-file-methods.html</a><br>官方文档：pathlib模块<br><a href="https://docs.python.org/3/library/pathlib.html" target="_blank" rel="noopener">https://docs.python.org/3/library/pathlib.html</a></p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://chinesehuazhou.github.io/2019/05/03/Python进阶/sum() 函数性能堪忧，列表降维有何良方？/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="John Doe">
      <meta itemprop="description" content>
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="豌豆花下猫">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2019/05/03/Python进阶/sum() 函数性能堪忧，列表降维有何良方？/" itemprop="url">未命名</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2019-05-03T21:21:22+08:00">
                2019-05-03
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="sum-函数性能堪忧，列表降维有何良方？"><a href="#sum-函数性能堪忧，列表降维有何良方？" class="headerlink" title="sum() 函数性能堪忧，列表降维有何良方？"></a>sum() 函数性能堪忧，列表降维有何良方？</h1><p><img src="http://ww1.sinaimg.cn/large/68b02e3bgy1g2gbcdgtb0j2400290hdu.jpg" alt></p>
<p>本文原创并首发于公众号【<strong>Python猫</strong>】，未经授权，请勿转载。</p>
<p>原文地址：<a href="https://mp.weixin.qq.com/s/mK1nav2vKykZaKw_TY-rtw" target="_blank" rel="noopener">https://mp.weixin.qq.com/s/mK1nav2vKykZaKw_TY-rtw</a></p>
<p>Python 的内置函数 sum() 可以接收两个参数，当第一个参数是二维列表，第二个参数是一维列表的时候，它可以实现列表降维的效果。</p>
<p>在上一篇《<a href="https://mp.weixin.qq.com/s/cr_noDx6s1sZ6Xt6PDpDVQ" target="_blank" rel="noopener">如何给列表降维？sum()函数的妙用</a>》中，我们介绍了这个用法，还对 sum() 函数做了扩展的学习。</p>
<p>那篇文章发布后，猫哥收到了一些很有价值的反馈，不仅在知识面上获得了扩充，在思维能力上也得到了一些启发，因此，我决定再写一篇文章，继续跟大家聊聊 sum() 函数以及列表降维。若你读后有所启发，欢迎留言与我交流。</p>
<p>有些同学表示，没想到 sum() 函数竟然可以这么用，涨见识了！猫哥最初在交流群里看到这种用法时，也有同样的想法。整理成文章后，能得到别人的认可，我非常开心。</p>
<p>学到新东西，进行分享，最后令读者也有所获，这鼓舞了我——应该每日精进，并把所学分享出去。</p>
<p>也有的同学早已知道 sum() 的这个用法，还指出它的性能并不好，不建议使用。这是我不曾考虑到的问题，但又不得不认真对待。</p>
<p>是的，sum() 函数做列表降维有奇效，但它性能堪忧，并不是最好的选择。</p>
<p>因此，本文想继续探讨的话题是：<strong>（1）sum() 函数的性能到底差多少，为什么会差？（2）既然 sum() 不是最好的列表降维方法，那是否有什么替代方案呢？</strong> </p>
<p>在 <code>stackoverflow</code> 网站上，有人问了个“<a href="https://stackoverflow.com/questions/952914/how-to-make-a-flat-list-out-of-list-of-lists" target="_blank" rel="noopener">How to make a flat list out of list of lists</a>”问题，正是我们在上篇文章中提出的问题。在回答中，有人分析了 7 种方法的时间性能。</p>
<p>先看看测试代码：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> functools</span><br><span class="line"><span class="keyword">import</span> itertools</span><br><span class="line"><span class="keyword">import</span> numpy</span><br><span class="line"><span class="keyword">import</span> operator</span><br><span class="line"><span class="keyword">import</span> perfplot</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">forfor</span><span class="params">(a)</span>:</span></span><br><span class="line">    <span class="keyword">return</span> [item <span class="keyword">for</span> sublist <span class="keyword">in</span> a <span class="keyword">for</span> item <span class="keyword">in</span> sublist]</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">sum_brackets</span><span class="params">(a)</span>:</span></span><br><span class="line">    <span class="keyword">return</span> sum(a, [])</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">functools_reduce</span><span class="params">(a)</span>:</span></span><br><span class="line">    <span class="keyword">return</span> functools.reduce(operator.concat, a)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">functools_reduce_iconcat</span><span class="params">(a)</span>:</span></span><br><span class="line">    <span class="keyword">return</span> functools.reduce(operator.iconcat, a, [])</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">itertools_chain</span><span class="params">(a)</span>:</span></span><br><span class="line">    <span class="keyword">return</span> list(itertools.chain.from_iterable(a))</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">numpy_flat</span><span class="params">(a)</span>:</span></span><br><span class="line">    <span class="keyword">return</span> list(numpy.array(a).flat)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">numpy_concatenate</span><span class="params">(a)</span>:</span></span><br><span class="line">    <span class="keyword">return</span> list(numpy.concatenate(a))</span><br><span class="line"></span><br><span class="line">perfplot.show(</span><br><span class="line">    setup=<span class="keyword">lambda</span> n: [list(range(<span class="number">10</span>))] * n,</span><br><span class="line">    kernels=[</span><br><span class="line">        forfor, sum_brackets, functools_reduce, functools_reduce_iconcat,</span><br><span class="line">        itertools_chain, numpy_flat, numpy_concatenate</span><br><span class="line">        ],</span><br><span class="line">    n_range=[<span class="number">2</span>**k <span class="keyword">for</span> k <span class="keyword">in</span> range(<span class="number">16</span>)],</span><br><span class="line">    logx=<span class="literal">True</span>,</span><br><span class="line">    logy=<span class="literal">True</span>,</span><br><span class="line">    xlabel=<span class="string">'num lists'</span></span><br><span class="line">    )</span><br></pre></td></tr></table></figure>
<p>代码囊括了最具代表性的 7 种解法，使用了 <code>perfplot</code> （注：这是该测试者本人开发的库）作可视化，结果很直观地展示出，随着数据量的增加，这几种方法的效率变化。 </p>
<p><img src="http://ww1.sinaimg.cn/large/68b02e3bgy1g2gb7khceij20g60c8jsq.jpg" alt></p>
<p>从测试图中可看出，当数据量小于 10 的时候，sum() 函数的效率很高，但是，随着数据量增长，它所花的时间就出现剧增，远远超过了其它方法的损耗。</p>
<p>值得注意的是，functools_reduce 方法的性能曲线几乎与 sum_brackets 重合。</p>
<p>在另一个回答中，有人也做了 7 种方法的性能测试（巧合的是，所用的可视化库也是测试者自己开发的），在这几种方法中，functools.reduce 结合 lambda 函数，虽然写法不同，它的时间效率与 sum() 函数也基本重合：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> itertools <span class="keyword">import</span> chain</span><br><span class="line"><span class="keyword">from</span> functools <span class="keyword">import</span> reduce</span><br><span class="line"><span class="keyword">from</span> collections <span class="keyword">import</span> Iterable  <span class="comment"># or from collections.abc import Iterable</span></span><br><span class="line"><span class="keyword">import</span> operator</span><br><span class="line"><span class="keyword">from</span> iteration_utilities <span class="keyword">import</span> deepflatten</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">nested_list_comprehension</span><span class="params">(lsts)</span>:</span></span><br><span class="line">    <span class="keyword">return</span> [item <span class="keyword">for</span> sublist <span class="keyword">in</span> lsts <span class="keyword">for</span> item <span class="keyword">in</span> sublist]</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">itertools_chain_from_iterable</span><span class="params">(lsts)</span>:</span></span><br><span class="line">    <span class="keyword">return</span> list(chain.from_iterable(lsts))</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">pythons_sum</span><span class="params">(lsts)</span>:</span></span><br><span class="line">    <span class="keyword">return</span> sum(lsts, [])</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">reduce_add</span><span class="params">(lsts)</span>:</span></span><br><span class="line">    <span class="keyword">return</span> reduce(<span class="keyword">lambda</span> x, y: x + y, lsts)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">pylangs_flatten</span><span class="params">(lsts)</span>:</span></span><br><span class="line">    <span class="keyword">return</span> list(flatten(lsts))</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">flatten</span><span class="params">(items)</span>:</span></span><br><span class="line">    <span class="string">"""Yield items from any nested iterable; see REF."""</span></span><br><span class="line">    <span class="keyword">for</span> x <span class="keyword">in</span> items:</span><br><span class="line">        <span class="keyword">if</span> isinstance(x, Iterable) <span class="keyword">and</span> <span class="keyword">not</span> isinstance(x, (str, bytes)):</span><br><span class="line">            <span class="keyword">yield</span> <span class="keyword">from</span> flatten(x)</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="keyword">yield</span> x</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">reduce_concat</span><span class="params">(lsts)</span>:</span></span><br><span class="line">    <span class="keyword">return</span> reduce(operator.concat, lsts)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">iteration_utilities_deepflatten</span><span class="params">(lsts)</span>:</span></span><br><span class="line">    <span class="keyword">return</span> list(deepflatten(lsts, depth=<span class="number">1</span>))</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">from</span> simple_benchmark <span class="keyword">import</span> benchmark</span><br><span class="line"></span><br><span class="line">b = benchmark(</span><br><span class="line">    [nested_list_comprehension, itertools_chain_from_iterable, pythons_sum, reduce_add,</span><br><span class="line">     pylangs_flatten, reduce_concat, iteration_utilities_deepflatten],</span><br><span class="line">    arguments=&#123;<span class="number">2</span>**i: [[<span class="number">0</span>]*<span class="number">5</span>]*(<span class="number">2</span>**i) <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">1</span>, <span class="number">13</span>)&#125;,</span><br><span class="line">    argument_name=<span class="string">'number of inner lists'</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line">b.plot()</span><br></pre></td></tr></table></figure>
<p><img src="http://ww1.sinaimg.cn/large/68b02e3bgy1g2gb8zmsxzj20hs0dcgn2.jpg" alt></p>
<p>这就证实了两点：sum() 函数确实性能堪忧；它的执行效果实际是每个子列表逐一相加（concat）。</p>
<p>那么，问题来了，<strong>拖慢 sum() 函数性能的原因是啥呢？</strong> </p>
<p>在它的实现源码中，我找到了一段注释：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">/* It&apos;s tempting to use PyNumber_InPlaceAdd instead of</span><br><span class="line">PyNumber_Add here, to avoid quadratic running time</span><br><span class="line">when doing &apos;sum(list_of_lists, [])&apos;.  However, this</span><br><span class="line">would produce a change in behaviour: a snippet like</span><br><span class="line"></span><br><span class="line">empty = []</span><br><span class="line">sum([[x] for x in range(10)], empty)</span><br><span class="line"></span><br><span class="line">would change the value of empty. */</span><br></pre></td></tr></table></figure>
<p>为了不改变 sum() 函数的第二个参数值，CPython 没有采用就地相加的方法（PyNumber_InPlaceAdd），而是采用了较耗性能的普通相加的方法（PyNumber_Add）。这种方法所耗费的时间是二次方程式的（quadratic running time）。</p>
<p>为什么在这里要牺牲性能呢？我猜想（只是浅薄猜测），可能有两种考虑，一是为了第二个参数（start）的一致性，因为它通常是一个数值，是不可变对象，所以当它是可变对象类型时，最好也不对它做修改；其次，为了确保 sum() 函数是个 <code>纯函数</code> ，为了多次执行时能返回同样的结果。</p>
<p>那么，我要继续问：<strong>哪种方法是最优的呢？</strong> </p>
<p>综合来看，当子列表个数小于 10 时，sum() 函数几乎是最优的，与某几种方法相差不大，但是，当子列表数目增加时，最优的选择是 functools.reduce(operator.iconcat, a, [])，其次是 list(itertools.chain.from_iterable(a)) 。</p>
<p>事实上，最优方案中的 iconcat(a, b) 等同于 a += b，它是一种就地修改的方法。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">operator.iconcat(a, b)</span><br><span class="line">operator.__iconcat__(a, b)</span><br><span class="line">a = iconcat(a, b) is equivalent to a += b for a and b sequences.</span><br></pre></td></tr></table></figure>
<p>这正是 sum() 函数出于一致性考虑，而舍弃掉的实现方案。</p>
<p>至此，前文提出的问题都找到了答案。</p>
<p>我最后总结一下吧：<strong>sum() 函数采用的是非就地修改的相加方式，用作列表降维时，随着数据量增大，其性能将是二次方程式的剧增，所以说是性能堪忧；而 reduce 结合 iconcat 的方法，才是大数据量时的最佳方案。</strong> </p>
<p>这个结果是否与你所想的一致呢？希望本文的分享，能给你带来新的收获。</p>
<p><strong>相关链接：</strong> </p>
<p>如何给列表降维？sum()函数的妙用 ：<a href="https://mp.weixin.qq.com/s/cr_noDx6s1sZ6Xt6PDpDVQ" target="_blank" rel="noopener">https://mp.weixin.qq.com/s/cr_noDx6s1sZ6Xt6PDpDVQ</a></p>
<p>stackoverflow 问题：<a href="https://stackoverflow.com/questions/952914/how-to-make-a-flat-list-out-of-list-of-lists" target="_blank" rel="noopener">https://stackoverflow.com/questions/952914/how-to-make-a-flat-list-out-of-list-of-lists</a></p>
<p><img src="http://ww1.sinaimg.cn/large/68b02e3bly1g2aiq1kpa8j21hc0nmgs4.jpg" alt></p>
<p>公众号【<strong>Python猫</strong>】， 本号连载优质的系列文章，有喵星哲学猫系列、Python进阶系列、好书推荐系列、技术写作、优质英文推荐与翻译等等，欢迎关注哦。后台回复“<strong>爱学习</strong>”，免费获得一份学习大礼包。</p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://chinesehuazhou.github.io/2019/05/03/Python进阶/Python骚操作：动态定义函数/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="John Doe">
      <meta itemprop="description" content>
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="豌豆花下猫">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2019/05/03/Python进阶/Python骚操作：动态定义函数/" itemprop="url">未命名</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2019-05-03T21:21:22+08:00">
                2019-05-03
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="Python骚操作：动态定义函数"><a href="#Python骚操作：动态定义函数" class="headerlink" title="Python骚操作：动态定义函数"></a>Python骚操作：动态定义函数</h1><p>标题：Python Tips: Dynamic function definition</p>
<p>作者：Philip Trauner</p>
<p>译者：豌豆花下猫</p>
<p>链接：<a href="https://philip-trauner.me/blog/post/python-tips-dynamic-function-definition" target="_blank" rel="noopener">https://philip-trauner.me/blog/post/python-tips-dynamic-function-definition</a></p>
<p>基于 MIT 许可协议</p>
<p>在 Python 中，没有可以在运行时简化函数定义的语法糖。然而，这并不意味着它就不可能，或者是难以实现。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">from types import FunctionType</span><br><span class="line"></span><br><span class="line">foo_code = compile(&apos;def foo(): return &quot;bar&quot;&apos;, &quot;&lt;string&gt;&quot;, &quot;exec&quot;)</span><br><span class="line">foo_func = FunctionType(foo_code.co_consts[0], globals(), &quot;foo&quot;)</span><br><span class="line"></span><br><span class="line">print(foo_func())</span><br></pre></td></tr></table></figure>
<p>输出：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">bar</span><br></pre></td></tr></table></figure>
<h2 id="剖析"><a href="#剖析" class="headerlink" title="剖析"></a>剖析</h2><p>逐行检视代码，你会发现语言/解释器的屏障是多么脆弱。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; from types import FunctionType</span><br></pre></td></tr></table></figure>
<p>Python 文档通常不会列出那些非用于手动创建的类的特征（这是完全合理的）。有三种方法可以解决这个问题：help()、inspect（无法查看内置方法）、以及最后的解决方案，即查看 CPython 源代码。</p>
<p>在本例中，help() 与 inspect 都可以完成工作，但是查看实际的源代码，则会揭示出关于数据类型的更多细节。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; from inspect import signature</span><br><span class="line">&gt;&gt;&gt; signature(FunctionType)</span><br><span class="line">&lt;Signature (code, globals, name=None, argdefs=None, closure=None)&gt;</span><br></pre></td></tr></table></figure>
<h3 id="1-code"><a href="#1-code" class="headerlink" title="1. code"></a>1. code</h3><p>内部是一个<code>PyCodeobject</code> ，作为<code>types.CodeType</code> 对外开放。非内置方法拥有一个<code>__code__</code> 属性，该属性保存了相应的代码对象。利用内置的 compile() 方法，可以在运行期创建<code>types.CodeType</code> 对象。</p>
<h3 id="2-globals"><a href="#2-globals" class="headerlink" title="2. globals"></a>2. globals</h3><p>如果一个函数引用的变量不是在局部定义的，而是作为参数转入、由默认参数值提供、或者通过闭包上下文提供，则它会在 globals 字典中查找。</p>
<p>内置的 globals() 方法会返回一个对当前模块的全局符号表（global symbol table）的<strong>引用</strong> ，因此能被用来提供一个总是与当前表的状态相一致的字典。传入任意其它的字典也是可以的（FunctionType((lambda: bar).__code__, {“bar” : “baz”}, “foo”)() == “baz”）。</p>
<h3 id="3-name（可选）"><a href="#3-name（可选）" class="headerlink" title="3. name（可选）"></a>3. name（可选）</h3><p>控制所返回的函数的<code>__name__</code> 属性。只真正对 lambdas 有用（由于匿名性，它们通常没有名称），并且重命名函数。</p>
<h3 id="4-argdefs（可选）"><a href="#4-argdefs（可选）" class="headerlink" title="4. argdefs（可选）"></a>4. argdefs（可选）</h3><p>通过传入一个包含任意类型的对象的元组，提供了一个方式来供应默认参数值（def foo(bar=”baz”)）。（FunctionType((lambda bar: bar).__code__, {}, “foo”, (10,))() == 10）。</p>
<h3 id="5-closure（可选）"><a href="#5-closure（可选）" class="headerlink" title="5. closure（可选）"></a>5. closure（可选）</h3><p>（如果需要在 CPython（PyPy，Jython，…）以外的其它 Python VM 中执行，可能不应该触及，因为它严重地依赖于实现细节）。</p>
<p>一个<code>cell</code> 对象的元组。创建 cell 对象并非完全是直截了当的，因为需要调用 CPython 的内部组件，但有一个库可以令它更加方便：<code>exalt</code> （无耻的广告）。（译注：这个库是作者开发的。）</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; foo_code = compile(&apos;def foo(): return &quot;bar&quot;&apos;, &quot;&lt;string&gt;&quot;, &quot;exec&quot;)</span><br></pre></td></tr></table></figure>
<p>compile() 是一个内置方法，因此同时也是文档丰富的。</p>
<p>exec 模式被用到，因为定义函数需要用多个语句。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; foo_func = FunctionType(foo_code.co_consts[0], globals(), &quot;foo&quot;)</span><br></pre></td></tr></table></figure>
<p>聚合全部内容，并将动态创建的函数指定给一个变量。</p>
<p>那个被前一句代码编译成的函数，成为了生成的代码对象的第一个常量，因此仅仅指向 foo_code 是不充分的。这是 exec 模式的直接后果，因为生成的代码对象可以包含多个常量。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; print(foo_func())</span><br></pre></td></tr></table></figure>
<p>动态生成的函数可以像其它函数一样被调用。</p>
<h2 id="结尾"><a href="#结尾" class="headerlink" title="结尾"></a>结尾</h2><ul>
<li>除了做实验，需要用到动态创建函数的场景很少。</li>
<li>玩耍（Toying around） Python 的内部构件是一种深入学习这门语言的好方法。</li>
<li>如果需要，可以毫不费力地越过解释器/语言的界线。</li>
</ul>
<p>还是一如既往地：<strong>不要滥用语言</strong> （好吧，一点点也无妨，对吧？）</p>
<p>——–（译文完）——–</p>
<p><strong>花下猫语：</strong> 在上一篇《<a href="https://mp.weixin.qq.com/s/4eWQmJ15QZabNViePCDmNw" target="_blank" rel="noopener">Python进阶：如何将字符串常量转为变量？</a>》中，我介绍了两种<strong>动态修改变量</strong> 的方法（globals() 与 exec()）。写完之后，我偶然发现，在自己列的“计划转载清单”中，有这一篇相关的文章，它介绍了<strong>动态定义函数</strong> 的方法。因为它的相关度太大，而篇幅又是那么小（核心代码只有三行，文中其它内容都是在解释其背后的原理），我觉得如果翻译出来的话，效果会更好，所以就抓紧时间翻译出来了。建议与前一篇文章配合阅读。</p>
<p><img src="http://ww1.sinaimg.cn/large/68b02e3bgy1g08dfkg8sdj2076076t96.jpg" alt></p>
<p>公众号【<strong>Python猫</strong>】， 专注Python技术、数据科学和深度学习，力图创造一个有趣又有用的学习分享平台。本号连载优质的系列文章，有喵星哲学猫系列、Python进阶系列、好书推荐系列、优质英文推荐与翻译等等，欢迎关注哦。PS：后台回复“<strong>爱学习</strong>”，免费获得一份学习大礼包。</p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://chinesehuazhou.github.io/2019/05/03/Python进阶/Python进阶：迭代器与迭代器切片/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="John Doe">
      <meta itemprop="description" content>
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="豌豆花下猫">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2019/05/03/Python进阶/Python进阶：迭代器与迭代器切片/" itemprop="url">未命名</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2019-05-03T21:21:22+08:00">
                2019-05-03
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="Python进阶：迭代器与迭代器切片"><a href="#Python进阶：迭代器与迭代器切片" class="headerlink" title="Python进阶：迭代器与迭代器切片"></a>Python进阶：迭代器与迭代器切片</h1><p>在前两篇关于 Python 切片的文章中，我们学习了切片的基础用法、高级用法、使用误区，以及自定义对象如何实现切片用法（相关链接见文末）。本文是切片系列的第三篇，主要内容是迭代器切片。</p>
<p>迭代器是 Python 中独特的一种高级特性，而切片也是一种高级特性，两者相结合，会产生什么样的结果呢？</p>
<h2 id="1、迭代与迭代器"><a href="#1、迭代与迭代器" class="headerlink" title="1、迭代与迭代器"></a>1、迭代与迭代器</h2><p>首先，有几个基本概念要澄清：迭代、可迭代对象、迭代器。</p>
<p><code>迭代</code> 是一种遍历容器类型对象（例如字符串、列表、字典等等）的方式，例如，我们说迭代一个字符串“abc”，指的就是从左往右依次地、逐个地取出它的全部字符的过程。（PS：汉语中迭代一词有循环反复、层层递进的意思，但 Python 中此词要理解成<strong>单向水平线性</strong> 的，如果你不熟悉它，我建议直接将其理解为遍历。）</p>
<p>那么，怎么写出迭代操作的指令呢？最通用的书写语法就是 for 循环。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># for循环实现迭代过程</span></span><br><span class="line"><span class="keyword">for</span> char <span class="keyword">in</span> <span class="string">"abc"</span>:</span><br><span class="line">    print(char, end=<span class="string">" "</span>)</span><br><span class="line"><span class="comment"># 输出结果：a b c</span></span><br></pre></td></tr></table></figure>
<p>for 循环可以实现迭代的过程，但是，并非所有对象都可以用于 for 循环，例如，上例中若将字符串“abc”换成任意整型数字，则会报错： ‘int’ object is not iterable .</p>
<p>这句报错中的单词“iterable”指的是“可迭代的”，即 int 类型不是可迭代的。而字符串（string）类型是可迭代的，同样地，列表、元组、字典等类型，都是可迭代的。</p>
<p>那怎么判断一个对象是否可迭代呢？为什么它们是可迭代的呢？怎么让一个对象可迭代呢？</p>
<p>要使一个对象可迭代，就要实现可迭代协议，即需要实现<code>__iter__()</code> 魔术方法，换言之，只要实现了这个魔术方法的对象都是可迭代对象。</p>
<p>那怎么判断一个对象是否实现了这个方法呢？除了上述的 for 循环外，我知道还有四种方法：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 方法1：dir()查看__iter__</span></span><br><span class="line">dir(<span class="number">2</span>)     <span class="comment"># 没有，略</span></span><br><span class="line">dir(<span class="string">"abc"</span>) <span class="comment"># 有，略</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 方法2：isinstance()判断</span></span><br><span class="line"><span class="keyword">import</span> collections</span><br><span class="line">isinstance(<span class="number">2</span>, collections.Iterable)     <span class="comment"># False</span></span><br><span class="line">isinstance(<span class="string">"abc"</span>, collections.Iterable) <span class="comment"># True</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 方法3：hasattr()判断</span></span><br><span class="line">hasattr(<span class="number">2</span>,<span class="string">"__iter__"</span>)     <span class="comment"># False</span></span><br><span class="line">hasattr(<span class="string">"abc"</span>,<span class="string">"__iter__"</span>) <span class="comment"># True</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 方法4：用iter()查看是否报错</span></span><br><span class="line">iter(<span class="number">2</span>)     <span class="comment"># 报错：'int' object is not iterable</span></span><br><span class="line">iter(<span class="string">"abc"</span>) <span class="comment"># &lt;str_iterator at 0x1e2396d8f28&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">### PS：判断是否可迭代，还可以查看是否实现__getitem__，为方便描述，本文从略。</span></span><br></pre></td></tr></table></figure>
<p>这几种方法中最值得一提的是 iter() 方法，它是 Python 的内置方法，其作用是<strong>将可迭代对象变成迭代器</strong> 。这句话可以解析出两层意思：（1）可迭代对象跟迭代器是两种东西；（2）可迭代对象能变成迭代器。</p>
<p>实际上，迭代器必然是可迭代对象，但可迭代对象不一定是迭代器。两者有多大的区别呢？</p>
<p><img src="http://ww1.sinaimg.cn/large/68b02e3bly1fynwz67tj7j20vq0bxt9t.jpg" alt></p>
<p>如上图蓝圈所示，普通可迭代对象与迭代器的最关键区别可概括为：<strong>一同两不同</strong> ，所谓“一同”，即两者都是可迭代的（<code>__iter__</code>），所谓“两不同”，即可迭代对象在转化为迭代器后，它会丢失一些属性（<code>__getitem__</code>），同时也增加一些属性（<code>__next__</code>）。</p>
<p>首先看看增加的属性 <code>__next__</code> ， 它是迭代器之所以是迭代器的关键，事实上，我们正是把同时实现了 <code>__iter__</code> 方法 和 <code>__next__</code> 方法的对象定义为迭代器的。</p>
<p>有了多出来的这个属性，可迭代对象不需要借助外部的 for 循环语法，就能实现自我的迭代/遍历过程。我发明了两个概念来描述这两种遍历过程（PS：为了易理解，这里称遍历，实际也可称为迭代）：<code>它遍历</code> 指的是通过外部语法而实现的遍历，<code>自遍历</code> 指的是通过自身方法实现的遍历。</p>
<p>借助这两个概念，我们说，可迭代对象就是能被“它遍历”的对象，而迭代器是在此基础上，还能做到“自遍历”的对象。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">ob1 = <span class="string">"abc"</span></span><br><span class="line">ob2 = iter(<span class="string">"abc"</span>)</span><br><span class="line">ob3 = iter(<span class="string">"abc"</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># ob1它遍历</span></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> ob1:</span><br><span class="line">    print(i, end = <span class="string">" "</span>)   <span class="comment"># a b c</span></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> ob1:</span><br><span class="line">    print(i, end = <span class="string">" "</span>)   <span class="comment"># a b c</span></span><br><span class="line"><span class="comment"># ob1自遍历</span></span><br><span class="line">ob1.__next__()  <span class="comment"># 报错： 'str' object has no attribute '__next__'</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># ob2它遍历</span></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> ob2:</span><br><span class="line">    print(i, end = <span class="string">" "</span>)   <span class="comment"># a b c    </span></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> ob2:</span><br><span class="line">    print(i, end = <span class="string">" "</span>)   <span class="comment"># 无输出</span></span><br><span class="line"><span class="comment"># ob2自遍历</span></span><br><span class="line">ob2.__next__()  <span class="comment"># 报错：StopIteration</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># ob3自遍历</span></span><br><span class="line">ob3.__next__()  <span class="comment"># a</span></span><br><span class="line">ob3.__next__()  <span class="comment"># b</span></span><br><span class="line">ob3.__next__()  <span class="comment"># c</span></span><br><span class="line">ob3.__next__()  <span class="comment"># 报错：StopIteration</span></span><br></pre></td></tr></table></figure>
<p>通过上述例子可看出，迭代器的优势在于支持自遍历，同时，它的特点是单向非循环的，一旦完成遍历，再次调用就会报错。</p>
<p>对此，我想到一个比方：普通可迭代对象就像是子弹匣，它遍历就是取出子弹，在完成操作后又装回去，所以可以反复遍历（即多次调用for循环，返回相同结果）；而迭代器就像是装载了子弹匣且不可拆卸的枪，进行它遍历或者自遍历都是发射子弹，这是消耗性的遍历，是无法复用的（即遍历会有尽头）。</p>
<p>写了这么多，稍微小结一下：<strong>迭代是一种遍历元素的方式，按照实现方式划分，有外部迭代与内部迭代两种，支持外部迭代（它遍历）的对象就是可迭代对象，而同时还支持内部迭代（自遍历）的对象就是迭代器；按照消费方式划分，可分为复用型迭代与一次性迭代，普通可迭代对象是复用型的，而迭代器是一次性的。</strong> </p>
<h2 id="2、迭代器切片"><a href="#2、迭代器切片" class="headerlink" title="2、迭代器切片"></a>2、迭代器切片</h2><p>前面提到了“一同两不同”，最后的不同是，普通可迭代对象在转化成迭代器的过程中会丢失一些属性，其中关键的属性是 <code>__getitem__</code> 。在《<a href="https://mp.weixin.qq.com/s/QTodsriWW_gESvmJPD1EYg" target="_blank" rel="noopener">Python进阶：自定义对象实现切片功能</a>》中，我曾介绍了这个魔术方法，并用它实现了自定义对象的切片特性。</p>
<p>那么问题来了：为什么迭代器不继承这个属性呢？</p>
<p>首先，迭代器使用的是消耗型的遍历，这意味着它充满不确定性，即其长度与索引键值对是动态衰减的，所以很难 get 到它的 item ，也就不再需要 <code>__getitem__</code> 属性了。其次，若强行给迭代器加上这个属性，这并不合理，正所谓强扭的瓜不甜……</p>
<p>由此，新的问题来了：既然会丢失这么重要的属性（还包括其它未标识的属性），为什么还要使用迭代器呢？</p>
<p>这个问题的答案在于，迭代器拥有不可替代的强大的有用的功能，使得 Python 要如此设计它。限于篇幅，此处不再展开，后续我会专门填坑此话题。</p>
<p>还没完，死缠烂打的问题来了：能否令迭代器拥有这个属性呢，即令迭代器继续支持切片呢？</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">hi = <span class="string">"欢迎关注公众号：Python猫"</span></span><br><span class="line">it = iter(hi)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 普通切片</span></span><br><span class="line">hi[<span class="number">-7</span>:] <span class="comment"># Python猫</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 反例：迭代器切片</span></span><br><span class="line">it[<span class="number">-7</span>:] <span class="comment"># 报错：'str_iterator' object is not subscriptable</span></span><br></pre></td></tr></table></figure>
<p>迭代器因为缺少<code>__getitem__</code> ，因此不能使用普通的切片语法。想要实现切片，无非两种思路：一是自己造轮子，写实现的逻辑；二是找到封装好的轮子。</p>
<p>Python 的 itertools 模块就是我们要找的轮子，用它提供的方法可轻松实现迭代器切片。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> itertools</span><br><span class="line"></span><br><span class="line"><span class="comment"># 例1：简易迭代器</span></span><br><span class="line">s = iter(<span class="string">"123456789"</span>)</span><br><span class="line"><span class="keyword">for</span> x <span class="keyword">in</span> itertools.islice(s, <span class="number">2</span>, <span class="number">6</span>):</span><br><span class="line">    print(x, end = <span class="string">" "</span>)   <span class="comment"># 输出：3 4 5 6</span></span><br><span class="line"><span class="keyword">for</span> x <span class="keyword">in</span> itertools.islice(s, <span class="number">2</span>, <span class="number">6</span>):</span><br><span class="line">    print(x, end = <span class="string">" "</span>)   <span class="comment"># 输出：9</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 例2：斐波那契数列迭代器</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Fib</span><span class="params">()</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self)</span>:</span></span><br><span class="line">        self.a, self.b = <span class="number">1</span>, <span class="number">1</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__iter__</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">            <span class="keyword">yield</span> self.a</span><br><span class="line">            self.a, self.b = self.b, self.a + self.b</span><br><span class="line">f = iter(Fib())</span><br><span class="line"><span class="keyword">for</span> x <span class="keyword">in</span> itertools.islice(f, <span class="number">2</span>, <span class="number">6</span>):</span><br><span class="line">    print(x, end = <span class="string">" "</span>)  <span class="comment"># 输出：2 3 5 8</span></span><br><span class="line"><span class="keyword">for</span> x <span class="keyword">in</span> itertools.islice(f, <span class="number">2</span>, <span class="number">6</span>):</span><br><span class="line">    print(x, end = <span class="string">" "</span>)  <span class="comment"># 输出：34 55 89 144</span></span><br></pre></td></tr></table></figure>
<p>itertools 模块的 islice() 方法将迭代器与切片完美结合，终于回答了前面的问题。然而，迭代器切片跟普通切片相比，前者有很多局限性。首先，这个方法不是“纯函数”（纯函数需遵守“相同输入得到相同输出”的原则，之前在《<a href="https://mp.weixin.qq.com/s/2l_erf55IMvT4Tz0AGWCUQ" target="_blank" rel="noopener">来自Kenneth Reitz大神的建议：避免不必要的面向对象编程</a>》提到过）；其次，它只支持正向切片，且不支持负数索引，这都是由迭代器的损耗性所决定的。</p>
<p>那么，我不禁要问：itertools 模块的切片方法用了什么实现逻辑呢？下方是官网提供的源码：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">islice</span><span class="params">(iterable, *args)</span>:</span></span><br><span class="line">    <span class="comment"># islice('ABCDEFG', 2) --&gt; A B</span></span><br><span class="line">    <span class="comment"># islice('ABCDEFG', 2, 4) --&gt; C D</span></span><br><span class="line">    <span class="comment"># islice('ABCDEFG', 2, None) --&gt; C D E F G</span></span><br><span class="line">    <span class="comment"># islice('ABCDEFG', 0, None, 2) --&gt; A C E G</span></span><br><span class="line">    s = slice(*args)</span><br><span class="line">    <span class="comment"># 索引区间是[0,sys.maxsize]，默认步长是1</span></span><br><span class="line">    start, stop, step = s.start <span class="keyword">or</span> <span class="number">0</span>, s.stop <span class="keyword">or</span> sys.maxsize, s.step <span class="keyword">or</span> <span class="number">1</span></span><br><span class="line">    it = iter(range(start, stop, step))</span><br><span class="line">    <span class="keyword">try</span>:</span><br><span class="line">        nexti = next(it)</span><br><span class="line">    <span class="keyword">except</span> StopIteration:</span><br><span class="line">        <span class="comment"># Consume *iterable* up to the *start* position.</span></span><br><span class="line">        <span class="keyword">for</span> i, element <span class="keyword">in</span> zip(range(start), iterable):</span><br><span class="line">            <span class="keyword">pass</span></span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line">    <span class="keyword">try</span>:</span><br><span class="line">        <span class="keyword">for</span> i, element <span class="keyword">in</span> enumerate(iterable):</span><br><span class="line">            <span class="keyword">if</span> i == nexti:</span><br><span class="line">                <span class="keyword">yield</span> element</span><br><span class="line">                nexti = next(it)</span><br><span class="line">    <span class="keyword">except</span> StopIteration:</span><br><span class="line">        <span class="comment"># Consume to *stop*.</span></span><br><span class="line">        <span class="keyword">for</span> i, element <span class="keyword">in</span> zip(range(i + <span class="number">1</span>, stop), iterable):</span><br><span class="line">            <span class="keyword">pass</span></span><br></pre></td></tr></table></figure>
<p>islice() 方法的索引方向是受限的，但它也提供了一种可能性：即允许你对一个无穷的（在系统支持范围内）迭代器进行切片的能力。这是迭代器切片最具想象力的用途场景。</p>
<p>除此之外，迭代器切片还有一个很实在的应用场景：读取文件对象中给定行数范围的数据。</p>
<p>在《<a href="https://mp.weixin.qq.com/s/Md07VoaULda7qnMO4ob7Ww" target="_blank" rel="noopener">给Python学习者的文件读写指南（含基础与进阶，建议收藏）</a>》里，我介绍了从文件中读取内容的几种方法：readline() 比较鸡肋，不咋用；read() 适合读取内容较少的情况，或者是需要一次性处理全部内容的情况；而 readlines() 用的较多，比较灵活，每次迭代读取内容，既减少内存压力，又方便逐行对数据处理。</p>
<p>虽然 readlines() 有迭代读取的优势，但它是从头到尾逐行读取，若文件有几千行，而我们只想要读取少数特定行（例如第1000-1009行），那它还是效率太低了。考虑到<strong>文件对象天然就是迭代器</strong> ，我们可以使用迭代器切片先行截取，然后再处理，如此效率将大大地提升。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># test.txt 文件内容</span></span><br><span class="line"><span class="string">'''</span></span><br><span class="line"><span class="string">猫</span></span><br><span class="line"><span class="string">Python猫</span></span><br><span class="line"><span class="string">python is a cat.</span></span><br><span class="line"><span class="string">this is the end.</span></span><br><span class="line"><span class="string">'''</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">from</span> itertools <span class="keyword">import</span> islice</span><br><span class="line"><span class="keyword">with</span> open(<span class="string">'test.txt'</span>,<span class="string">'r'</span>,encoding=<span class="string">'utf-8'</span>) <span class="keyword">as</span> f:</span><br><span class="line">    print(hasattr(f, <span class="string">"__next__"</span>))  <span class="comment"># 判断是否迭代器</span></span><br><span class="line">    content = islice(f, <span class="number">2</span>, <span class="number">4</span>)</span><br><span class="line">    <span class="keyword">for</span> line <span class="keyword">in</span> content:</span><br><span class="line">        print(line.strip())</span><br><span class="line"><span class="comment">### 输出结果：</span></span><br><span class="line"><span class="literal">True</span></span><br><span class="line">python <span class="keyword">is</span> a cat.</span><br><span class="line">this <span class="keyword">is</span> the end.</span><br></pre></td></tr></table></figure>
<h2 id="3、小结"><a href="#3、小结" class="headerlink" title="3、小结"></a>3、小结</h2><p>好啦，今天的学习就到这，小结一下：迭代器是一种特殊的可迭代对象，可用于它遍历与自遍历，但遍历过程是损耗型的，不具备循环复用性，因此，迭代器本身不支持切片操作；通过借助 itertools 模块，我们能实现迭代器切片，将两者的优势相结合，其主要用途在于截取大型迭代器（如无限数列、超大文件等等）的片段，实现精准的处理，从而大大地提升性能与效率。</p>
<p><strong>切片系列：</strong> </p>
<p>《<a href="https://mp.weixin.qq.com/s/fwZnvcQ_u-fYLFeQaYkJLw" target="_blank" rel="noopener">Python进阶：切片的误区与高级用法</a>》</p>
<p>《<a href="https://mp.weixin.qq.com/s/QTodsriWW_gESvmJPD1EYg" target="_blank" rel="noopener">Python进阶：自定义对象实现切片功能</a>》</p>
<p><strong>相关链接：</strong> </p>
<p>《<a href="https://docs.python.org/3.7/library/itertools.html#itertools.islice" target="_blank" rel="noopener">官网的itertools模块介绍</a>》</p>
<p>《<a href="https://mp.weixin.qq.com/s/2l_erf55IMvT4Tz0AGWCUQ" target="_blank" rel="noopener">来自Kenneth Reitz大神的建议：避免不必要的面向对象编程</a>》</p>
<p>《<a href="https://mp.weixin.qq.com/s/Md07VoaULda7qnMO4ob7Ww" target="_blank" rel="noopener">给Python学习者的文件读写指南（含基础与进阶，建议收藏）</a>》</p>
<p>-—————-</p>
<p>本文原创并首发于微信公众号【Python猫】，后台回复“爱学习”，免费获得20+本精选电子书。</p>
<p>2018-12-31 更新声明：切片系列文章本是分三篇写成，现已合并成一篇。合并后，修正了一些严重的错误（如自定义序列切片的部分），还对行文结构与章节衔接做了大量改动。原系列的单篇就不删除了，毕竟也是有单独成篇的作用。特此声明，请阅读改进版—— Python进阶：全面解读高级特性之切片！<a href="https://mp.weixin.qq.com/s/IRAjR-KHZBPEEkdiofseGQ" target="_blank" rel="noopener">https://mp.weixin.qq.com/s/IRAjR-KHZBPEEkdiofseGQ</a></p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://chinesehuazhou.github.io/2019/05/03/Python进阶/Python进阶：设计模式之迭代器模式/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="John Doe">
      <meta itemprop="description" content>
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="豌豆花下猫">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2019/05/03/Python进阶/Python进阶：设计模式之迭代器模式/" itemprop="url">未命名</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2019-05-03T21:21:22+08:00">
                2019-05-03
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="Python进阶：设计模式之迭代器模式"><a href="#Python进阶：设计模式之迭代器模式" class="headerlink" title="Python进阶：设计模式之迭代器模式"></a>Python进阶：设计模式之迭代器模式</h1><p>在软件开发领域中，人们经常会用到这一个概念——“设计模式”（design pattern），它是一种针对软件设计的共性问题而提出的解决方案。在一本圣经级的书籍《设计模式：可复用面向对象软件的基础》（1991年，Design Patterns - Elements of Reusable Object-Oriented Software）中，它提出了23种设计模式。迭代器模式就是其中的一种，在各种编程语言中都得到了广泛的应用。</p>
<p>本文将谈谈 Python 中的迭代器模式，主要内容：什么是迭代器模式、Python 如何实现迭代器模式、itertools 模块创建迭代器的方法、其它运用迭代器的场景等等，期待与你共同学习进步。</p>
<h2 id="1、什么是迭代器模式？"><a href="#1、什么是迭代器模式？" class="headerlink" title="1、什么是迭代器模式？"></a>1、什么是迭代器模式？</h2><p>维基百科有如下定义：</p>
<blockquote>
<p>迭代器是一种最简单也最常见的设计模式。它可以让用户透过特定的接口巡访容器中的每一个元素而不用了解底层的实现。——维基百科</p>
</blockquote>
<p>简单地说，迭代器模式就是一种通用性的可以遍历容器类型（如序列类型、集合类型等）的实现方式。使用迭代器模式，可以不关心遍历的对象具体是什么（如字符串、列表、字典等等），也不需要关心遍历的实现算法是什么，它关心的是从容器中遍历/取出元素的结果。</p>
<p>按遍历方式划分，迭代器可分为内部迭代器与外部迭代器，它们的区别在于执行迭代动作与维持迭代状态的不同。</p>
<p>通常而言，迭代器是一次性的，当迭代过一轮后，再次迭代将获取不到元素。</p>
<h2 id="2、Python的迭代器模式"><a href="#2、Python的迭代器模式" class="headerlink" title="2、Python的迭代器模式"></a>2、Python的迭代器模式</h2><p>由于迭代器模式的使用太常见了，所以大多数编程语言都给常见的容器类型实现了它，例如 Java 中的 Collection，List、Set、Map等。在 Java 中使用迭代器遍历 List 可以这么写：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">List&lt;String&gt; list = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">Iterator&lt;String&gt; iterator = list.iterator();</span><br><span class="line"><span class="keyword">while</span>(iterator.hasNext())&#123;</span><br><span class="line">    System.out.println(iterator.next());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>ArrayList 类通过自身的 iterator() 方法获得一个迭代器 iterator，然后由该迭代器实例来落实遍历过程。</p>
<p>Python 当然也应用了迭代器模式，但它的实现思路跟上例却不太一样。</p>
<p>首先，Python 认为遍历容器类型并不一定要用到迭代器，因此设计了可迭代对象。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">list = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>]</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> list:</span><br><span class="line">    print(i,end=<span class="string">" "</span>) <span class="comment"># 1 2 3 4</span></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> list:</span><br><span class="line">    print(i,end=<span class="string">" "</span>) <span class="comment"># 1 2 3 4</span></span><br></pre></td></tr></table></figure>
<p>上例中的 list 是可迭代对象（Iterable），但并不是迭代器（虽然在底层实现时用了迭代器的部分思想）。Python 抓住了迭代器模式的本质，即是“迭代”，赋予了它极高的地位。</p>
<p>如此设计的好处显而易见：（1）写法简便，用意直白；（2）可重复迭代，避免一次性迭代器的缺陷；（3）不需要创建迭代器，减少开销。</p>
<p>可迭代对象可看作是广义的迭代器，同时，Python 也设计了普通意义的狭义的迭代器。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">list = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>]</span><br><span class="line">it = iter(list)</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> it:</span><br><span class="line">    print(i,end=<span class="string">" "</span>) <span class="comment"># 1 2 3 4</span></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> it:</span><br><span class="line">    print(i,end=<span class="string">" "</span>) <span class="comment"># 无输出</span></span><br></pre></td></tr></table></figure>
<p>上例中的 iter() 方法会将可迭代对象变成一个迭代器。从输出结果可以看出，该迭代器的迭代过程是一次性的。</p>
<p>由此看来，<strong>Python 其实是将“迭代器模式”一拆为二来实现：一是可迭代思想，广泛播种于容器类型的对象中，使它们都可迭代；一是迭代器，一种特殊的可迭代对象，承担普通意义上的迭代器所特有的迭代任务。</strong> </p>
<p>同时，它还提供了将可迭代对象转化为迭代器的简易方法，如此安排，真是将迭代器模式的效力发挥到了极致。（关于可迭代对象与迭代器的更多区别、以及它们的实现原理，请参见《<a href="https://mp.weixin.qq.com/s/DIhwoJE3o0kKw3kzZKysag" target="_blank" rel="noopener">Python进阶：迭代器与迭代器切片</a>》）</p>
<h2 id="3、创建迭代器"><a href="#3、创建迭代器" class="headerlink" title="3、创建迭代器"></a>3、创建迭代器</h2><p>创建迭代器有如下方式：（1）iter() 方法，将可迭代对象转化成迭代器；（2）<code>__iter__()</code> 与 <code>__next__()</code> 魔术方法，定义类实现这两个魔术方法；（3）itertools 模块，使用内置模块生成迭代器；（4）其它创建方法，如 zip() 、map() 、enumerate() 等等。</p>
<p>四类方法各有适用场所，本节重点介绍 itertools 模块。它可以创建三类迭代器：无限迭代器、有限迭代器与组合迭代器。</p>
<h3 id="3-1-无限迭代器"><a href="#3-1-无限迭代器" class="headerlink" title="3.1 无限迭代器"></a>3.1 无限迭代器</h3><p><code>count(start=0, step=1)</code> ：创建一个从 start (默认值为 0) 开始，以 step (默认值为 1) 为步长的的无限整数迭代器。</p>
<p><code>cycle(iterable)</code> ：对可迭代对象的元素反复执行循环。</p>
<p><code>repeat(object [,times])</code> ：反复生成 object 至无限，或者到给定的 times 次。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> itertools</span><br><span class="line">co = itertools.count()</span><br><span class="line">cy = itertools.cycle(<span class="string">'ABC'</span>)</span><br><span class="line">re = itertools.repeat(<span class="string">'A'</span>, <span class="number">30</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 注意：请分别执行；以下写法未加终止判断，只能按 Ctrl+C 退出</span></span><br><span class="line"><span class="keyword">for</span> n <span class="keyword">in</span> co:</span><br><span class="line">    print(n,end=<span class="string">" "</span>)  <span class="comment"># 0 1 2 3 4......</span></span><br><span class="line"><span class="keyword">for</span> n <span class="keyword">in</span> cy:</span><br><span class="line">    print(n,end=<span class="string">" "</span>)  <span class="comment"># A B C A B C A B......</span></span><br><span class="line"><span class="keyword">for</span> n <span class="keyword">in</span> re:</span><br><span class="line">    print(n,end=<span class="string">" "</span>)  <span class="comment"># A A A A A A A A....(30个)</span></span><br></pre></td></tr></table></figure>
<h3 id="3-2-有限迭代器"><a href="#3-2-有限迭代器" class="headerlink" title="3.2 有限迭代器"></a>3.2 有限迭代器</h3><p><img src="http://ww1.sinaimg.cn/large/68b02e3bgy1fyskexyzmnj20sz0mbdhb.jpg" alt></p>
<p>以上方法，比较常用的有：chain() 将多个可迭代对象（可以是不同类型）连接成一个大迭代器；compress() 方法根据真假过滤器筛选元素；groupby() 把迭代器中相邻的重复元素挑出来放在一起；islice() 方法返回迭代器切片（用法参见《<a href="https://mp.weixin.qq.com/s/DIhwoJE3o0kKw3kzZKysag" target="_blank" rel="noopener">Python进阶：迭代器与迭代器切片</a>》）；tee() 方法根据可迭代对象创建 n 个（默认2个）迭代器副本。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">for c in itertools.chain(&apos;ABC&apos;, [1,2,3]):</span><br><span class="line">    print(c,end=&quot; &quot;)</span><br><span class="line"># 输出结果：A B C 1 2 3</span><br><span class="line"></span><br><span class="line">for c in itertools.compress(&apos;ABCDEF&apos;, [1, 1, 0, 1, 0, 1]):</span><br><span class="line">    print(c,end=&quot; &quot;)</span><br><span class="line"># 输出结果：A B D F</span><br><span class="line"></span><br><span class="line">for key, group in itertools.groupby(&apos;aaabbbaaccd&apos;):</span><br><span class="line">    print(key, &apos;:&apos;, list(group))</span><br><span class="line"># 输出结果：</span><br><span class="line">a : [&apos;a&apos;, &apos;a&apos;, &apos;a&apos;]</span><br><span class="line">b : [&apos;b&apos;, &apos;b&apos;, &apos;b&apos;]</span><br><span class="line">a : [&apos;a&apos;, &apos;a&apos;]</span><br><span class="line">c : [&apos;c&apos;, &apos;c&apos;]</span><br><span class="line">d : [&apos;d&apos;]</span><br><span class="line"></span><br><span class="line">itertools.tee(&apos;abc&apos;, 3)</span><br><span class="line"># 输出结果：(&lt;itertools._tee at 0x1fc72c08108&gt;,</span><br><span class="line"> &lt;itertools._tee at 0x1fc73f91d08&gt;,</span><br><span class="line"> &lt;itertools._tee at 0x1fc73efc248&gt;)</span><br></pre></td></tr></table></figure>
<h3 id="3-3-组合迭代器"><a href="#3-3-组合迭代器" class="headerlink" title="3.3 组合迭代器"></a>3.3 组合迭代器</h3><p>product() ：求解多个可迭代对象的笛卡尔积。</p>
<p>permutations() ：求解可迭代对象的元素的全排列。</p>
<p>combinations()：求解可迭代对象的元素的组合。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">for i in itertools.product(&apos;ABC&apos;, [1,2]):</span><br><span class="line">    print(i, end=&quot; &quot;)</span><br><span class="line"># 输出结果：(&apos;A&apos;, 1) (&apos;A&apos;, 2) (&apos;B&apos;, 1) (&apos;B&apos;, 2) (&apos;C&apos;, 1) (&apos;C&apos;, 2)</span><br><span class="line"></span><br><span class="line">for i in itertools.permutations(&apos;ABC&apos;, 2):</span><br><span class="line">    print(i, end=&quot; &quot;)</span><br><span class="line"># 输出结果：(&apos;A&apos;, &apos;B&apos;) (&apos;A&apos;, &apos;C&apos;) (&apos;B&apos;, &apos;A&apos;) (&apos;B&apos;, &apos;C&apos;) (&apos;C&apos;, &apos;A&apos;) (&apos;C&apos;, &apos;B&apos;)</span><br><span class="line"></span><br><span class="line">for i in itertools.combinations(&apos;ABC&apos;, 2):</span><br><span class="line">    print(i, end=&quot; &quot;)</span><br><span class="line"># 输出结果：(&apos;A&apos;, &apos;B&apos;) (&apos;A&apos;, &apos;C&apos;) (&apos;B&apos;, &apos;C&apos;)</span><br><span class="line"></span><br><span class="line">for i in itertools.combinations(&apos;ABCD&apos;, 3):</span><br><span class="line">    print(i, end=&quot; &quot;)</span><br><span class="line"># 输出结果：(&apos;A&apos;, &apos;B&apos;, &apos;C&apos;) (&apos;A&apos;, &apos;B&apos;, &apos;D&apos;) (&apos;A&apos;, &apos;C&apos;, &apos;D&apos;) (&apos;B&apos;, &apos;C&apos;, &apos;D&apos;)</span><br></pre></td></tr></table></figure>
<h2 id="4、强大的内置迭代器方法"><a href="#4、强大的内置迭代器方法" class="headerlink" title="4、强大的内置迭代器方法"></a>4、强大的内置迭代器方法</h2><p>迭代器模式的使用场景实在太普遍了，而 Python 也为迭代器的顺利使用而提供了很多便利的条件，本节将介绍相关的几个内置方法。这些方法非常常用而且强大，是 Python 进阶的必会内容。</p>
<h3 id="4-1-zip-方法"><a href="#4-1-zip-方法" class="headerlink" title="4.1 zip() 方法"></a>4.1 zip() 方法</h3><p>zip() 方法可以同时迭代多个序列，并各取一个元素，生成一个可返回元组的迭代器。此迭代器的长度以较短序列的长度保持一致，若想生成较长序列的长度，需要使用 itertools 模块的 zip_longest() 方法。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">import itertools</span><br><span class="line"></span><br><span class="line">a = [1, 2, 3]</span><br><span class="line">b = [&apos;w&apos;, &apos;x&apos;, &apos;y&apos;, &apos;z&apos;]</span><br><span class="line"></span><br><span class="line">for i in zip(a,b):</span><br><span class="line">    print(i,end=&quot; &quot;)  # (1, &apos;w&apos;) (2, &apos;x&apos;) (3, &apos;y&apos;)</span><br><span class="line"></span><br><span class="line"># 空缺值以 None 填补</span><br><span class="line">for i in itertools.zip_longest(a,b):</span><br><span class="line">    print(i,end=&quot; &quot;)  # (1, &apos;w&apos;) (2, &apos;x&apos;) (3, &apos;y&apos;) (None, &apos;z&apos;)</span><br></pre></td></tr></table></figure>
<h3 id="4-2-enumerate-方法"><a href="#4-2-enumerate-方法" class="headerlink" title="4.2 enumerate() 方法"></a>4.2 enumerate() 方法</h3><p>enumerate() 方法接收一个序列类型参数，生成一个可返回元组的迭代器，元组内容是下标及其对应的元素值。它还可接收一个可选参数，指定下标的起始值，默认是0 。</p>
<p>注意：众所周知，Python 中序列的索引值从 0 开始，但是，enumerate() 可以达到改变起始索引数值的效果。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">seasons = [&apos;Spring&apos;, &apos;Summer&apos;, &apos;Fall&apos;, &apos;Winter&apos;]</span><br><span class="line"></span><br><span class="line">for i in enumerate(seasons):</span><br><span class="line">    print(i,end=&quot; &quot;)  </span><br><span class="line">#输出结果：(0, &apos;Spring&apos;) (1, &apos;Summer&apos;) (2, &apos;Fall&apos;) (3, &apos;Winter&apos;)</span><br><span class="line"></span><br><span class="line">for i in enumerate(seasons, start=7):</span><br><span class="line">    print(i,end=&quot; &quot;)  </span><br><span class="line">#输出结果：(7, &apos;Spring&apos;) (8, &apos;Summer&apos;) (9, &apos;Fall&apos;) (10, &apos;Winter&apos;)</span><br></pre></td></tr></table></figure>
<h3 id="4-3-map-方法"><a href="#4-3-map-方法" class="headerlink" title="4.3 map() 方法"></a>4.3 map() 方法</h3><p>map() 方法的参数是一个函数及一个或多个可迭代对象，它会将可迭代对象的元素映射到该函数中，然后迭代地运行该函数，返回结果也是一个迭代器。当存在多个可迭代对象参数时，迭代长度等于较短对象的长度。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">def square(x):</span><br><span class="line">    return x ** 2</span><br><span class="line"></span><br><span class="line">l = map(square, [1, 2, 3, 4, 5])</span><br><span class="line">print(list(l))</span><br><span class="line"># 输出结果：[1, 4, 9, 16, 25]</span><br><span class="line"></span><br><span class="line">m = map(lambda x, y: x + y, [1, 3, 5, 7, 9], [2, 4, 6, 8, 10, 2])</span><br><span class="line">print(list(m))</span><br><span class="line"># 输出结果：[3, 7, 11, 15, 19]</span><br></pre></td></tr></table></figure>
<h3 id="4-4-filter-方法"><a href="#4-4-filter-方法" class="headerlink" title="4.4 filter() 方法"></a>4.4 filter() 方法</h3><p>filter() 方法的参数是一个判断函数及一个可迭代对象，遍历可迭代对象执行判断函数，过滤下判断为True 的元素，与它相对，若想保留判断为 False 的元素，可使用 itertoole 模块的 filterfalse() 方法。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">import itertools</span><br><span class="line"></span><br><span class="line">fi = filter(lambda x: x%2, range(10))</span><br><span class="line">ff = itertools.filterfalse(lambda x: x%2, range(10))</span><br><span class="line"></span><br><span class="line">for i in fi:</span><br><span class="line">    print(i,end=&quot; &quot;)</span><br><span class="line"># 输出结果：1 3 5 7 9</span><br><span class="line"></span><br><span class="line">for i in ff:</span><br><span class="line">    print(i,end=&quot; &quot;)</span><br><span class="line"># 输出结果：0 2 4 6 8</span><br></pre></td></tr></table></figure>
<h2 id="5-小结"><a href="#5-小结" class="headerlink" title="5. 小结"></a>5. 小结</h2><p>迭代器模式几乎是 23 种设计模式中最常用的设计模式，本文主要介绍了 Python 是如何运用迭代器模式，并介绍了 itertools 模块生成迭代器的 18 种方法，以及 5 种生成迭代器的内置方法。 </p>
<p>相关链接：</p>
<p>itertools模块文档：<a href="http://t.cn/R6cGtfw" target="_blank" rel="noopener">http://t.cn/R6cGtfw</a></p>
<p><a href="https://mp.weixin.qq.com/s/DIhwoJE3o0kKw3kzZKysag" target="_blank" rel="noopener">Python进阶：迭代器与迭代器切片</a></p>
<p><a href="https://mp.weixin.qq.com/s/IRAjR-KHZBPEEkdiofseGQ" target="_blank" rel="noopener">Python进阶：全面解读高级特性之切片！</a></p>
<p>-—————-</p>
<p>本文原创并首发于微信公众号【Python猫】，后台回复“爱学习”，免费获得20+本精选电子书。</p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://chinesehuazhou.github.io/2019/05/03/Python进阶/Python进阶：自定义对象实现切片功能/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="John Doe">
      <meta itemprop="description" content>
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="豌豆花下猫">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2019/05/03/Python进阶/Python进阶：自定义对象实现切片功能/" itemprop="url">未命名</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2019-05-03T21:21:22+08:00">
                2019-05-03
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="Python进阶：自定义对象实现切片功能"><a href="#Python进阶：自定义对象实现切片功能" class="headerlink" title="Python进阶：自定义对象实现切片功能"></a>Python进阶：自定义对象实现切片功能</h1><p>切片是 Python 中最迷人最强大最 Amazing 的语言特性（几乎没有之一），在《<a href="https://mp.weixin.qq.com/s/fwZnvcQ_u-fYLFeQaYkJLw" target="_blank" rel="noopener">Python进阶：切片的误区与高级用法</a>》中，我介绍了切片的基础用法、高级用法以及一些使用误区。这些内容都是基于原生的序列类型（如字符串、列表、元组……），那么，我们是否可以定义自己的序列类型并让它支持切片语法呢？更进一步，我们是否可以自定义其它对象（如字典）并让它支持切片呢？</p>
<h2 id="1、魔术方法：-getitem"><a href="#1、魔术方法：-getitem" class="headerlink" title="1、魔术方法：__getitem__()"></a>1、魔术方法：<code>__getitem__()</code></h2><p>想要使自定义对象支持切片语法并不难，只需要在定义类的时候给它实现魔术方法 <code>__getitem__()</code> 即可。所以，这里就先介绍一下这个方法。</p>
<p>语法： <code>object.__getitem__(self, key)</code></p>
<p>官方文档释义：Called to implement evaluation of self[key]. For sequence types, the accepted keys should be integers and slice objects. Note that the special interpretation of negative indexes (if the class wishes to emulate a sequence type) is up to the <code>__getitem__()</code> method. If key is of an inappropriate type, TypeError may be raised; if of a value outside the set of indexes for the sequence (after any special interpretation of negative values), IndexError should be raised. For mapping types, if key is missing (not in the container), KeyError should be raised.</p>
<p>概括翻译一下：<code>__getitem__()</code> 方法用于返回参数 key 所对应的值，这个 key 可以是整型数值和切片对象，并且支持负数索引；如果 key 不是以上两种类型，就会抛 TypeError；如果索引越界，会抛 IndexError ；如果定义的是映射类型，当 key 参数不是其对象的键值时，则会抛 KeyError 。</p>
<h2 id="2、自定义序列实现切片功能"><a href="#2、自定义序列实现切片功能" class="headerlink" title="2、自定义序列实现切片功能"></a>2、自定义序列实现切片功能</h2><p>接下来，我们定义一个简单的 MyList ，并给它加上切片功能。（PS：仅作演示，不保证其它功能的完备性）。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyList</span><span class="params">()</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self)</span>:</span></span><br><span class="line">        self.data = []</span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">append</span><span class="params">(self, item)</span>:</span></span><br><span class="line">        self.data.append(item)</span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__iter__</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="keyword">return</span> self</span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__getitem__</span><span class="params">(self, key)</span>:</span></span><br><span class="line">        print(<span class="string">"key is : "</span> + str(key))</span><br><span class="line">        <span class="keyword">return</span> self.data[key]</span><br><span class="line"></span><br><span class="line">l = MyList()</span><br><span class="line">l.append(<span class="string">"My"</span>)</span><br><span class="line">l.append(<span class="string">"name"</span>)</span><br><span class="line">l.append(<span class="string">"is"</span>)</span><br><span class="line">l.append(<span class="string">"Python猫"</span>)</span><br><span class="line"></span><br><span class="line">print(l[<span class="number">3</span>])</span><br><span class="line">print(l[:<span class="number">2</span>])</span><br><span class="line">print(l[<span class="string">'hi'</span>])</span><br><span class="line"></span><br><span class="line"><span class="comment">### 输出结果：</span></span><br><span class="line">key <span class="keyword">is</span> : <span class="number">3</span></span><br><span class="line">Python猫</span><br><span class="line">key <span class="keyword">is</span> : slice(<span class="literal">None</span>, <span class="number">2</span>, <span class="literal">None</span>)</span><br><span class="line">[<span class="string">'My'</span>, <span class="string">'name'</span>]</span><br><span class="line">key <span class="keyword">is</span> : hi</span><br><span class="line">Traceback (most recent call last):</span><br><span class="line">...</span><br><span class="line">TypeError: list indices must be integers <span class="keyword">or</span> slices, <span class="keyword">not</span> str</span><br><span class="line">    </span><br><span class="line"><span class="comment">#####</span></span><br><span class="line"><span class="number">2018</span><span class="number">-12</span><span class="number">-31</span> 更新声明：本例未考虑到返回类型，严格来说并未实现切片。</span><br><span class="line">在合并的文章里已做修正：https://mp.weixin.qq.com/s/IRAjR-KHZBPEEkdiofseGQ</span><br></pre></td></tr></table></figure>
<p>从输出结果来看，自定义的 MyList 既支持按索引查找，也支持切片操作，这正是我们的目的。</p>
<p>特别需要说明的是，此例中的 <code>__getitem__()</code> 方法会根据不同的参数类型而实现不同的功能（取索引位值或切片值），也会妥当地处理异常，所以并不需要我们再去写繁琐的处理逻辑。网上有不少学习资料完全是在误人子弟，它们会教你区分参数的不同类型，然后写一大段代码来实现索引查找和切片语法，简直是画蛇添足。下面的就是一个代表性的错误示例：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">###略去其它代码####</span><br><span class="line">def __getitem__(self, index):</span><br><span class="line">    cls = type(self)</span><br><span class="line">    if isinstance(index, slice):  # 如果index是个切片类型，则构造新实例</span><br><span class="line">       return cls(self._components[index])</span><br><span class="line">    elif isinstance(index, numbers.Integral):  # 如果index是个数，则直接返回</span><br><span class="line">        return self._components[index]</span><br><span class="line">    else:</span><br><span class="line">        msg = &quot;&#123;cls.__name__&#125; indices must be integers&quot;</span><br><span class="line">        raise TypeError(msg.format(cls=cls))</span><br></pre></td></tr></table></figure>
<h2 id="3、自定义字典实现切片功能"><a href="#3、自定义字典实现切片功能" class="headerlink" title="3、自定义字典实现切片功能"></a>3、自定义字典实现切片功能</h2><p>切片是序列类型的特性，所以在上例中，我们不需要写切片的具体实现逻辑。但是，对于其它非序列类型的自定义对象，就得自己实现切片逻辑。以自定义字典为例（PS：仅作演示，不保证其它功能的完备性）：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyDict</span><span class="params">()</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self)</span>:</span></span><br><span class="line">        self.data = &#123;&#125;</span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__len__</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="keyword">return</span> len(self.data)</span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">append</span><span class="params">(self, item)</span>:</span></span><br><span class="line">        self.data[len(self)] = item</span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__getitem__</span><span class="params">(self, key)</span>:</span></span><br><span class="line">        <span class="keyword">if</span> isinstance(key, int):</span><br><span class="line">            <span class="keyword">return</span> self.data[key]</span><br><span class="line">        <span class="keyword">if</span> isinstance(key, slice):</span><br><span class="line">            slicedkeys = list(self.data.keys())[key]</span><br><span class="line">            <span class="keyword">return</span> &#123;k: self.data[k] <span class="keyword">for</span> k <span class="keyword">in</span> slicedkeys&#125;</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="keyword">raise</span> TypeError</span><br><span class="line"></span><br><span class="line">d = MyDict()</span><br><span class="line">d.append(<span class="string">"My"</span>)</span><br><span class="line">d.append(<span class="string">"name"</span>)</span><br><span class="line">d.append(<span class="string">"is"</span>)</span><br><span class="line">d.append(<span class="string">"Python猫"</span>)</span><br><span class="line">print(d[<span class="number">2</span>])</span><br><span class="line">print(d[:<span class="number">2</span>])</span><br><span class="line">print(d[<span class="number">-4</span>:<span class="number">-2</span>])</span><br><span class="line">print(d[<span class="string">'hi'</span>])</span><br><span class="line"></span><br><span class="line"><span class="comment">### 输出结果：</span></span><br><span class="line"><span class="keyword">is</span></span><br><span class="line">&#123;<span class="number">0</span>: <span class="string">'My'</span>, <span class="number">1</span>: <span class="string">'name'</span>&#125;</span><br><span class="line">&#123;<span class="number">0</span>: <span class="string">'My'</span>, <span class="number">1</span>: <span class="string">'name'</span>&#125;</span><br><span class="line">Traceback (most recent call last):</span><br><span class="line">...</span><br><span class="line">TypeError</span><br></pre></td></tr></table></figure>
<p>上例的关键点在于将字典的键值取出，并对键值的列表做切片处理，其妙处在于，不用担心索引越界和负数索引，将字典切片转换成了字典键值的切片，最终实现目的。</p>
<h2 id="4、小结"><a href="#4、小结" class="headerlink" title="4、小结"></a>4、小结</h2><p>最后小结一下：本文介绍了<code>__getitem__()</code> 魔术方法，并用于实现自定义对象（以列表类型和字典类型为例）的切片功能，希望对你有所帮助。</p>
<p><strong>参考阅读：</strong> </p>
<p><a href="https://mp.weixin.qq.com/s/fwZnvcQ_u-fYLFeQaYkJLw" target="_blank" rel="noopener">Python进阶：切片的误区与高级用法</a></p>
<p>官方文档getitem用法：<a href="http://t.cn/EbzoZyp" target="_blank" rel="noopener">http://t.cn/EbzoZyp</a></p>
<p>Python切片赋值源码分析：<a href="http://t.cn/EbzSaoZ" target="_blank" rel="noopener">http://t.cn/EbzSaoZ</a></p>
<p>PS：本公众号（Python猫）已开通读者交流群，详情请通过菜单栏中的“交流群”来了解。</p>
<p>-—————-</p>
<p>本文原创并首发于微信公众号【Python猫】，后台回复“爱学习”，免费获得20+本精选电子书。</p>
<p>2018-12-31 更新声明：切片系列文章本是分三篇写成，现已合并成一篇。合并后，修正了一些严重的错误（如自定义序列切片的部分），还对行文结构与章节衔接做了大量改动。原系列的单篇就不删除了，毕竟也是有单独成篇的作用。特此声明，请阅读改进版—— Python进阶：全面解读高级特性之切片！<a href="https://mp.weixin.qq.com/s/IRAjR-KHZBPEEkdiofseGQ" target="_blank" rel="noopener">https://mp.weixin.qq.com/s/IRAjR-KHZBPEEkdiofseGQ</a></p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://chinesehuazhou.github.io/2019/05/03/Python进阶/Python进阶：如何将字符串常量转化为变量？/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="John Doe">
      <meta itemprop="description" content>
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="豌豆花下猫">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2019/05/03/Python进阶/Python进阶：如何将字符串常量转化为变量？/" itemprop="url">未命名</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2019-05-03T21:21:22+08:00">
                2019-05-03
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="Python进阶：如何将字符串常量转化为变量？"><a href="#Python进阶：如何将字符串常量转化为变量？" class="headerlink" title="Python进阶：如何将字符串常量转化为变量？"></a>Python进阶：如何将字符串常量转化为变量？</h1><p>前几天，我们<code>Python猫交流学习群</code> 里的 M 同学提了个问题。这个问题挺有意思，经初次讨论，我们认为它无解。</p>
<p>然而，我认为它很有价值，应该继续思考怎么解决，所以就在私密的知识星球上记录了下来。</p>
<p>万万没想到的是，在第二天，有两位同学接连给出了解决方法！</p>
<p>由此，群内出现了一轮热烈的技术交流。</p>
<p>本文将相关的内容要点作了梳理，并由此引申到更进一步的学习话题，希望对你有所帮助。</p>
<h2 id="1、如何动态生成变量名？"><a href="#1、如何动态生成变量名？" class="headerlink" title="1、如何动态生成变量名？"></a>1、如何动态生成变量名？</h2><p>M 同学的问题如下：</p>
<blockquote>
<p>打扰一下大家，请教一个问题，已知 list = [‘A’, ‘B’, ‘C’, ‘D’] , 如何才能得到以 list 中元素命名的新列表 A = [], B = [], C = [], D = [] 呢?</p>
</blockquote>
<p>简单理解，这个问题的意思是，<strong>将字符串内容作为其它对象的变量名。</strong> </p>
<p>list 中的元素是字符串，此处的 ‘A’-‘D’ 是<strong>常量</strong> ，而在要求的结果中，A-D 是<strong>变量</strong> 。</p>
<p>如果强行直接将常量当做变量使用，它会报错：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; &apos;A&apos; = []</span><br><span class="line">...SyntaxError: can&apos;t assign to literal</span><br></pre></td></tr></table></figure>
<p>报错中的<code>literal</code> 指的是<code>字面量</code> ，这是计算机科学中常见的一个概念，<strong>用于表达源代码中的固定值。</strong> 例如，整数、浮点数、字符串等基本类型，就是字面量。</p>
<p>字面量指的就是一个量本身，可以理解为一种原子性的实体，当然不能再被赋值了。</p>
<p>所以，取出的字符串内容，并不能直接用作变量名，需要另想办法。</p>
<p>有初学者可能会想，list[0] = [] 行不行？当然不行，因为没有出现 A 。那 A = list[0] ，接着 A = [] 呢？那也不行，因为这里的 A 是你凭空定义出来的，而不是从已有条件中生成的。</p>
<p>当时，群里只有两三个同学参与了讨论，我们没想到解决办法。但是，我觉得这个题目很有意思，值得玩味。</p>
<p>因为，如果能解决这个问题，那就意味着可以不作预先定义，而是动态地生成变量名，这不仅能减少给变量取名的麻烦，还实现了自动编码！</p>
<p>可以设想一下未来，人工智能在编写代码的时候，如果能根据已知条件，动态生成变量名，那编写代码的过程不就顺利多了么？（据说，现在已经有人工智能可以编写代码了，不知它在取变量名时，是用的什么方法？）</p>
<h2 id="2、办法总是有的"><a href="#2、办法总是有的" class="headerlink" title="2、办法总是有的"></a>2、办法总是有的</h2><p>最近，学习群里蒙混进来了几个打广告的，为此，我决定提高审核门槛，例如，用群里的问题来作个考核。</p>
<p>万万没想到的是，第一个被考核到的 Q 同学，几乎不假思索地就说出了一个解决上述问题的思路。而<strong>偏偏就是那么巧</strong> ，几乎在同时，群内的 J 同学给出了另外一个解决方法（他没看到群内的讨论，而是看到了知识星球的记录，才知道这个问题的）。</p>
<p>也就是说，前一晚还以为无解的问题，在第二天竟得到了两种不同的解决方法！</p>
<p>那么，他们的答案是什么呢？</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"># J 同学的解答</span><br><span class="line">&gt;&gt;&gt; list1 = [&apos;A&apos;, &apos;B&apos;, &apos;C&apos;, &apos;D&apos;]</span><br><span class="line">&gt;&gt;&gt; for i in list1:</span><br><span class="line">&gt;&gt;&gt;     globals()[i] = []</span><br><span class="line">&gt;&gt;&gt; A</span><br><span class="line">[]</span><br></pre></td></tr></table></figure>
<p>这个方法通过修改全局命名空间，巧妙地“定义”出了新的变量。globals() 方法取出来的是一个字典，字符串 ‘A’ 是其中一个键值（key），而这个键值恰恰是全局命名空间中的一个变量，这就实现了从常量到变量的转化。</p>
<p>在数据结构层面上，空列表 [] 作为一个值（value）跟它的字符串键值绑定在一起，而在运用层面上，它作为变量内容而跟变量名绑定在一起。</p>
<p>看到这个回答的时候，我就突然想起来了，上个月转载过一篇《<a href="https://mp.weixin.qq.com/s/f9BBe2W1X1p7NcHg665I4A" target="_blank" rel="noopener">Python 动态赋值的陷阱</a>》，讲的正是<strong>动态地进行变量赋值</strong> 的问题啊！我似乎只关注了 globals() 与 locals() 用法的区别，却没有真正地掌握它们的原初用途。</p>
<p>J 同学说，他正是看了那篇文章，才学得了这个方法。这就有意思了，我分享了一个自己囫囵吞枣的知识，然后它被 J 同学吸收掌握，最后反馈回来解决了我的难题。</p>
<p>我真切地感受到了知识分享的魅力：<strong>知识在流动中获得生命，在碰撞中锃亮色泽。</strong> </p>
<p>同时，我也真切地明白了一个互助的学习团体的好处：<strong>利人者也利己，互助者共同进步。</strong> </p>
<h2 id="3、动态执行代码的方法"><a href="#3、动态执行代码的方法" class="headerlink" title="3、动态执行代码的方法"></a>3、动态执行代码的方法</h2><p>新进群的 Q 同学，提供了一个不同的答案：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"># Q 同学的解答</span><br><span class="line">&gt;&gt;&gt; list1 = [&apos;A&apos;, &apos;B&apos;, &apos;C&apos;, &apos;D&apos;]</span><br><span class="line">&gt;&gt;&gt; for i in list1:</span><br><span class="line">&gt;&gt;&gt;     exec(f&quot;&#123;i&#125; = []&quot;)</span><br><span class="line">&gt;&gt;&gt; A</span><br><span class="line">[]</span><br></pre></td></tr></table></figure>
<p>他的写法用到了 Python 3.6 才引入的 f-strings 特性，事实上，在较低版本中，也是可以实现的，只需要保证 exec() 方法接收的参数是包含了变量 i 的字符串即可，例如这样写：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"># 以下代码可替换上例的第 4 行</span><br><span class="line">exec(i + &quot; = []&quot;)</span><br><span class="line"># 或者：</span><br><span class="line">exec(&quot;&#123;&#125; = []&quot;.format(i))</span><br><span class="line"># 或者：</span><br><span class="line">exec(&apos; &apos;.join([i, &apos;= []&apos;]))</span><br></pre></td></tr></table></figure>
<p>这几种写法的区别只是字符串拼接法的区别，关于如何拼接字符串，以及不同方法之间的区别，可参看《<a href="https://mp.weixin.qq.com/s/Whrd6NiD4Y2Z-YSCy4XJ1w" target="_blank" rel="noopener">详解Python拼接字符串的七种方式</a>》。</p>
<p>Q 同学这个答案的核心在于 exec() 方法，它是内置的，用途是<strong>执行储存在字符串或文件中的代码段。</strong> </p>
<p>它的基础用法如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; exec(&apos;x = 1 + 2&apos;)</span><br><span class="line">&gt;&gt;&gt; x</span><br><span class="line">3</span><br><span class="line"></span><br><span class="line"># 执行代码段</span><br><span class="line">&gt;&gt;&gt; s = &quot;&quot;&quot;</span><br><span class="line">&gt;&gt;&gt; x = 10</span><br><span class="line">&gt;&gt;&gt; y = 20</span><br><span class="line">&gt;&gt;&gt; sum = x + y</span><br><span class="line">&gt;&gt;&gt; print(sum)</span><br><span class="line">&gt;&gt;&gt; &quot;&quot;&quot;</span><br><span class="line">&gt;&gt;&gt; exec(s)</span><br><span class="line">30</span><br></pre></td></tr></table></figure>
<p>看完了 exec() 的用法，我们再回来看 Q 同学的答案。for-循环中取出来的 i 是字符串，而拼接后的字符串经过 exec() 的处理，就获得了动态编写代码的效果。</p>
<p>也就是说，因为字符串常量的内容被当做有效代码而执行了，其中的 ‘A’-‘D’ 元素，就取得了新的身份，变成了最终的 A-D 变量名。</p>
<p>这个方法看起来很简单啊，可是由于 exec() 方法太生僻了，直到 Q 同学提出，我们才醒悟过来。</p>
<blockquote>
<p>注意：在 Python3 中，exec() 是个内置方法；而在 Python2 中，exec 是个语句（statement），另外有个 execfile() 方法，两者相合并，就成了 Python3 中的 exec() 方法。本文使用的是 Python3。</p>
</blockquote>
<h2 id="4、总结"><a href="#4、总结" class="headerlink" title="4、总结"></a>4、总结</h2><p>抽象一下最初的问题，它实际问的是“如何将字符串内容作为其它对象的变量名”，更进一步地讲是——“<strong>如何将常量转化为变量</strong> ”。</p>
<p>使用直接进行赋值的静态方法，行不通。</p>
<p>两位同学提出的方法都是间接的动态方法：<strong>一个是动态地进行变量赋值，通过修改命名空间而植入变量；一个是动态地执行代码，可以说是通过“走后门”的方式，安插了变量。</strong> </p>
<p>两种方法殊途同归，不管是白猫还是黑猫，它们都抓到了老鼠。</p>
<p>这两种方法已经给我们带来了很有价值的启发，同时，因为它们，群内小伙伴们更是发散地讨论一些相关联的话题，例如：S 同学提出了另一种修改命名空间中变量的写法、L 同学提到了 eval() 的意义、eval() 与 exec() 的区别、我查到了为什么要慎用 eval() 、C 与 H 同学提到了 eval() 的安全用法……</p>
<p>虽然，某些话题无法在群聊中充分展开，但是，这些话题知识的延展联系，大大地丰富了本文开头的问题，这一个微小的问题，牵连出来了两个大的知识体系。</p>
<p>最后，真得感谢群内的这些爱学习的优秀的同志们！除了文中提及的，还有一些同学也做了积极贡献，大家都很给力！</p>
<p><strong>相关链接：</strong> </p>
<p>《<a href="https://mp.weixin.qq.com/s/f9BBe2W1X1p7NcHg665I4A" target="_blank" rel="noopener">Python 动态赋值的陷阱</a>》</p>
<p>《<a href="https://mp.weixin.qq.com/s/Whrd6NiD4Y2Z-YSCy4XJ1w" target="_blank" rel="noopener">详解Python拼接字符串的七种方式</a>》</p>
<p>eval()、exec()及其相关函数：<a href="https://www.tuicool.com/wx/vEbeumE" target="_blank" rel="noopener">https://www.tuicool.com/wx/vEbeumE</a></p>
<p><img src="http://ww1.sinaimg.cn/large/68b02e3bgy1g08dfkg8sdj2076076t96.jpg" alt></p>
<p>公众号【<strong>Python猫</strong>】， 专注Python技术、数据科学和深度学习，力图创造一个有趣又有用的学习分享平台。本号连载优质的系列文章，有喵星哲学猫系列、Python进阶系列、好书推荐系列、优质英文推荐与翻译等等，欢迎关注哦。PS：后台回复“<strong>爱学习</strong>”，免费获得一份学习大礼包。</p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://chinesehuazhou.github.io/2019/05/03/Python进阶/Python进阶：切片的误区与高级用法/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="John Doe">
      <meta itemprop="description" content>
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="豌豆花下猫">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2019/05/03/Python进阶/Python进阶：切片的误区与高级用法/" itemprop="url">未命名</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2019-05-03T21:21:22+08:00">
                2019-05-03
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="Python进阶：切片的误区与高级用法"><a href="#Python进阶：切片的误区与高级用法" class="headerlink" title="Python进阶：切片的误区与高级用法"></a>Python进阶：切片的误区与高级用法</h1><p>众所周知，我们可以通过索引值（或称下标）来查找序列类型（如字符串、列表、元组…）中的单个元素，那么，如果要获取一个索引区间的元素该怎么办呢？</p>
<p>切片（slice）就是一种截取索引片段的技术，借助切片技术，我们可以十分灵活地处理序列类型的对象。通常来说，切片的作用就是截取序列对象，然而，它还有一些使用误区与高级用法，都值得我们注意。所以，本文将主要跟大家一起来探讨这些内容，希望你能学有所获。</p>
<p>事先声明，切片并非列表的专属操作，但因为列表最具有代表性，所以，本文仅以列表为例作探讨。</p>
<h2 id="1、切片的基础用法"><a href="#1、切片的基础用法" class="headerlink" title="1、切片的基础用法"></a>1、切片的基础用法</h2><p>列表是 Python 中极为基础且重要的一种数据结构，我曾写过一篇汇总文章（链接见文末）较全面地学习过它。文中详细地总结了切片的基础用法，现在回顾一下：</p>
<p>切片的书写形式：[i : i+n : m] ；其中，i 是切片的起始索引值，为列表首位时可省略；i+n 是切片的结束位置，为列表末位时可省略；m 可以不提供，默认值是1，<strong>不允许为0</strong> ，当m为负数时，列表翻转。注意：这些值都可以大于列表长度，不会报越界。</p>
<p>切片的基本含义是：<strong>从序列的第i位索引起，向右取到后n位元素为止，按m间隔过滤</strong> 。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">li = [1, 4, 5, 6, 7, 9, 11, 14, 16]</span><br><span class="line"></span><br><span class="line"># 以下写法都可以表示整个列表，其中 X &gt;= len(li)</span><br><span class="line">li[0:X] == li[0:] == li[:X] == li[:] == li[::] == li[-X:X] == li[-X:]</span><br><span class="line"></span><br><span class="line">li[1:5] == [4,5,6,7] # 从1起，取5-1位元素</span><br><span class="line">li[1:5:2] == [4,6] # 从1起，取5-1位元素，按2间隔过滤</span><br><span class="line">li[-1:] == [16] # 取倒数第一个元素</span><br><span class="line">li[-4:-2] == [9, 11] # 从倒数第四起，取-2-(-4)=2位元素</span><br><span class="line">li[:-2] == li[-len(li):-2] == [1,4,5,6,7,9,11] # 从头开始，取-2-(-len(li))=7位元素</span><br><span class="line"></span><br><span class="line"># 步长为负数时，列表先翻转，再截取</span><br><span class="line">li[::-1] == [16,14,11,9,7,6,5,4,1] # 翻转整个列表</span><br><span class="line">li[::-2] == [16,11,7,5,1] # 翻转整个列表，再按2间隔过滤</span><br><span class="line">li[:-5:-1] == [16,14,11,9] # 翻转整个列表，取-5-(-len(li))=4位元素</span><br><span class="line">li[:-5:-3] == [16,9] # 翻转整个列表，取-5-(-len(li))=4位元素，再按3间隔过滤</span><br><span class="line"></span><br><span class="line"># 切片的步长不可以为0</span><br><span class="line">li[::0]  # 报错（ValueError: slice step cannot be zero）</span><br></pre></td></tr></table></figure>
<p>上述的某些例子对于初学者（甚至很多老手）来说，可能还不好理解。我个人总结出两条经验：（1）牢牢记住公式<code>[i : i+n : m]</code> ，当出现缺省值时，通过想象把公式补全；（2）索引为负且步长为正时，按倒数计算索引位置；索引为负且步长为负时，先翻转列表，再按倒数计算索引位置。</p>
<h2 id="2、切片是伪独立对象"><a href="#2、切片是伪独立对象" class="headerlink" title="2、切片是伪独立对象"></a>2、切片是伪独立对象</h2><p>切片操作的返回结果是一个新的独立的序列（PS：也有例外，参见《<a href="https://mp.weixin.qq.com/s/PsY8Iec1EeGDKKnTNU5CNw" target="_blank" rel="noopener">Python是否支持复制字符串呢？</a>》）。以列表为例，列表切片后得到的还是一个列表，占用新的内存地址。</p>
<p>当取出切片的结果时，它是一个独立对象，因此，可以将其用于赋值操作，也可以用于其它传递值的场景。但是，切片只是浅拷贝，它拷贝的是原列表中元素的引用，所以，当存在变长对象的元素时，新列表将受制于原列表。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">li = [1, 2, 3, 4]</span><br><span class="line">ls = li[::]</span><br><span class="line"></span><br><span class="line">li == ls # True</span><br><span class="line">id(li) == id(ls) # False</span><br><span class="line">li.append(li[2:4]) # [1, 2, 3, 4, [3, 4]]</span><br><span class="line">ls.extend(ls[2:4]) # [1, 2, 3, 4, 3, 4]</span><br><span class="line"></span><br><span class="line"># 下例等价于判断li长度是否大于8</span><br><span class="line">if(li[8:]):</span><br><span class="line">    print(&quot;not empty&quot;)</span><br><span class="line">else:</span><br><span class="line">    print(&quot;empty&quot;)</span><br><span class="line"></span><br><span class="line"># 切片列表受制于原列表</span><br><span class="line">lo = [1,[1,1],2,3]</span><br><span class="line">lp = lo[:2] # [1, [1, 1]]</span><br><span class="line">lo[1].append(1) # [1, [1, 1, 1], 2, 3]</span><br><span class="line">lp # [1, [1, 1, 1]]</span><br></pre></td></tr></table></figure>
<p>由于可见，将切片结果取出，它可以作为独立对象使用，但是也要注意，是否取出了变长对象的元素。</p>
<h2 id="3、切片可作为占位符"><a href="#3、切片可作为占位符" class="headerlink" title="3、切片可作为占位符"></a>3、切片可作为占位符</h2><p>切片既可以作为独立对象被“取出”原序列，也可以留在原序列，作为一种占位符使用。</p>
<p>在写《<a href="https://mp.weixin.qq.com/s/Whrd6NiD4Y2Z-YSCy4XJ1w" target="_blank" rel="noopener">详解Python拼接字符串的七种方式</a>》的时候，我介绍了几种拼接字符串的方法，其中三种格式化类的拼接方法（即 %、format()、template）就是使用了占位符的思想。对于列表来说，使用切片作为占位符，同样能够实现拼接列表的效果。特别需要注意的是，给切片赋值的必须是可迭代对象。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">li = [1, 2, 3, 4]</span><br><span class="line"></span><br><span class="line"># 在头部拼接</span><br><span class="line">li[:0] = [0] # [0, 1, 2, 3, 4]</span><br><span class="line"># 在末尾拼接</span><br><span class="line">li[len(li):] = [5,7] # [0, 1, 2, 3, 4, 5, 7]</span><br><span class="line"># 在中部拼接</span><br><span class="line">li[6:6] = [6] # [0, 1, 2, 3, 4, 5, 6, 7]</span><br><span class="line"></span><br><span class="line"># 给切片赋值的必须是可迭代对象</span><br><span class="line">li[-1:-1] = 6 # （报错，TypeError: can only assign an iterable）</span><br><span class="line">li[:0] = (9,) #  [9, 0, 1, 2, 3, 4, 5, 6, 7]</span><br><span class="line">li[:0] = range(3) #  [0, 1, 2, 9, 0, 1, 2, 3, 4, 5, 6, 7]</span><br></pre></td></tr></table></figure>
<p>上述例子中，若将切片作为独立对象取出，那你会发现它们都是空列表，即 <code>li[:0]==li[len(li):]==li[6:6]==[]</code> ，我将这种占位符称为“<strong>纯占位符</strong>”，对纯占位符赋值，并不会破坏原有的元素，只会在特定的索引位置中拼接进新的元素。删除纯占位符时，也不会影响列表中的元素。</p>
<p>与“纯占位符”相对应，“<strong>非纯占位符</strong>”的切片是非空列表，对它进行操作（赋值与删除），将会影响原始列表。如果说纯占位符可以实现列表的拼接，那么，非纯占位符可以实现列表的替换。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">li = [1, 2, 3, 4]</span><br><span class="line"></span><br><span class="line"># 不同位置的替换</span><br><span class="line">li[:3] = [7,8,9] # [7, 8, 9, 4]</span><br><span class="line">li[3:] = [5,6,7] # [7, 8, 9, 5, 6, 7]</span><br><span class="line">li[2:4] = [&apos;a&apos;,&apos;b&apos;] # [7, 8, &apos;a&apos;, &apos;b&apos;, 6, 7]</span><br><span class="line"></span><br><span class="line"># 非等长替换</span><br><span class="line">li[2:4] = [1,2,3,4] # [7, 8, 1, 2, 3, 4, 6, 7]</span><br><span class="line">li[2:6] = [&apos;a&apos;]  # [7, 8, &apos;a&apos;, 6, 7]</span><br><span class="line"></span><br><span class="line"># 删除元素</span><br><span class="line">del li[2:3] # [7, 8, 6, 7]</span><br></pre></td></tr></table></figure>
<p>切片占位符可以带步长，从而实现连续跨越性的替换或删除效果。需要注意的是，这种用法只支持等长替换。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">li = [1, 2, 3, 4, 5, 6]</span><br><span class="line"></span><br><span class="line">li[::2] = [&apos;a&apos;,&apos;b&apos;,&apos;c&apos;] # [&apos;a&apos;, 2, &apos;b&apos;, 4, &apos;c&apos;, 6]</span><br><span class="line">li[::2] = [0]*3 # [0, 2, 0, 4, 0, 6]</span><br><span class="line">li[::2] = [&apos;w&apos;] # 报错，attempt to assign sequence of size 1 to extended slice of size 3</span><br><span class="line"></span><br><span class="line">del li[::2] # [2, 4, 6]</span><br></pre></td></tr></table></figure>
<h2 id="4、更多思考"><a href="#4、更多思考" class="headerlink" title="4、更多思考"></a>4、更多思考</h2><p>其它编程语言是否有类似于 Python 的切片操作呢？有什么差异？</p>
<p>我在交流群里问了这个问题，小伙伴们纷纷说 Java、Go、Ruby……在查看相关资料的时候，我发现 Go 语言的切片是挺奇怪的设计。首先，它是一种特殊类型，即对数组（array）做切片后，得到的竟然不是一个数组；其次，你可以创建和初始化一个切片，需要声明长度（len）和容量（cap）；再者，它还存在超出底层数组的界限而需要进行扩容的动态机制，这倒是跟 Python 列表的超额分配机制有一定相似性……</p>
<p>在我看来，无论是用意，还是写法和用法，都是 Python 的切片操作更明了与好用。所以，本文就不再进行跨编程语言的比较了（唔，好吧我承认，其实是我不怎么懂其它编程语言……）</p>
<p>最后，还有一个问题：<strong>Python 的切片操作有什么底层原理呢？</strong> 我们是否可以自定义切片操作呢？限于篇幅，我将在下次推文中跟大家一起学习，敬请期待。</p>
<p><strong>延伸阅读</strong> ：</p>
<p><a href="https://mp.weixin.qq.com/s/OKf7N3xxrS0tJ_K8Srw-jA" target="_blank" rel="noopener">超强汇总：学习Python列表，只需这篇文章就够了</a></p>
<p><a href="https://mp.weixin.qq.com/s/Whrd6NiD4Y2Z-YSCy4XJ1w" target="_blank" rel="noopener">详解Python拼接字符串的七种方式</a></p>
<p><a href="https://mp.weixin.qq.com/s/PsY8Iec1EeGDKKnTNU5CNw" target="_blank" rel="noopener">Python是否支持复制字符串呢？</a></p>
<p>PS：本公众号（Python猫）已开通读者交流群，详情请通过菜单栏中的“交流群”了解。</p>
<p>-—————-</p>
<p>本文原创并首发于微信公众号【Python猫】，后台回复“爱学习”，免费获得20+本精选电子书。</p>
<p>2018-12-31 更新声明：切片系列文章本是分三篇写成，现已合并成一篇。合并后，修正了一些严重的错误（如自定义序列切片的部分），还对行文结构与章节衔接做了大量改动。原系列的单篇就不删除了，毕竟也是有单独成篇的作用。特此声明，请阅读改进版—— Python进阶：全面解读高级特性之切片！<a href="https://mp.weixin.qq.com/s/IRAjR-KHZBPEEkdiofseGQ" target="_blank" rel="noopener">https://mp.weixin.qq.com/s/IRAjR-KHZBPEEkdiofseGQ</a></p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://chinesehuazhou.github.io/2019/05/03/Python进阶/Python进阶：全面解读高级特性之切片/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="John Doe">
      <meta itemprop="description" content>
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="豌豆花下猫">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2019/05/03/Python进阶/Python进阶：全面解读高级特性之切片/" itemprop="url">未命名</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2019-05-03T21:21:22+08:00">
                2019-05-03
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="Python进阶：全面解读高级特性之切片！"><a href="#Python进阶：全面解读高级特性之切片！" class="headerlink" title="Python进阶：全面解读高级特性之切片！"></a>Python进阶：全面解读高级特性之切片！</h1><p>导读：切片系列文章连续写了三篇，本文是对它们做的汇总。为什么要把序列文章合并呢？在此说明一下，本文绝不是简单地将它们做了合并，主要是修正了一些严重的错误（如自定义序列切片的部分），还对行文结构与章节衔接做了大量改动，如此一来，本文结构的完整性与内容的质量都得到了很好的保证。</p>
<p>众所周知，我们可以通过索引值（或称下标）来查找序列类型（如字符串、列表、元组…）中的单个元素，那么，如果要获取一个索引区间的元素该怎么办呢？</p>
<p>切片（slice）就是一种截取索引片段的技术，借助切片技术，我们可以十分灵活地处理序列类型的对象。通常来说，切片的作用就是截取序列对象，然而，对于非序列对象，我们是否有办法做到切片操作呢？在使用切片的过程中，有什么要点值得重视，又有什么底层原理值得关注呢？本文将主要跟大家一起来探讨这些内容，希望我能与你共同学习进步。</p>
<h2 id="1、切片的基础用法"><a href="#1、切片的基础用法" class="headerlink" title="1、切片的基础用法"></a>1、切片的基础用法</h2><p>列表是 Python 中极为基础且重要的一种数据结构，也是最能发挥切片的用处的一种数据结构，所以在前两节，我将以列表为例介绍切片的一些常见用法。</p>
<p>首先是切片的书写形式：[i : i+n : m] ；其中，i 是切片的起始索引值，为列表首位时可省略；i+n 是切片的结束位置，为列表末位时可省略；m 可以不提供，默认值是1，<strong>不允许为0</strong> ，当m为负数时，列表翻转。注意：这些值都可以大于列表长度，不会报越界。</p>
<p>切片的基本含义是：<strong>从序列的第i位索引起，向右取到后n位元素为止，按m间隔过滤</strong> 。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">li = [1, 4, 5, 6, 7, 9, 11, 14, 16]</span><br><span class="line"></span><br><span class="line"># 以下写法都可以表示整个列表，其中 X &gt;= len(li)</span><br><span class="line">li[0:X] == li[0:] == li[:X] == li[:] </span><br><span class="line">== li[::] == li[-X:X] == li[-X:]</span><br><span class="line"></span><br><span class="line">li[1:5] == [4,5,6,7] # 从1起，取5-1位元素</span><br><span class="line">li[1:5:2] == [4,6] # 从1起，取5-1位元素，按2间隔过滤</span><br><span class="line">li[-1:] == [16] # 取倒数第一个元素</span><br><span class="line">li[-4:-2] == [9, 11] # 从倒数第四起，取-2-(-4)=2位元素</span><br><span class="line">li[:-2] == li[-len(li):-2] </span><br><span class="line">== [1,4,5,6,7,9,11] # 从头开始，取-2-(-len(li))=7位元素</span><br><span class="line"></span><br><span class="line"># 步长为负数时，列表先翻转，再截取</span><br><span class="line">li[::-1] == [16,14,11,9,7,6,5,4,1] # 翻转整个列表</span><br><span class="line">li[::-2] == [16,11,7,5,1] # 翻转整个列表，再按2间隔过滤</span><br><span class="line">li[:-5:-1] == [16,14,11,9] # 翻转整个列表，取-5-(-len(li))=4位元素</span><br><span class="line">li[:-5:-3] == [16,9] # 翻转整个列表，取-5-(-len(li))=4位元素，再按3间隔过滤</span><br><span class="line"></span><br><span class="line"># 切片的步长不可以为0</span><br><span class="line">li[::0]  # 报错（ValueError: slice step cannot be zero）</span><br></pre></td></tr></table></figure>
<p>上述的某些例子对于初学者（甚至很多老手）来说，可能还不好理解，但是它们都离不开切片的基本语法，所以为方便起见，我将它们也归入基础用法中。</p>
<p>对于这些样例，我个人总结出两条经验：</p>
<p>（1）牢牢记住公式<code>[i : i+n : m]</code> ，当出现缺省值时，通过想象把公式补全；</p>
<p>（2）索引为负且步长为正时，按倒数计算索引位置；索引为负且步长为负时，先翻转列表，再按倒数计算索引位置。</p>
<h2 id="2、切片的高级用法"><a href="#2、切片的高级用法" class="headerlink" title="2、切片的高级用法"></a>2、切片的高级用法</h2><p>一般而言，切片操作的返回结果是一个新的独立的序列（PS：也有例外，参见《<a href="https://mp.weixin.qq.com/s/PsY8Iec1EeGDKKnTNU5CNw" target="_blank" rel="noopener">Python是否支持复制字符串呢？</a>》）。以列表为例，列表切片后得到的还是一个列表，占用新的内存地址。</p>
<p>当取出切片的结果时，它是一个独立对象，因此，可以将其用于赋值操作，也可以用于其它传递值的场景。但是，<strong>切片只是浅拷贝</strong> ，它拷贝的是原列表中元素的引用，所以，当存在变长对象的元素时，新列表将受制于原列表。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">li = [1, 2, 3, 4]</span><br><span class="line">ls = li[::]</span><br><span class="line"></span><br><span class="line">li == ls # True</span><br><span class="line">id(li) == id(ls) # False</span><br><span class="line">li.append(li[2:4]) # [1, 2, 3, 4, [3, 4]]</span><br><span class="line">ls.extend(ls[2:4]) # [1, 2, 3, 4, 3, 4]</span><br><span class="line"></span><br><span class="line"># 下例等价于判断li长度是否大于8</span><br><span class="line">if(li[8:]):</span><br><span class="line">    print(&quot;not empty&quot;)</span><br><span class="line">else:</span><br><span class="line">    print(&quot;empty&quot;)</span><br><span class="line"></span><br><span class="line"># 切片列表受制于原列表</span><br><span class="line">lo = [1,[1,1],2,3]</span><br><span class="line">lp = lo[:2] # [1, [1, 1]]</span><br><span class="line">lo[1].append(1) # [1, [1, 1, 1], 2, 3]</span><br><span class="line">lp # [1, [1, 1, 1]]</span><br></pre></td></tr></table></figure>
<p>由于可见，将切片结果取出，它可以作为独立对象使用，但是也要注意，是否取出了变长对象的元素。</p>
<p>切片既可以作为独立对象被“取出”原序列，也可以留在原序列，作为一种占位符使用。</p>
<p>不久前，我介绍了几种拼接字符串的方法（链接见文末），其中三种格式化类的拼接方法（即 %、format()、template）就是使用了占位符的思想。对于列表来说，使用切片作为占位符，同样能够实现拼接列表的效果。特别需要注意的是，给切片赋值的必须是可迭代对象。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">li = [1, 2, 3, 4]</span><br><span class="line"></span><br><span class="line"># 在头部拼接</span><br><span class="line">li[:0] = [0] # [0, 1, 2, 3, 4]</span><br><span class="line"># 在末尾拼接</span><br><span class="line">li[len(li):] = [5,7] # [0, 1, 2, 3, 4, 5, 7]</span><br><span class="line"># 在中部拼接</span><br><span class="line">li[6:6] = [6] # [0, 1, 2, 3, 4, 5, 6, 7]</span><br><span class="line"></span><br><span class="line"># 给切片赋值的必须是可迭代对象</span><br><span class="line">li[-1:-1] = 6 # （报错，TypeError: can only assign an iterable）</span><br><span class="line">li[:0] = (9,) #  [9, 0, 1, 2, 3, 4, 5, 6, 7]</span><br><span class="line">li[:0] = range(3) #  [0, 1, 2, 9, 0, 1, 2, 3, 4, 5, 6, 7]</span><br></pre></td></tr></table></figure>
<p>上述例子中，若将切片作为独立对象取出，那你会发现它们都是空列表，即 <code>li[:0]==li[len(li):]==li[6:6]==[]</code> ，我将这种占位符称为“<strong>纯占位符</strong>”，对纯占位符赋值，并不会破坏原有的元素，只会在特定的索引位置中拼接进新的元素。删除纯占位符时，也不会影响列表中的元素。</p>
<p>与“纯占位符”相对应，“<strong>非纯占位符</strong>”的切片是非空列表，对它进行操作（赋值与删除），将会影响原始列表。如果说纯占位符可以实现列表的拼接，那么，非纯占位符可以实现列表的替换。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">li = [1, 2, 3, 4]</span><br><span class="line"></span><br><span class="line"># 不同位置的替换</span><br><span class="line">li[:3] = [7,8,9] # [7, 8, 9, 4]</span><br><span class="line">li[3:] = [5,6,7] # [7, 8, 9, 5, 6, 7]</span><br><span class="line">li[2:4] = [&apos;a&apos;,&apos;b&apos;] # [7, 8, &apos;a&apos;, &apos;b&apos;, 6, 7]</span><br><span class="line"></span><br><span class="line"># 非等长替换</span><br><span class="line">li[2:4] = [1,2,3,4] # [7, 8, 1, 2, 3, 4, 6, 7]</span><br><span class="line">li[2:6] = [&apos;a&apos;]  # [7, 8, &apos;a&apos;, 6, 7]</span><br><span class="line"></span><br><span class="line"># 删除元素</span><br><span class="line">del li[2:3] # [7, 8, 6, 7]</span><br></pre></td></tr></table></figure>
<p>切片占位符可以带步长，从而实现连续跨越性的替换或删除效果。需要注意的是，这种用法只支持等长替换。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">li = [1, 2, 3, 4, 5, 6]</span><br><span class="line"></span><br><span class="line">li[::2] = [&apos;a&apos;,&apos;b&apos;,&apos;c&apos;] # [&apos;a&apos;, 2, &apos;b&apos;, 4, &apos;c&apos;, 6]</span><br><span class="line">li[::2] = [0]*3 # [0, 2, 0, 4, 0, 6]</span><br><span class="line">li[::2] = [&apos;w&apos;] # 报错，attempt to assign sequence of size 1 to extended slice of size 3</span><br><span class="line"></span><br><span class="line">del li[::2] # [2, 4, 6]</span><br></pre></td></tr></table></figure>
<h2 id="3、自定义对象实现切片功能"><a href="#3、自定义对象实现切片功能" class="headerlink" title="3、自定义对象实现切片功能"></a>3、自定义对象实现切片功能</h2><p>切片是 Python 中最迷人最强大最 Amazing 的语言特性（几乎没有之一），以上两小节虽然介绍了切片的基础用法与高级用法，但这些还不足以充分地展露切片的魅力，所以，在接下来的两章节中，我们将聚焦于它的更高级用法。</p>
<p>前两节内容都是基于原生的序列类型（如字符串、列表、元组……），那么，我们是否可以定义自己的序列类型并让它支持切片语法呢？更进一步，我们是否可以自定义其它对象（如字典）并让它支持切片呢？</p>
<h3 id="3-1、魔术方法：-getitem"><a href="#3-1、魔术方法：-getitem" class="headerlink" title="3.1、魔术方法：__getitem__()"></a>3.1、魔术方法：<code>__getitem__()</code></h3><p>想要使自定义对象支持切片语法并不难，只需要在定义类的时候给它实现魔术方法 <code>__getitem__()</code> 即可。所以，这里就先介绍一下这个方法。</p>
<p>语法： <code>object.__getitem__(self, key)</code></p>
<p>官方文档释义：Called to implement evaluation of self[key]. For sequence types, the accepted keys should be integers and slice objects. Note that the special interpretation of negative indexes (if the class wishes to emulate a sequence type) is up to the <code>__getitem__()</code> method. If key is of an inappropriate type, TypeError may be raised; if of a value outside the set of indexes for the sequence (after any special interpretation of negative values), IndexError should be raised. For mapping types, if key is missing (not in the container), KeyError should be raised.</p>
<p>概括翻译一下：<code>__getitem__()</code> 方法用于返回参数 key 所对应的值，这个 key 可以是整型数值和切片对象，并且支持负数索引；如果 key 不是以上两种类型，就会抛 TypeError；如果索引越界，会抛 IndexError ；如果定义的是映射类型，当 key 参数不是其对象的键值时，则会抛 KeyError 。</p>
<h3 id="3-2、自定义序列实现切片功能"><a href="#3-2、自定义序列实现切片功能" class="headerlink" title="3.2、自定义序列实现切片功能"></a>3.2、自定义序列实现切片功能</h3><p>接下来，我们定义一个简单的 MyList ，并给它加上切片功能。（PS：仅作演示，不保证其它功能的完备性）。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> numbers</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyList</span><span class="params">()</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, anylist)</span>:</span></span><br><span class="line">        self.data = anylist</span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__len__</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="keyword">return</span> len(self.data)</span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__getitem__</span><span class="params">(self, index)</span>:</span></span><br><span class="line">        print(<span class="string">"key is : "</span> + str(index))</span><br><span class="line">        cls = type(self)</span><br><span class="line">        <span class="keyword">if</span> isinstance(index, slice):</span><br><span class="line">            print(<span class="string">"data is : "</span> + str(self.data[index]))</span><br><span class="line">            <span class="keyword">return</span> cls(self.data[index])</span><br><span class="line">        <span class="keyword">elif</span> isinstance(index, numbers.Integral):</span><br><span class="line">            <span class="keyword">return</span> self.data[index]</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            msg = <span class="string">"&#123;cls.__name__&#125; indices must be integers"</span></span><br><span class="line">            <span class="keyword">raise</span> TypeError(msg.format(cls=cls))</span><br><span class="line"></span><br><span class="line">l = MyList([<span class="string">"My"</span>, <span class="string">"name"</span>, <span class="string">"is"</span>, <span class="string">"Python猫"</span>])</span><br><span class="line"></span><br><span class="line"><span class="comment">### 输出结果：</span></span><br><span class="line">key <span class="keyword">is</span> : <span class="number">3</span></span><br><span class="line">Python猫</span><br><span class="line">key <span class="keyword">is</span> : slice(<span class="literal">None</span>, <span class="number">2</span>, <span class="literal">None</span>)</span><br><span class="line">data <span class="keyword">is</span> : [<span class="string">'My'</span>, <span class="string">'name'</span>]</span><br><span class="line">&lt;__main__.MyList object at <span class="number">0x0000019CD83A7A90</span>&gt;</span><br><span class="line">key <span class="keyword">is</span> : hi</span><br><span class="line">Traceback (most recent call last):</span><br><span class="line">...</span><br><span class="line">TypeError: MyList indices must be integers <span class="keyword">or</span> slices</span><br></pre></td></tr></table></figure>
<p>从输出结果来看，自定义的 MyList 既支持按索引查找，也支持切片操作，这正是我们的目的。</p>
<h3 id="3-3、自定义字典实现切片功能"><a href="#3-3、自定义字典实现切片功能" class="headerlink" title="3.3、自定义字典实现切片功能"></a>3.3、自定义字典实现切片功能</h3><p>切片是序列类型的特性，所以在上例中，我们不需要写切片的具体实现逻辑。但是，对于其它非序列类型的自定义对象，就得自己实现切片逻辑。以自定义字典为例（PS：仅作演示，不保证其它功能的完备性）：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyDict</span><span class="params">()</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self)</span>:</span></span><br><span class="line">        self.data = &#123;&#125;</span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__len__</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="keyword">return</span> len(self.data)</span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">append</span><span class="params">(self, item)</span>:</span></span><br><span class="line">        self.data[len(self)] = item</span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__getitem__</span><span class="params">(self, key)</span>:</span></span><br><span class="line">        <span class="keyword">if</span> isinstance(key, int):</span><br><span class="line">            <span class="keyword">return</span> self.data[key]</span><br><span class="line">        <span class="keyword">if</span> isinstance(key, slice):</span><br><span class="line">            slicedkeys = list(self.data.keys())[key]</span><br><span class="line">            <span class="keyword">return</span> &#123;k: self.data[k] <span class="keyword">for</span> k <span class="keyword">in</span> slicedkeys&#125;</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="keyword">raise</span> TypeError</span><br><span class="line"></span><br><span class="line">d = MyDict()</span><br><span class="line">d.append(<span class="string">"My"</span>)</span><br><span class="line">d.append(<span class="string">"name"</span>)</span><br><span class="line">d.append(<span class="string">"is"</span>)</span><br><span class="line">d.append(<span class="string">"Python猫"</span>)</span><br><span class="line">print(d[<span class="number">2</span>])</span><br><span class="line">print(d[:<span class="number">2</span>])</span><br><span class="line">print(d[<span class="number">-4</span>:<span class="number">-2</span>])</span><br><span class="line">print(d[<span class="string">'hi'</span>])</span><br><span class="line"></span><br><span class="line"><span class="comment">### 输出结果：</span></span><br><span class="line"><span class="keyword">is</span></span><br><span class="line">&#123;<span class="number">0</span>: <span class="string">'My'</span>, <span class="number">1</span>: <span class="string">'name'</span>&#125;</span><br><span class="line">&#123;<span class="number">0</span>: <span class="string">'My'</span>, <span class="number">1</span>: <span class="string">'name'</span>&#125;</span><br><span class="line">Traceback (most recent call last):</span><br><span class="line">...</span><br><span class="line">TypeError</span><br></pre></td></tr></table></figure>
<p>上例的关键点在于将字典的键值取出，并对键值的列表做切片处理，其妙处在于，不用担心索引越界和负数索引，将字典切片转换成了字典键值的切片，最终实现目的。</p>
<h2 id="4、迭代器实现切片功能"><a href="#4、迭代器实现切片功能" class="headerlink" title="4、迭代器实现切片功能"></a>4、迭代器实现切片功能</h2><p>好了，介绍完一般的自定义对象如何实现切片功能，这里将迎来另一类非同一般的对象。</p>
<p>迭代器是 Python 中独特的一种高级对象，它本身不具备切片功能，然而若能将它用于切片，这便仿佛是锦上添花，能达到如虎添翼的效果。所以，本节将隆重地介绍迭代器如何实现切片功能。</p>
<h3 id="4-1、迭代与迭代器"><a href="#4-1、迭代与迭代器" class="headerlink" title="4.1、迭代与迭代器"></a>4.1、迭代与迭代器</h3><p>首先，有几个基本概念要澄清：迭代、可迭代对象、迭代器。</p>
<p><code>迭代</code> 是一种遍历容器类型对象（例如字符串、列表、字典等等）的方式，例如，我们说迭代一个字符串“abc”，指的就是从左往右依次地、逐个地取出它的全部字符的过程。（PS：汉语中迭代一词有循环反复、层层递进的意思，但 Python 中此词要理解成<strong>单向水平线性</strong> 的，如果你不熟悉它，我建议直接将其理解为遍历。）</p>
<p>那么，怎么写出迭代操作的指令呢？最通用的书写语法就是 for 循环。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># for循环实现迭代过程</span></span><br><span class="line"><span class="keyword">for</span> char <span class="keyword">in</span> <span class="string">"abc"</span>:</span><br><span class="line">    print(char, end=<span class="string">" "</span>)</span><br><span class="line"><span class="comment"># 输出结果：a b c</span></span><br></pre></td></tr></table></figure>
<p>for 循环可以实现迭代的过程，但是，并非所有对象都可以用于 for 循环，例如，上例中若将字符串“abc”换成任意整型数字，则会报错： ‘int’ object is not iterable .</p>
<p>这句报错中的单词“iterable”指的是“可迭代的”，即 int 类型不是可迭代的。而字符串（string）类型是可迭代的，同样地，列表、元组、字典等类型，都是可迭代的。</p>
<p>那怎么判断一个对象是否可迭代呢？为什么它们是可迭代的呢？怎么让一个对象可迭代呢？</p>
<p>要使一个对象可迭代，就要实现可迭代协议，即需要实现<code>__iter__()</code> 魔术方法，换言之，只要实现了这个魔术方法的对象都是可迭代对象。</p>
<p>那怎么判断一个对象是否实现了这个方法呢？除了上述的 for 循环外，我还知道四种方法：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 方法1：dir()查看__iter__</span></span><br><span class="line">dir(<span class="number">2</span>)     <span class="comment"># 没有，略</span></span><br><span class="line">dir(<span class="string">"abc"</span>) <span class="comment"># 有，略</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 方法2：isinstance()判断</span></span><br><span class="line"><span class="keyword">import</span> collections</span><br><span class="line">isinstance(<span class="number">2</span>, collections.Iterable)     <span class="comment"># False</span></span><br><span class="line">isinstance(<span class="string">"abc"</span>, collections.Iterable) <span class="comment"># True</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 方法3：hasattr()判断</span></span><br><span class="line">hasattr(<span class="number">2</span>,<span class="string">"__iter__"</span>)     <span class="comment"># False</span></span><br><span class="line">hasattr(<span class="string">"abc"</span>,<span class="string">"__iter__"</span>) <span class="comment"># True</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 方法4：用iter()查看是否报错</span></span><br><span class="line">iter(<span class="number">2</span>)     <span class="comment"># 报错：'int' object is not iterable</span></span><br><span class="line">iter(<span class="string">"abc"</span>) <span class="comment"># &lt;str_iterator at 0x1e2396d8f28&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">### PS：判断是否可迭代，还可以查看是否实现__getitem__，为方便描述，本文从略。</span></span><br></pre></td></tr></table></figure>
<p>这几种方法中最值得一提的是 iter() 方法，它是 Python 的内置方法，其作用是<strong>将可迭代对象变成迭代器</strong> 。这句话可以解析出两层意思：（1）可迭代对象跟迭代器是两种东西；（2）可迭代对象能变成迭代器。</p>
<p>实际上，迭代器必然是可迭代对象，但可迭代对象不一定是迭代器。两者有多大的区别呢？</p>
<p><img src="http://ww1.sinaimg.cn/large/68b02e3bly1fynwz67tj7j20vq0bxt9t.jpg" alt></p>
<p>如上图蓝圈所示，普通可迭代对象与迭代器的最关键区别可概括为：<strong>一同两不同</strong> ，所谓“一同”，即两者都是可迭代的（<code>__iter__</code>），所谓“两不同”，即可迭代对象在转化为迭代器后，它会丢失一些属性（<code>__getitem__</code>），同时也增加一些属性（<code>__next__</code>）。</p>
<p>首先看看增加的属性 <code>__next__</code> ， 它是迭代器之所以是迭代器的关键，事实上，我们正是把同时实现了 <code>__iter__</code> 方法 和 <code>__next__</code> 方法的对象定义为迭代器的。</p>
<p>有了多出来的这个属性，可迭代对象不需要借助外部的 for 循环语法，就能实现自我的迭代/遍历过程。我发明了两个概念来描述这两种遍历过程（PS：为了易理解，这里称遍历，实际也可称为迭代）：<code>它遍历</code> 指的是通过外部语法而实现的遍历，<code>自遍历</code> 指的是通过自身方法实现的遍历。</p>
<p>借助这两个概念，我们说，可迭代对象就是能被“它遍历”的对象，而迭代器是在此基础上，还能做到“自遍历”的对象。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">ob1 = <span class="string">"abc"</span></span><br><span class="line">ob2 = iter(<span class="string">"abc"</span>)</span><br><span class="line">ob3 = iter(<span class="string">"abc"</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># ob1它遍历</span></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> ob1:</span><br><span class="line">    print(i, end = <span class="string">" "</span>)   <span class="comment"># a b c</span></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> ob1:</span><br><span class="line">    print(i, end = <span class="string">" "</span>)   <span class="comment"># a b c</span></span><br><span class="line"><span class="comment"># ob1自遍历</span></span><br><span class="line">ob1.__next__()  <span class="comment"># 报错： 'str' object has no attribute '__next__'</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># ob2它遍历</span></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> ob2:</span><br><span class="line">    print(i, end = <span class="string">" "</span>)   <span class="comment"># a b c    </span></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> ob2:</span><br><span class="line">    print(i, end = <span class="string">" "</span>)   <span class="comment"># 无输出</span></span><br><span class="line"><span class="comment"># ob2自遍历</span></span><br><span class="line">ob2.__next__()  <span class="comment"># 报错：StopIteration</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># ob3自遍历</span></span><br><span class="line">ob3.__next__()  <span class="comment"># a</span></span><br><span class="line">ob3.__next__()  <span class="comment"># b</span></span><br><span class="line">ob3.__next__()  <span class="comment"># c</span></span><br><span class="line">ob3.__next__()  <span class="comment"># 报错：StopIteration</span></span><br></pre></td></tr></table></figure>
<p>通过上述例子可看出，迭代器的优势在于支持自遍历，同时，它的特点是单向非循环的，一旦完成遍历，再次调用就会报错。</p>
<p>对此，我想到一个比方：普通可迭代对象就像是子弹匣，它遍历就是取出子弹，在完成操作后又装回去，所以可以反复遍历（即多次调用for循环，返回相同结果）；而迭代器就像是装载了子弹匣且不可拆卸的枪，进行它遍历或者自遍历都是发射子弹，这是消耗性的遍历，是无法复用的（即遍历会有尽头）。</p>
<p>写了这么多，稍微小结一下：<strong>迭代是一种遍历元素的方式，按照实现方式划分，有外部迭代与内部迭代两种，支持外部迭代（它遍历）的对象就是可迭代对象，而同时还支持内部迭代（自遍历）的对象就是迭代器；按照消费方式划分，可分为复用型迭代与一次性迭代，普通可迭代对象是复用型的，而迭代器是一次性的。</strong> </p>
<h3 id="4-2、迭代器切片"><a href="#4-2、迭代器切片" class="headerlink" title="4.2、迭代器切片"></a>4.2、迭代器切片</h3><p>前面提到了“一同两不同”，最后的不同是，普通可迭代对象在转化成迭代器的过程中会丢失一些属性，其中关键的属性是 <code>__getitem__</code> 。在前一节中，我已经介绍了这个魔术方法，并用它实现了自定义对象的切片特性。</p>
<p>那么问题来了：为什么迭代器不继承这个属性呢？</p>
<p>首先，迭代器使用的是消耗型的遍历，这意味着它充满不确定性，即其长度与索引键值对是动态衰减的，所以很难 get 到它的 item ，也就不再需要 <code>__getitem__</code> 属性了。其次，若强行给迭代器加上这个属性，这并不合理，正所谓强扭的瓜不甜……</p>
<p>由此，新的问题来了：既然会丢失这么重要的属性（还包括其它未标识的属性），为什么还要使用迭代器呢？</p>
<p>这个问题的答案在于，迭代器拥有不可替代的强大的有用的功能，使得 Python 要如此设计它。限于篇幅，此处不再展开，后续我会专门填坑此话题。</p>
<p>还没完，死缠烂打的问题来了：能否令迭代器拥有这个属性呢，即令迭代器继续支持切片呢？</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">hi = <span class="string">"欢迎关注公众号：Python猫"</span></span><br><span class="line">it = iter(hi)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 普通切片</span></span><br><span class="line">hi[<span class="number">-7</span>:] <span class="comment"># Python猫</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 反例：迭代器切片</span></span><br><span class="line">it[<span class="number">-7</span>:] <span class="comment"># 报错：'str_iterator' object is not subscriptable</span></span><br></pre></td></tr></table></figure>
<p>迭代器因为缺少<code>__getitem__</code> ，因此不能使用普通的切片语法。想要实现切片，无非两种思路：一是自己造轮子，写实现的逻辑；二是找到封装好的轮子。</p>
<p>Python 的 itertools 模块就是我们要找的轮子，用它提供的方法可轻松实现迭代器切片。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> itertools</span><br><span class="line"></span><br><span class="line"><span class="comment"># 例1：简易迭代器</span></span><br><span class="line">s = iter(<span class="string">"123456789"</span>)</span><br><span class="line"><span class="keyword">for</span> x <span class="keyword">in</span> itertools.islice(s, <span class="number">2</span>, <span class="number">6</span>):</span><br><span class="line">    print(x, end = <span class="string">" "</span>)   <span class="comment"># 输出：3 4 5 6</span></span><br><span class="line"><span class="keyword">for</span> x <span class="keyword">in</span> itertools.islice(s, <span class="number">2</span>, <span class="number">6</span>):</span><br><span class="line">    print(x, end = <span class="string">" "</span>)   <span class="comment"># 输出：9</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 例2：斐波那契数列迭代器</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Fib</span><span class="params">()</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self)</span>:</span></span><br><span class="line">        self.a, self.b = <span class="number">1</span>, <span class="number">1</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__iter__</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">            <span class="keyword">yield</span> self.a</span><br><span class="line">            self.a, self.b = self.b, self.a + self.b</span><br><span class="line">f = iter(Fib())</span><br><span class="line"><span class="keyword">for</span> x <span class="keyword">in</span> itertools.islice(f, <span class="number">2</span>, <span class="number">6</span>):</span><br><span class="line">    print(x, end = <span class="string">" "</span>)  <span class="comment"># 输出：2 3 5 8</span></span><br><span class="line"><span class="keyword">for</span> x <span class="keyword">in</span> itertools.islice(f, <span class="number">2</span>, <span class="number">6</span>):</span><br><span class="line">    print(x, end = <span class="string">" "</span>)  <span class="comment"># 输出：34 55 89 144</span></span><br></pre></td></tr></table></figure>
<p>itertools 模块的 islice() 方法将迭代器与切片完美结合，终于回答了前面的问题。然而，迭代器切片跟普通切片相比，前者有很多局限性。首先，这个方法不是“纯函数”（纯函数需遵守“相同输入得到相同输出”的原则）；其次，它只支持正向切片，且不支持负数索引，这都是由迭代器的损耗性所决定的。</p>
<p>那么，我不禁要问：itertools 模块的切片方法用了什么实现逻辑呢？下方是官网提供的源码：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">islice</span><span class="params">(iterable, *args)</span>:</span></span><br><span class="line">    <span class="comment"># islice('ABCDEFG', 2) --&gt; A B</span></span><br><span class="line">    <span class="comment"># islice('ABCDEFG', 2, 4) --&gt; C D</span></span><br><span class="line">    <span class="comment"># islice('ABCDEFG', 2, None) --&gt; C D E F G</span></span><br><span class="line">    <span class="comment"># islice('ABCDEFG', 0, None, 2) --&gt; A C E G</span></span><br><span class="line">    s = slice(*args)</span><br><span class="line">    <span class="comment"># 索引区间是[0,sys.maxsize]，默认步长是1</span></span><br><span class="line">    start, stop, step = s.start <span class="keyword">or</span> <span class="number">0</span>, s.stop <span class="keyword">or</span> sys.maxsize, s.step <span class="keyword">or</span> <span class="number">1</span></span><br><span class="line">    it = iter(range(start, stop, step))</span><br><span class="line">    <span class="keyword">try</span>:</span><br><span class="line">        nexti = next(it)</span><br><span class="line">    <span class="keyword">except</span> StopIteration:</span><br><span class="line">        <span class="comment"># Consume *iterable* up to the *start* position.</span></span><br><span class="line">        <span class="keyword">for</span> i, element <span class="keyword">in</span> zip(range(start), iterable):</span><br><span class="line">            <span class="keyword">pass</span></span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line">    <span class="keyword">try</span>:</span><br><span class="line">        <span class="keyword">for</span> i, element <span class="keyword">in</span> enumerate(iterable):</span><br><span class="line">            <span class="keyword">if</span> i == nexti:</span><br><span class="line">                <span class="keyword">yield</span> element</span><br><span class="line">                nexti = next(it)</span><br><span class="line">    <span class="keyword">except</span> StopIteration:</span><br><span class="line">        <span class="comment"># Consume to *stop*.</span></span><br><span class="line">        <span class="keyword">for</span> i, element <span class="keyword">in</span> zip(range(i + <span class="number">1</span>, stop), iterable):</span><br><span class="line">            <span class="keyword">pass</span></span><br></pre></td></tr></table></figure>
<p>islice() 方法的索引方向是受限的，但它也提供了一种可能性：即允许你对一个无穷的（在系统支持范围内）迭代器进行切片的能力。这是迭代器切片最具想象力的用途场景。</p>
<p>除此之外，迭代器切片还有一个很实在的应用场景：读取文件对象中给定行数范围的数据。</p>
<p>我们知道，从文件中读取内容主要有两种方法（参见之前关于文件读写的文章）：read() 适合读取内容较少的情况，或者是需要一次性处理全部内容的情况；而 readlines() 适用性更广，因为它是迭代地读取内容，既减少内存压力，又方便逐行对数据处理。</p>
<p>虽然 readlines() 有迭代读取的优势，但它是从头到尾逐行读取，若文件有几千行，而我们只想要读取少数特定行（例如第1000-1009行），那它还是效率太低了。考虑到<strong>文件对象天然就是迭代器</strong> ，我们可以使用迭代器切片先行截取，然后再处理，如此效率将大大地提升。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># test.txt 文件内容</span></span><br><span class="line"><span class="string">'''</span></span><br><span class="line"><span class="string">猫</span></span><br><span class="line"><span class="string">Python猫</span></span><br><span class="line"><span class="string">python is a cat.</span></span><br><span class="line"><span class="string">this is the end.</span></span><br><span class="line"><span class="string">'''</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">from</span> itertools <span class="keyword">import</span> islice</span><br><span class="line"><span class="keyword">with</span> open(<span class="string">'test.txt'</span>,<span class="string">'r'</span>,encoding=<span class="string">'utf-8'</span>) <span class="keyword">as</span> f:</span><br><span class="line">    print(hasattr(f, <span class="string">"__next__"</span>))  <span class="comment"># 判断是否迭代器</span></span><br><span class="line">    content = islice(f, <span class="number">2</span>, <span class="number">4</span>)</span><br><span class="line">    <span class="keyword">for</span> line <span class="keyword">in</span> content:</span><br><span class="line">        print(line.strip())</span><br><span class="line"><span class="comment">### 输出结果：</span></span><br><span class="line"><span class="literal">True</span></span><br><span class="line">python <span class="keyword">is</span> a cat.</span><br><span class="line">this <span class="keyword">is</span> the end.</span><br></pre></td></tr></table></figure>
<p>本节内容较多，简单回顾一下：迭代器是一种特殊的可迭代对象，可用于它遍历与自遍历，但遍历过程是损耗型的，不具备循环复用性，因此，迭代器本身不支持切片操作；通过借助 itertools 模块，我们能实现迭代器切片，将两者的优势相结合，其主要用途在于截取大型迭代器（如无限数列、超大文件等等）的片段，实现精准的处理，从而大大地提升性能与效率。</p>
<h2 id="5、小结"><a href="#5、小结" class="headerlink" title="5、小结"></a>5、小结</h2><p>最后总结一下，切片是 Python 的一种高级特性，常用于截取序列类型的元素，但并不局限于此，本文主要介绍了它的基础用法、高级用法（如占位符用法）、自定义对象切片、以及迭代器切片等使用内容。除此之外，切片还有更广阔多样的使用场景，例如 Numpy 的多维切片、内存视图切片、异步迭代器切片等等，都值得我们去探索一番，今限于篇幅而无法细说，欢迎关注公众号“<strong>Python猫</strong> ”，以后我们慢慢学习之。</p>
<p><strong>切片系列（原单篇）：</strong> </p>
<p><a href="https://mp.weixin.qq.com/s/fwZnvcQ_u-fYLFeQaYkJLw" target="_blank" rel="noopener">Python进阶：切片的误区与高级用法</a></p>
<p><a href="https://mp.weixin.qq.com/s/QTodsriWW_gESvmJPD1EYg" target="_blank" rel="noopener">Python进阶：自定义对象实现切片功能</a></p>
<p><a href="https://mp.weixin.qq.com/s/DIhwoJE3o0kKw3kzZKysag" target="_blank" rel="noopener">Python进阶：迭代器与迭代器切片</a></p>
<p><strong>相关链接：</strong> </p>
<p>官方文档getitem用法：<a href="http://t.cn/EbzoZyp" target="_blank" rel="noopener">http://t.cn/EbzoZyp</a></p>
<p>切片赋值的源码分析：<a href="http://t.cn/EbzSaoZ" target="_blank" rel="noopener">http://t.cn/EbzSaoZ</a></p>
<p>官网itertools模块介绍：<a href="http://t.cn/EbNc0ot" target="_blank" rel="noopener">http://t.cn/EbNc0ot</a></p>
<p><a href="https://mp.weixin.qq.com/s/PsY8Iec1EeGDKKnTNU5CNw" target="_blank" rel="noopener">Python是否支持复制字符串呢？</a></p>
<p><a href="https://mp.weixin.qq.com/s/2l_erf55IMvT4Tz0AGWCUQ" target="_blank" rel="noopener">来自Kenneth Reitz大神的建议：避免不必要的面向对象编程</a></p>
<p><a href="https://mp.weixin.qq.com/s/Md07VoaULda7qnMO4ob7Ww" target="_blank" rel="noopener">给Python学习者的文件读写指南（含基础与进阶，建议收藏）</a></p>
<p><a href="https://mp.weixin.qq.com/s/Whrd6NiD4Y2Z-YSCy4XJ1w" target="_blank" rel="noopener">详解Python拼接字符串的七种方式</a></p>
<p>-—————-</p>
<p>本文原创并首发于微信公众号【Python猫】，后台回复“爱学习”，免费获得20+本精选电子书。</p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://chinesehuazhou.github.io/2019/05/03/Python进阶/Python为什么不支持复制字符串？/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="John Doe">
      <meta itemprop="description" content>
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="豌豆花下猫">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2019/05/03/Python进阶/Python为什么不支持复制字符串？/" itemprop="url">未命名</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2019-05-03T21:21:22+08:00">
                2019-05-03
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="Python是否支持复制字符串呢？"><a href="#Python是否支持复制字符串呢？" class="headerlink" title="Python是否支持复制字符串呢？"></a>Python是否支持复制字符串呢？</h1><p>连续几篇文章都在写 Python 字符串，这出乎我的意料了。但是，有的问题，不写不行，特别是那种灵机一动想到的问题，最后你发现，<strong>很多人根本不懂却又误以为自己懂了</strong>。那就继续刨根问底，探究个明白吧。</p>
<p>在上一篇文章《<a href="https://mp.weixin.qq.com/s/M4_38VHlQwp-CDRczh2NIA" target="_blank" rel="noopener">你真的知道Python的字符串怎么用吗？</a>》里，我突发奇想，将字符串跟列表做了比较，然后发现字符串竟然没有复制的方法。当时没有细想，只说要搁置疑问。过后，有好学的小伙伴在后台留言，与我交流这个问题，给了我一些启发。为了彻底弄懂它，我继续查了不少资料，今天，就跟大家分享一下我发现的东西吧。</p>
<p>本文标题的问题分为两部分：（1）Python 中是否支持复制字符串？（2）如果不支持，为什么不支持？</p>
<p>请读者花几分钟想一下，想清楚后，把你的答案记住，然后再往下看。</p>
<p>让我们做一个约定（自愿遵守）：如果看到最后，你推翻了现在的答案，建立了新的认知，这说明我写的内容有用，那请你任意赞赏，或者将本文分享给其他使用 Python 的小伙伴。</p>
<h2 id="1-什么是复制字符串？"><a href="#1-什么是复制字符串？" class="headerlink" title="1. 什么是复制字符串？"></a>1. 什么是复制字符串？</h2><p>首先，必须要大家对“复制”这个概念达成共识。复制，也叫<strong>拷贝</strong>，英文单词是 copy，具体意思是“<strong>将某事物通过某种方式制作成相同的一份或多份的行为</strong>”（释义来自维基百科）。复制的结果是，出现了多份极其相似但却相互独立的事物（副本），举例来说，你有一份文档 X，然后复制一份并重新命名为 Y，这两者是相互独立的，若你删除其中一个，另一个不会一起被删除。</p>
<p>这个词用在 Python 里，我们想表达的是同样的意思，即复制行为会产生新的独立对象，它与原始对象极其相似，但两者的生命周期没有直接的关联关系。下面先用列表来举例：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">list1 = [1,2]</span><br><span class="line">id(list1) </span><br><span class="line">&gt;&gt;&gt; 1981119454856</span><br><span class="line"></span><br><span class="line">list2 = list1.copy()</span><br><span class="line">print(list1 == list2) </span><br><span class="line">&gt;&gt;&gt; True</span><br><span class="line">id(list2)</span><br><span class="line">&gt;&gt;&gt; 1981116983752</span><br></pre></td></tr></table></figure>
<p>上例中，列表 list2 是 list1 的副本，两者字面量相等，但是内存地址（即 id ）不相等，是两个相互独立的对象。如果字符串能够做到同样的效果，那我们就说，字符串可以被复制，否则，我们说字符串不可以被复制。</p>
<h2 id="2-怎样能复制字符串？"><a href="#2-怎样能复制字符串？" class="headerlink" title="2. 怎样能复制字符串？"></a>2. 怎样能复制字符串？</h2><p>有了上面的概念和示例，请先思考，你会用什么方式复制字符串呢？（暂停，思考3分钟）</p>
<p>好了，先看看下面的几种方法：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">s0 = &quot;Python猫&quot;</span><br><span class="line"></span><br><span class="line">s1 = s0</span><br><span class="line">s2 = str(s0)</span><br><span class="line">s3 = s0[:]</span><br><span class="line">s4 = s0 + &apos;&apos;</span><br><span class="line">s5 = &apos;%s&apos; % s0</span><br><span class="line">s6 = s0 * 1</span><br><span class="line">s7 = &quot;&quot;.join(s0)</span><br><span class="line">import copy</span><br><span class="line">s8 = copy.copy(s0)</span><br></pre></td></tr></table></figure>
<p>你想到的复制方式是否在以上8种方式里呢？那么，如果把 s0 至 s8 的 id 打印出来，有哪些会跟 s0 不同呢？</p>
<p>答案是，<strong>它们的内存地址 id 完全相同</strong>，也就是说，一顿操作猛如虎，结果却始终只有一份字符串，根本没有复制出新的字符串！</p>
<p><code>Python猫</code> 的老读者看到这，会心一笑，这不就是因为字符串的 Intern 机制嘛，短字符串在内存中只会存在一份，在《<a href="https://mp.weixin.qq.com/s/vCs6QvJU2J6L0rIWDKQPUQ" target="_blank" rel="noopener">Python中的“特权种族”是什么？</a>》这篇文章里提到过的。</p>
<p>但请别开心得太早，你可以把 s0 改成一个超长的字符串，例如：</p>
<blockquote>
<p>s0 = “Python猫是来自喵星的客人，它喜欢地球和人类，正在学习Python，而且想借助Python变成人，它的微信公众号也叫Python猫，欢迎你关注哦，喵喵喵喵<del>~</del>~~”</p>
</blockquote>
<p>然后，再重复上面的操作。最终，你会发现，s0 到 s8 的 id 还是完全相同。</p>
<p>是不是吃惊了呢？新的 s0 明明已经超过 Intern 机制的长度了，为什么不会产生新的字符串呢？</p>
<p>首先，请你相信，<strong>超出 Intern 机制的字符串可以存在多份</strong>，即你可以创建出值完全相同的多个字符串对象，因为字符串对象在内存中并不一定是唯一的：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">s9 = &quot;Python猫是来自喵星的客人，它喜欢地球和人类，正在学习Python，而且想借助Python变成人，它的微信公众号也叫Python猫，欢迎你关注哦，喵喵喵喵~~~&quot;</span><br><span class="line"></span><br><span class="line">print(id(s0) == id(s9))</span><br><span class="line">&gt;&gt;&gt; False</span><br></pre></td></tr></table></figure>
<p>上例表明，你可以创建出多个相同的字符串对象，但是这种方法与前面列举的8种不同，因为它是独立于 s0 的操作，并不是一种复制操作。从理论上讲，Python 完全可以提供一个方法，达到复制出新的副本的结果。现在的问题恰恰就是：<strong>为什么允许存在多个相等的字符串对象，但是却无法通过复制的方式来创建呢？</strong> </p>
<h2 id="3-为什么不允许复制字符串？"><a href="#3-为什么不允许复制字符串？" class="headerlink" title="3. 为什么不允许复制字符串？"></a>3. 为什么不允许复制字符串？</h2><p>我发现，不仅字符串不允许复制，元组也如此，事实上，还有 int 、float 也不支持复制。它们都是不可变对象，为什么不可变对象就不支持复制操作呢？</p>
<p>在查资料的时候，我发现网上很多文章对于“不可变对象”的认识存在误区，这些人不知道 Intern 机制的存在，误以为字符串对象在内存只能有唯一一个，进而误以为不可变对象就是在内存中只有一份的对象。所以，这些文章很容易推断出错误的结论：因为字符串是不可变对象，所以字符串不支持复制。</p>
<p>事实上，不可变对象跟复制操作之间，并没有必然的强相关的关系。肯定是出于别的原因，设计者才给不可变对象加上这种限制，这个原因是什么呢？</p>
<p>在知乎上，有敏锐的同学提出了我的疑问“<a href="https://www.zhihu.com/question/41527532" target="_blank" rel="noopener">Python中如何复制一个值或字符串？</a>”，可惜只有4个回答，而且都没答到点上。Stackoverflow上恰好也有一个问题“<a href="https://stackoverflow.com/questions/24804453/how-can-i-copy-a-python-string" target="_blank" rel="noopener">How can I copy a Python string?</a>”，同样没多少人注意到，只有5个回答，好在最高票答案提到了一个点，即这样可以加快字典的查找速度。</p>
<p>然而，他说的这个点并不靠谱。字典要求键值是可哈希对象，可是计算字符串的哈希值是根据字面值计算，所以对多个相等的字符串对象，其哈希值其实是一样的，对计算和查找根本无影响。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">w1 = &quot;Python猫是来自喵星的客人，它喜欢地球和人类，正在学习Python，而且想借助Python变成人，它的微信公众号也叫Python猫，欢迎你关注哦，喵喵喵喵~~~&quot;</span><br><span class="line">w2 = &quot;Python猫是来自喵星的客人，它喜欢地球和人类，正在学习Python，而且想借助Python变成人，它的微信公众号也叫Python猫，欢迎你关注哦，喵喵喵喵~~~&quot;</span><br><span class="line"></span><br><span class="line">print(w1 == w2) </span><br><span class="line">&gt;&gt;&gt; True</span><br><span class="line">print(id(w1) == id(w2)) </span><br><span class="line">&gt;&gt;&gt; False </span><br><span class="line">print(hash(w1) == hash(w2)) </span><br><span class="line">&gt;&gt;&gt; True</span><br></pre></td></tr></table></figure>
<p>继续查资料，终于在《流畅的Python》找到了明确的解释：</p>
<blockquote>
<p>这些细节是 CPython 核心开发者走的捷径和做的优化措施，对这门语言的用户而言无需了解，而且那些细节对其他 Python 实现可能没用，CPython 未来的版本可能也不会用。</p>
</blockquote>
<p>这本《流畅的Python》是进阶首选书目之一，我曾读过部分章节，没想到在一个不起眼的小节里，作者 “惊讶地发现” 元组的不可复制性，在此之前，他还自以为“对元组无所不知”，哈哈哈。</p>
<p>虽然，我早猜测到原因是节省内存和提高速度，但看到这个明确的解释，知道这只是CPython 解释器的“善意的谎言”，而且在未来版本可能不会用，我感到特别意外。</p>
<p>它证实了我的猜测，同时，也提供了超预期的信息：<strong>其它 Python 解释器可能支持复制不可变对象，目前 CPython 算是一种妥协，在未来可能会恢复不可变对象的复制操作呢！</strong> </p>
<p>回到文章开头的两个问题，我们得到的答案是：<strong>Python 本身并不限制字符串的复制操作，只是当前版本的 CPython 做了优化，才导致出现这种“善意的谎言”，它这么做的原因为了对 Intern 机制做补充，设法使全部字符串对象在内存都只有一份，以达到节省内存的效果。</strong> </p>
<p>CPython 是用 C 语言实现的 Python 解释器，是官方的、使用最广泛的解释器。除了它，还有用 Java 实现的 Jython 解释器、用 .NET 实现的 IronPython 解释器、用 Python 实现的 PyPy 解释器，等等。其它解释器都是怎么应对字符串的复制操作的呢？唉，学无止境，本人才疏学浅没有涉猎，还是先搁置疑问吧。</p>
<p>这里，我就想提一个题外话，Python 最最最广为人诟病的就是 GIL（全局解释器锁），这导致它不支持真正意义的多线程，成为很多人指责 Python 慢的元凶。但是，这个问题是 CPython 解释器带来的，而像 Jython 解释器就不存在这个问题。</p>
<p>好了，就此打住吧。你是否还记得在文章开头时想到的答案呢？是否改变了最初的想法呢？欢迎关注公众号 <strong>Python猫</strong> ，来跟我交流，一起来学习 Python ，做个合格的 <code>Pythonista</code>。</p>
<p>参考学习：</p>
<p>《流畅的Python》</p>
<p><a href="https://www.zhihu.com/question/41527532" target="_blank" rel="noopener">https://www.zhihu.com/question/41527532</a></p>
<p><a href="https://dwz.cn/4o0WXy8G" target="_blank" rel="noopener">https://dwz.cn/4o0WXy8G</a></p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
  </section>

  
  <nav class="pagination">
    <a class="extend prev" rel="prev" href="/page/3/"><i class="fa fa-angle-left"></i></a><a class="page-number" href="/">1</a><span class="space">&hellip;</span><a class="page-number" href="/page/3/">3</a><span class="page-number current">4</span><a class="page-number" href="/page/5/">5</a><a class="extend next" rel="next" href="/page/5/"><i class="fa fa-angle-right"></i></a>
  </nav>



          </div>
          


          

        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    
    <div class="sidebar-inner">

      

      

      <section class="site-overview-wrap sidebar-panel sidebar-panel-active">
        <div class="site-overview">
          <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
            
              <p class="site-author-name" itemprop="name">John Doe</p>
              <p class="site-description motion-element" itemprop="description"></p>
          </div>

          <nav class="site-state motion-element">

            
              <div class="site-state-item site-state-posts">
              
                <a href="/archives/">
              
                  <span class="site-state-item-count">44</span>
                  <span class="site-state-item-name">日志</span>
                </a>
              </div>
            

            

            

          </nav>

          

          

          
          

          
          

          

        </div>
      </section>

      

      

    </div>
  </aside>


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright">&copy; <span itemprop="copyrightYear">2019</span>
  <span class="with-love">
    <i class="fa fa-user"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">John Doe</span>

  
</div>


  <div class="powered-by">由 <a class="theme-link" target="_blank" href="https://hexo.io">Hexo</a> 强力驱动</div>



  <span class="post-meta-divider">|</span>



  <div class="theme-info">主题 &mdash; <a class="theme-link" target="_blank" href="https://github.com/iissnan/hexo-theme-next">NexT.Muse</a> v5.1.4</div>




        







        
      </div>
    </footer>

    
      <div class="back-to-top">
        <i class="fa fa-arrow-up"></i>
        
      </div>
    

    

  </div>

  

<script type="text/javascript">
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>









  












  
  
    <script type="text/javascript" src="/lib/jquery/index.js?v=2.1.3"></script>
  

  
  
    <script type="text/javascript" src="/lib/fastclick/lib/fastclick.min.js?v=1.0.6"></script>
  

  
  
    <script type="text/javascript" src="/lib/jquery_lazyload/jquery.lazyload.js?v=1.9.7"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/fancybox/source/jquery.fancybox.pack.js?v=2.1.5"></script>
  


  


  <script type="text/javascript" src="/js/src/utils.js?v=5.1.4"></script>

  <script type="text/javascript" src="/js/src/motion.js?v=5.1.4"></script>



  
  

  

  


  <script type="text/javascript" src="/js/src/bootstrap.js?v=5.1.4"></script>



  


  




	





  





  












  





  

  

  

  
  

  

  

  

</body>
</html>
