<!DOCTYPE html>



  


<html class="theme-next muse use-motion" lang="zh-Hans">
<head><meta name="generator" content="Hexo 3.8.0">
  <meta charset="UTF-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
<meta name="theme-color" content="#222">









<meta http-equiv="Cache-Control" content="no-transform">
<meta http-equiv="Cache-Control" content="no-siteapp">
















  
  
  <link href="/lib/fancybox/source/jquery.fancybox.css?v=2.1.5" rel="stylesheet" type="text/css">







<link href="/lib/font-awesome/css/font-awesome.min.css?v=4.6.2" rel="stylesheet" type="text/css">

<link href="/css/main.css?v=5.1.4" rel="stylesheet" type="text/css">


  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png?v=5.1.4">


  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png?v=5.1.4">


  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png?v=5.1.4">


  <link rel="mask-icon" href="/images/logo.svg?v=5.1.4" color="#222">





  <meta name="keywords" content="Hexo, NexT">










<meta property="og:type" content="website">
<meta property="og:title" content="豌豆花下猫">
<meta property="og:url" content="https://chinesehuazhou.github.io/page/3/index.html">
<meta property="og:site_name" content="豌豆花下猫">
<meta property="og:locale" content="zh-Hans">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="豌豆花下猫">



<script type="text/javascript" id="hexo.configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '/',
    scheme: 'Muse',
    version: '5.1.4',
    sidebar: {"position":"left","display":"post","offset":12,"b2t":false,"scrollpercent":false,"onmobile":false},
    fancybox: true,
    tabs: true,
    motion: {"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},
    duoshuo: {
      userId: '0',
      author: '博主'
    },
    algolia: {
      applicationID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    }
  };
</script>



  <link rel="canonical" href="https://chinesehuazhou.github.io/page/3/">





  <title>豌豆花下猫</title>
  








</head>

<body itemscope itemtype="http://schema.org/WebPage" lang="zh-Hans">

  
  
    
  

  <div class="container sidebar-position-left 
  page-home">
    <div class="headband"></div>

    <header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-wrapper">
  <div class="site-meta ">
    

    <div class="custom-logo-site-title">
      <a href="/" class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">豌豆花下猫</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
      
        <p class="site-subtitle"></p>
      
  </div>

  <div class="site-nav-toggle">
    <button>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
    </button>
  </div>
</div>

<nav class="site-nav">
  

  
    <ul id="menu" class="menu">
      
        
        <li class="menu-item menu-item-home">
          <a href="/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-home"></i> <br>
            
            首页
          </a>
        </li>
      
        
        <li class="menu-item menu-item-archives">
          <a href="/archives/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-archive"></i> <br>
            
            归档
          </a>
        </li>
      

      
    </ul>
  

  
</nav>



 </div>
    </header>

    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          <div id="content" class="content">
            
  <section id="posts" class="posts-expand">
    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://chinesehuazhou.github.io/2019/05/03/纪念 Vamei/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="John Doe">
      <meta itemprop="description" content>
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="豌豆花下猫">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2019/05/03/纪念 Vamei/" itemprop="url">未命名</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2019-05-03T21:21:22+08:00">
                2019-05-03
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="纪念-Vamei"><a href="#纪念-Vamei" class="headerlink" title="纪念 Vamei"></a>纪念 Vamei</h1><p>偶然在某公众号里看到一篇文章，得知 Vamei 去世的消息。</p>
<p>看到它之前，我并不知道这位“知名的 Python 技术博主”。我写 Python 技术文章有一小段时间了，也认识了很多圈内的博主。但是，这个 Vamei 是谁呢？竟不认识。我很好奇。</p>
<p>因为消息是从豆瓣里传出来的，我就去搜他的豆瓣。然后，一路看到了他的知乎，他的书，他的技术博客，他的演讲，他的微博，甚至他的公众号，也看到了一些友人的纪念文章。</p>
<p>看得越多，我就越放不下了。正好我在写一篇荐书栏目，就发现他跟我恰巧同时在读着一本未上市的新书。这个难得的巧合让我更不能释怀，我自以为这是一个神秘主义的讯息。</p>
<p>该拿他怎么办呢？我决定就写下这篇东西，以作纪念吧。</p>
<h2 id="（1）一首诗"><a href="#（1）一首诗" class="headerlink" title="（1）一首诗"></a>（1）一首诗</h2><p>他在豆瓣的最后一篇日记是一首诗：</p>
<blockquote>
<p>《寻影》</p>
<p>远处的光臆造身前的影。</p>
<p>影高而大，</p>
<p>噬我，缠绕我，御我为奴。</p>
<p>我与影欢歌。</p>
<p>倏忽，</p>
<p>光灭影消。</p>
<p>黑漆漆的我，</p>
<p>不知何处寻影。</p>
</blockquote>
<p>发布时间 2 月 21 日，距离世日期仅一周。</p>
<p><img src="http://ww1.sinaimg.cn/large/68b02e3bgy1g0wy6ejeipj20u00u0754.jpg" alt></p>
<p>一个臆造的高大的影，吃人奴役人，然而他说，与影欢歌。这是哪种的乐？是愚者后知后觉，还是英雄苦中寻乐？</p>
<p>光灭影消，不去寻光，却要找影，为什么？是因为没有了光，还是他离不开影？</p>
<p>黑漆漆的 Vamei，他的外号是“挖煤”。</p>
<p>挖煤，挖煤，挖的是什么煤？</p>
<p>挖出来知识的煤、技术的煤，照亮了读者。可是没有挖出生命的煤，又或者是，挖出的那生命的煤已烧干净了呢，没办法再继续照亮他自己？</p>
<h2 id="（2）他是谁？"><a href="#（2）他是谁？" class="headerlink" title="（2）他是谁？"></a>（2）他是谁？</h2><p>他生于 1988 年，本科毕业于中科大，博士毕业于南洋理工。</p>
<p>他出版了两本纸书《从Python开始学编程》和《树莓派开始，玩转Linux》，在豆瓣读书上出了 6 本电子书，内容既有网络协议、新加坡考古、气象人物与历史，还有手机摄影，以及一本中篇科幻小说。</p>
<p>他写技术博客，内容有 Python/Linux/网络协议/算法/Java/数据科学的系列文章，200 多篇，据统计，总阅读量超过 800 万。按照积分排名，他是 156 名。</p>
<p>他是某智能农业公司的首席技术官，因 AI 养猪而闻名，被邀请上《一席》节目做过分享。他演讲时幽默风趣，堪称程序员界的段子手。</p>
<p><img src="http://ww1.sinaimg.cn/large/68b02e3bgy1g0wxw14l05j20p20hm1b9.jpg" alt="Vamei制服一头猪"></p>
<p>他兴趣广泛，学识渊博，从电影中聊历史，从名画中聊天气，写过科普，写过手机摄影教程。有作品发表在南方人物周刊、国家人文历史、澎湃新闻、果壳网这样的主流媒体上。</p>
<p>他研究过创伤心理学，写过一篇《没有杀死我的》。语自尼采——<strong>没有杀死我的让我更强大。</strong> </p>
<p>在这篇文章的末尾，他写道：</p>
<blockquote>
<p>我的记忆中有一些窘迫或者恐惧的片段，希望有一天能够淡然看待这些。</p>
<p>痛并快乐着，送给所有努力和创伤斗争的朋友。</p>
</blockquote>
<h2 id="（3）什么杀了他？"><a href="#（3）什么杀了他？" class="headerlink" title="（3）什么杀了他？"></a>（3）什么杀了他？</h2><p>我想在他留下来的痕迹里找出一个解释：这么一个有趣的人，是什么杀了他？</p>
<p><img src="http://ww1.sinaimg.cn/large/68b02e3bgy1g0wv9p3qnhj20q00eago3.jpg" alt="一个友人的豆瓣广播"></p>
<p>所有认识他的人都表示震惊，一个阳光男孩，一个风趣博主，怎么说走就走了呢？</p>
<p>一个插画师说：“回来吧 你书稿还没写完啊”。</p>
<p>一个朋友说：“记得几个月前还在问我办理准生证的事”。另一个朋友说：“我还以为他忙于工作和照看婴儿，像我在我女儿刚出生那时一样，无暇顾及社交”。</p>
<p>大家都没想到。没有任何迹象，除了那首短诗。</p>
<p>人们常说，女性可能会得产后抑郁。可是，作为一个新晋爸爸，他怎么也抑郁了呢？那到底是多重的抑郁，才会使一个丈夫、一个爸爸，抛家弃子，纵身跃下高楼？</p>
<p>Vamei 写下了很多文字，但几乎没有写过家庭和家人。我做了一番侦探工作，才仅仅获得几条零碎的线索。最近的一条是 2015 年的年终回顾，他写到：</p>
<blockquote>
<p>最先浮现的是一些快乐的孤点。和太太躲在阳台上吃自制的麻辣香锅，被辣得快要晕过去。生日那天被忽悠到公园，在亭子里意外收到一堆生日礼物。</p>
</blockquote>
<p>往前一年，他得意地晒出“挖夫人送给挖煤君的生日礼物”，那是一本手工相册，贴了他的摄影作品。相册背部依稀写着“By Vivian  With love”。</p>
<p><img src="http://ww1.sinaimg.cn/large/68b02e3bgy1g0wya6scj1j20u00u0wkv.jpg" alt></p>
<p>再往前一年，是他们相识的第三年，大概正是那时，婚姻、蜜月、搬家，和乐融融。</p>
<p>其它时候，其它家人，没有踪迹可寻。他全部的世界似乎都在几大网络平台中，豆瓣、微博、博客园、知乎，身份始终是网红、科普达人、技术达人、撰稿人和文青。</p>
<p>他的豆瓣签名解释了自己的身份：</p>
<blockquote>
<p>Vamei 是赤道附近一个台风的名字。按照气象规律，台风不常出现在赤道。所以，Vamei 是一个离群的风，无所顾忌地生长，不着边际地游荡。</p>
</blockquote>
<p>抑郁症的倾向深深地隐藏在其中，你甚至可能怀疑，这样一个高智商的、自由的、成功的、热爱生活的人，绝对不会做出那种事来。</p>
<p>可是，越是聪明而理智的人，越是善于藏住自己的阴郁，所以，即使是他的深夜自白中，你也看不出文字的密码：</p>
<blockquote>
<p>我也提笔写文，作一些历史与自然的文章，用一知半解和胡思乱想编织成一个自己的精神世界。然而骗得了他人，却开解不了自己：那些文章，只不过是为了安放无处可去的自己。</p>
</blockquote>
<p>那些试图并且成功杀死了他的东西，究竟是什么呢？我仍不得而知。</p>
<p>继续读那篇《没有杀死我的》。他为什么会关心创伤心理学呢？</p>
<p>他在说创伤是一种财富，说创伤是一个成长的机会，说要不断体验创伤造成的痛苦，来达到自我的实现，这个时候，他说的是自我疗伤的经验，还是仅仅在作一份科普呢？</p>
<p><img src="http://ww1.sinaimg.cn/large/68b02e3bgy1g0wy7q0wnxj20qo0qo75q.jpg" alt></p>
<p>没有杀死我的让我更强大，可是，我变强大，那杀人犯也在变强大啊。那想要杀我的东西，并不是一把痛快的刀，而是一把吱呀吱呀的锯子，磨啊磨，等你麻木了的时候，时间就站到了死神的一边。</p>
<p>Vamei 啊，Vamei 啊，你要指出我的错谬么？</p>
<p>愿在天国，仍有撰稿创作的平台，有代码和猪。</p>
<p>愿在天国，没有抑郁症。</p>
<p><strong>相关文章：</strong> </p>
<p>一席演讲：<a href="https://mp.weixin.qq.com/s/usQ3vBg0EqAiHiysJ5ZRjQ" target="_blank" rel="noopener">https://mp.weixin.qq.com/s/usQ3vBg0EqAiHiysJ5ZRjQ</a></p>
<p>没有杀死我的：<a href="https://www.cnblogs.com/vamei/archive/2013/01/15/2861928.html" target="_blank" rel="noopener">https://www.cnblogs.com/vamei/archive/2013/01/15/2861928.html</a></p>
<p>朋友纪念1：<a href="https://mp.weixin.qq.com/s/BsP8pCtuIjD7mOPQThlWzg" target="_blank" rel="noopener">https://mp.weixin.qq.com/s/BsP8pCtuIjD7mOPQThlWzg</a></p>
<p>朋友纪念2：<a href="https://mp.weixin.qq.com/s/_S8P0uxU_jT81lNfJzRztA" target="_blank" rel="noopener">https://mp.weixin.qq.com/s/_S8P0uxU_jT81lNfJzRztA</a></p>
<p>技术圈纪念1：<a href="https://mp.weixin.qq.com/s/mKqrqt0gFfpifEnTzccYbQ" target="_blank" rel="noopener">https://mp.weixin.qq.com/s/mKqrqt0gFfpifEnTzccYbQ</a></p>
<p>技术圈纪念2：<a href="https://mp.weixin.qq.com/s/EOhJXsXO8tgibZ9PDZXLfg" target="_blank" rel="noopener">https://mp.weixin.qq.com/s/EOhJXsXO8tgibZ9PDZXLfg</a></p>
<p><img src="http://ww1.sinaimg.cn/large/68b02e3bgy1g0wy5wiwu6j20u00u0n0r.jpg" alt></p>
<p>PS：除驯猪图，其它照片皆 Vamei 所摄，取自豆瓣</p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://chinesehuazhou.github.io/2019/05/03/四个月技术写作，我写了些什么？/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="John Doe">
      <meta itemprop="description" content>
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="豌豆花下猫">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2019/05/03/四个月技术写作，我写了些什么？/" itemprop="url">未命名</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2019-05-03T21:21:22+08:00">
                2019-05-03
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="四个月技术写作，我写了些什么？"><a href="#四个月技术写作，我写了些什么？" class="headerlink" title="四个月技术写作，我写了些什么？"></a>四个月技术写作，我写了些什么？</h1><p>从去年国庆节开始，我连续更新了 4 个月公众号，累计发布原创文章 40 篇。</p>
<p>按照大多数个人订阅号的优良传统，号主应该在跨年的前后作年终总结。然而，一来我反应比较迟钝，没跟上节奏，二来当时我正在写比较重要的系列，没时间分心，所以还是慢了半拍。</p>
<p>现在，创作出现了空档期，而身体也出现一种魔幻性的跨移——从几千里外的城市回到分别了几百天的农村。这仿佛就在营造一种仪式感，逼使我要把这未完成的任务做个了结。</p>
<p>因此，现在我就来梳理梳理写出来的东西，说说我的想法吧。</p>
<h2 id="1、Python猫的故事"><a href="#1、Python猫的故事" class="headerlink" title="1、Python猫的故事"></a>1、Python猫的故事</h2><p>这是我的主打系列，故事的主角是一只来自外太星（喵星）的猫。它外貌长什么样，我还没想好，你可以叠加所有猫的形象上去，这就是它的样子。</p>
<p>然而，它绝不是一种固定形态的物种。编程语言（Python为主）、人类文化（文学+哲学）、人工智能、前沿科学（生物+量子物理）和幻想相交合，这些东西都会是我的灵感，也会是塑造这只猫的原力。</p>
<p>我们认识周遭世界的过程是一种逐步扩大的过程，从点到线，到理得清的网，再到真正的网。一只作为讲述者的猫，在思考，在探知并试图融入陌生的星球的时候，会发生些什么认知层面上的结果呢？</p>
<p>我有很多朦胧的念头。想要完全落实它们，简直不可能。有些东西就是说不清。</p>
<p>不过，有了开端，有了大致的方向，就总是有了提起“笔”写下去的动机。</p>
<p><a href="https://mp.weixin.qq.com/s/ch8JkAgcgi2o4HtGAUfZVg" target="_blank" rel="noopener">有了Python，我能叫出所有猫的名字</a></p>
<p><a href="https://mp.weixin.qq.com/s/YQbk0smMTCexsi3Ytd2AzA" target="_blank" rel="noopener">Python对象的身份迷思：从全体公民到万物皆数</a></p>
<p><a href="https://mp.weixin.qq.com/s/q0QvAqXcZzURH3aZ5gZm8A" target="_blank" rel="noopener">Python对象的空间边界：独善其身与开放包容</a></p>
<h2 id="2、Python进阶之路"><a href="#2、Python进阶之路" class="headerlink" title="2、Python进阶之路"></a>2、Python进阶之路</h2><p>我接触 Python 的时间并不长，在工作中用到它的时间就更短了。</p>
<p>因为清楚地意识到自己的基础并不扎实，所以，几个月以来，我花了不少时间系统性地学习了一些内容。</p>
<p>写作前，搜集资料，查漏补缺；写作中，发散思考，融会贯通；发布后，聆听反馈，修正错误。</p>
<p>时间过得真快，现在能拿得出手的也就仅仅是字符串系列、切片系列和迭代器系列了。我计划继续花些时间，把重要的知识梳理一遍。</p>
<p>通过这个系列的写作，我想驱动自己走出一条 Python 进阶之路。然后以它为基础，再进行其它领域（爬虫、数据分析、深度学习、？）的转向。</p>
<p>在准备生成器系列的时候，我一时起了翻译 PEP 的念头，就开启了翻译 PEP 的系列。现在试水了两篇生成器相关的，年后还会翻译一篇。关于翻译，我有一些想法，今后再细说。</p>
<p>这个系列的一些内容，其实是在给 Python 猫系列打基础做铺垫。今后，我会避免两个系列的内容重叠，也不让它们失衡，因此会想办法给 Python猫 系列留下足够的写作余地。</p>
<p><a href="https://mp.weixin.qq.com/s/OKf7N3xxrS0tJ_K8Srw-jA" target="_blank" rel="noopener">超强汇总：学习Python列表，只需这篇文章就够了</a></p>
<p><a href="https://mp.weixin.qq.com/s/hR2Z_duLXnN0fQ3khDPiPQ" target="_blank" rel="noopener">学习Python操作JSON，网络数据交换不用愁</a></p>
<p><a href="https://mp.weixin.qq.com/s/Md07VoaULda7qnMO4ob7Ww" target="_blank" rel="noopener">给Python学习者的文件读写指南（含基础与进阶，建议收藏）</a></p>
<p><a href="https://mp.weixin.qq.com/s/2zGUfwIYY4EVJ0NNyJkNRQ" target="_blank" rel="noopener">再谈文件读写：判断文件的几种方法及其优劣对比</a></p>
<p><a href="https://mp.weixin.qq.com/s/vCs6QvJU2J6L0rIWDKQPUQ" target="_blank" rel="noopener">Python中的“特权种族”是什么？</a></p>
<p><a href="https://mp.weixin.qq.com/s/Whrd6NiD4Y2Z-YSCy4XJ1w" target="_blank" rel="noopener">详解Python拼接字符串的七种方式</a></p>
<p><a href="https://mp.weixin.qq.com/s/z-gSW6XJrAvUE5rS5XrAig" target="_blank" rel="noopener">你真的知道Python的字符串是什么吗？</a></p>
<p><a href="https://mp.weixin.qq.com/s/M4_38VHlQwp-CDRczh2NIA" target="_blank" rel="noopener">你真的知道Python的字符串怎么用吗？</a></p>
<p><a href="https://mp.weixin.qq.com/s/PsY8Iec1EeGDKKnTNU5CNw" target="_blank" rel="noopener">Python是否支持复制字符串呢？</a></p>
<p><a href="https://mp.weixin.qq.com/s/M2uHVqaHe_nyO5jT60V_6Q" target="_blank" rel="noopener">join()方法的神奇用处与Intern机制的软肋</a></p>
<p><a href="https://mp.weixin.qq.com/s/fwZnvcQ_u-fYLFeQaYkJLw" target="_blank" rel="noopener">Python进阶：切片的误区与高级用法</a></p>
<p><a href="https://mp.weixin.qq.com/s/DIhwoJE3o0kKw3kzZKysag" target="_blank" rel="noopener">Python进阶：迭代器与迭代器切片</a></p>
<p><a href="https://mp.weixin.qq.com/s/IRAjR-KHZBPEEkdiofseGQ" target="_blank" rel="noopener">Python进阶：全面解读高级特性之切片！</a></p>
<p><a href="https://mp.weixin.qq.com/s/7MbRCn37fIIN42rLm6ho3g" target="_blank" rel="noopener">Python进阶：设计模式之迭代器模式</a></p>
<p><a href="https://mp.weixin.qq.com/s/1fZs_yXIUhjzN0mQyujXhQ" target="_blank" rel="noopener">为什么range不是迭代器？range到底是什么类型？</a></p>
<p><a href="https://mp.weixin.qq.com/s/vjQLlmH5QV-zAre7tVCxSA" target="_blank" rel="noopener">[译] PEP 255–简单的生成器</a></p>
<p><a href="https://mp.weixin.qq.com/s/M79svUpskZQz15SxEfIWbQ" target="_blank" rel="noopener">[译]PEP 342–增强型生成器：协程</a></p>
<h2 id="3、荐书系列"><a href="#3、荐书系列" class="headerlink" title="3、荐书系列"></a>3、荐书系列</h2><p>关于荐书系列，我是受到了经常阅读的一些电影公众号的启发。</p>
<p>如果有一部好电影，大家就会花很长篇幅去推介它，去评论它，去宣传它。对于一些非技术类的书籍，也很可能有此待遇。</p>
<p>可是，我们却不怎么见到技术类书籍是这样的吧？除去出版社、作者和利益相关机构，你几乎看不到有人为一本技术书籍写书评（写笔记、画思维导图的倒是挺多）。</p>
<p>于是，我决定来尝试一下。有几篇，我特意提到了豆瓣评分和评论，现在看来模仿的痕迹太重，这类玩意对技术类书籍来说，真不合适。纯探索阶段，希望今后能拿出更好的作品。</p>
<p>这个系列，主要还有一个考虑：促使我自己去阅读，逼着自己学会总结归纳，多产生一些积累。</p>
<ol>
<li>《<a href="https://mp.weixin.qq.com/s/JnoYojDsNHYkpibSfF3hOg" target="_blank" rel="noopener">编写高质量代码改善 Python 程序的 91 个建议</a>》</li>
<li>《<a href="https://mp.weixin.qq.com/s/9RonAqwCXo_lganYvLHgVw" target="_blank" rel="noopener">Python最佳实践指南</a>》</li>
<li>《<a href="https://mp.weixin.qq.com/s/6swAZA7baF26BlrKV7zBFg" target="_blank" rel="noopener">黑客与画家</a>》</li>
<li>《<a href="https://mp.weixin.qq.com/s/RcvYm7Ro_nnMx0ZVrJmtyA" target="_blank" rel="noopener">Python源码剖析</a>》</li>
<li>《<a href="https://mp.weixin.qq.com/s/UxPxSJRHk0R6ffhpl8aSpw" target="_blank" rel="noopener">Python高性能编程</a> 》</li>
</ol>
<h2 id="4、杂七杂八"><a href="#4、杂七杂八" class="headerlink" title="4、杂七杂八"></a>4、杂七杂八</h2><p>这部分内容也是跟技术息息相关的，例如 Python社区动态、技术写作、编程思想、技术翻译等等。</p>
<p>其中，关于社区治理模式投票的几篇文章，我最初以为是个热点，但后来意识到，真的没有多少人关心。（我该怀疑自己的关注点呢，还是怀疑别人？）</p>
<p>值得庆幸的是，有篇文章被两位圈内大佬转载了！我乐了好久。这里就不提名字了，总之他们是我初学 Python 时就很佩服的人，因为看了他们的一些文章，我才动了写技术文章的念头。</p>
<p> 关于技术写作和翻译，我初见门道，今后还会多作总结分享。</p>
<p><a href="https://mp.weixin.qq.com/s/2l_erf55IMvT4Tz0AGWCUQ" target="_blank" rel="noopener">来自Kenneth Reitz大神的建议：避免不必要的面向对象编程</a></p>
<p><a href="https://mp.weixin.qq.com/s/oRoBxZ2-IyuPOf_MWyKZyw" target="_blank" rel="noopener">学习Python，怎能不懂点PEP呢？</a></p>
<p><a href="https://mp.weixin.qq.com/s/855ur2uCI1Z1-qpuLGKp0Q" target="_blank" rel="noopener">再聊聊Python中文社区的翻译</a></p>
<p><a href="https://mp.weixin.qq.com/s/vyx61e9GiiTnmaVzTYOcmw" target="_blank" rel="noopener">Python之父退位后，最高决策权花落谁家？</a></p>
<p><a href="https://mp.weixin.qq.com/s/gl8grRlvZ9ylWRdXTWUXow" target="_blank" rel="noopener">这件正在发生的事，关乎所有的Python开发者……</a></p>
<p><a href="https://mp.weixin.qq.com/s/aLkfOoqQubjEIhF1YrLgeg" target="_blank" rel="noopener">最新进展|关于Python治理模式的投票</a></p>
<p><a href="https://mp.weixin.qq.com/s/c7Jz0L8YBoX0Dfb5cZz9sg" target="_blank" rel="noopener">Python决策权的投票结果诞生了，“指导委员会”模式拔得头筹</a></p>
<p><a href="https://mp.weixin.qq.com/s/cCWfbHeptEUKtI19GIxF8A" target="_blank" rel="noopener">聊聊技术写作的个人体会</a></p>
<p><a href="https://mp.weixin.qq.com/s/jdS_hkeDxwroRU3k6or_fg" target="_blank" rel="noopener">大名鼎鼎的Requests库用了什么编码风格？</a></p>
<h2 id="5、写在最后"><a href="#5、写在最后" class="headerlink" title="5、写在最后"></a>5、写在最后</h2><p>我承认自己是一个不擅运营的人，虽然为了提升公众号的订阅数与阅读数，也做过一些运营的尝试，但是，跟圈内的很多号主相比，差得可不止一丝半点。</p>
<p>四个月以来，我结识了很多技术写作的号主，他们有些人创号不久，但不仅技术扎实，而且抓选题、抓热点和写作风格都极其出色，很快就成为了“当红炸子鸡”；还有的大佬，持续耕耘了几年，坐拥数十万粉丝，立品牌、出书、出课程、开知识付费、开公司，替技术人走出了一条名利双收的榜样之路。</p>
<p>他们令我羡慕。他们皆有值得我学习取经的优点。不过我也知道，坚持自己的原则、发展自己的特色更为重要。做人也好，写公众号也好，循着自己的本心与节奏，才不至于走歪了路。</p>
<p>所以，在以上几个系列的写作方向上，我仍会继续坚持，沉下心来学习，思考和分享。这个阶段性的小结，既是一个交代，也是新的开端。</p>
<p>-—————-</p>
<p>本文原创并首发于微信公众号【Python猫】，后台回复“爱学习”，免费获得20+本精选电子书。</p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://chinesehuazhou.github.io/2019/05/03/介绍几款 Python 静态类型检查器/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="John Doe">
      <meta itemprop="description" content>
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="豌豆花下猫">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2019/05/03/介绍几款 Python 静态类型检查器/" itemprop="url">未命名</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2019-05-03T21:21:22+08:00">
                2019-05-03
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="介绍几款-Python-类型检查工具"><a href="#介绍几款-Python-类型检查工具" class="headerlink" title="介绍几款 Python 类型检查工具"></a>介绍几款 Python 类型检查工具</h1><p>近日，微软在 Github 上开源了一个 Python 静态类型检查工具：<code>pyright</code> ，引起了社区内的多方关注。</p>
<p>微软在开源项目上的参与力度是越来越大了，不说收购 Github 这种大的战略野心，只说它家开源的 VS Code 编辑器，在猿界已经割粉无数，连我们 Python 圈的红人 Kenneth Reitz （多个开源项目的作者，包括 requests、requests-html、responder等）都对它赞不绝口。</p>
<p>如今开源的 Pyright ，口碑还不错，那我们就来看看它有啥本事，顺便再介绍其它几款类型检查工具。</p>
<p>众所周知，Python 是一门动态类型语言，在运行期才知道变量的实际类型。这本就是动态语言的特色，然而在团队合作或大型项目上，维护的代价也不可避免，俗话说的是：“<strong>动态一时爽，重构火葬场</strong> ”。</p>
<p>早在 2006 年的 PEP-3107，Python 就推出了函数注解的功能，最终落在 3.0 版本实现。而到了 3.5 版本，Python 继续引入了静态类型检查的语法（即 PEP-484，type hints）。2014 年的 PEP-483 更是以《The Theory of Type Hints》为题，做出了理论上的归纳。后来，又陆续提出了 PEP-526、PEP-544，类型检查的规范逐渐丰富。</p>
<p>类型检查的好处是及早检查，提前发现类型的错误，增强代码的一致性与可维护性。（还有防止脱发，喵）</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"># 不加检查</span><br><span class="line">def greeting(name):</span><br><span class="line">    return &apos;Hello &apos; + name</span><br><span class="line"></span><br><span class="line"># 添加检查</span><br><span class="line">def greeting(name: str) -&gt; str:</span><br><span class="line">    return &apos;Hello &apos; + name</span><br></pre></td></tr></table></figure>
<p>如上例所示，增加检查后，可以在编译期就判断入参和返回值是否是字符串类型。</p>
<p>在微软推出 pyright 之前，主流的静态检查工具有三款：官方的<code>mypy</code> 、Google 出的<code>pytype</code> 、Facebook 出的<code>pyre-check</code> 。三足鼎立的局面要被打破了。</p>
<p><img src="http://ww1.sinaimg.cn/large/68b02e3bgy1g1gmiohkzij20fp06imxk.jpg" alt></p>
<p>pyright 的文档宣称它有如下特点：</p>
<ul>
<li>速度快。相较于 mypy 及其它用 Python 写的检查工具，它的速度是 5 倍甚至更多。</li>
<li>不依赖 Python 环境。它用 TypeScript 写成，运行于 node 上，不依赖 Python 环境或第三方包。</li>
<li>可配置性强。支持自由地配置，支持指定不同的运行环境（PYTHONPATH 设置、Python 版本、平台目标）。</li>
<li>检查项齐全。支持类型检查及其它语法项的检查（如 PEP-484、PEP-526、PEP-544），以及函数返回值、类变量、全局变量的检查，甚至可以检查条件循环语句</li>
<li>命令行工具。它包含两个 VS Code 插件：一个命令行工具和一个语言服务器协议（Language Server Protocol）</li>
<li>内置 Stubs 。使用的是 <code>Typeshed</code> 的副本。（注：使用静态的 pyi 文件，检查内置模块、标准库和三方件 ）</li>
<li>语言服务特性。悬停提示信息、符号定义的跳转、实时的编辑反馈</li>
</ul>
<p>就此而言，不可谓不强大。事实上，pyright 是“站在了巨人的肩膀上”，它的各项功能似乎都继承自其它几位前辈。</p>
<p>接着看官方的 mypy ，它由“Python 之父” Guido van Rossum 亲自参与开发，是最主流的选择，推出得早，用户基数大，文档与社区经验也最丰富。</p>
<p>在集成 IDE 方面，所有主流的编辑器都支持：PyCharm、Vim、Emacs、Sublime Text、VS Code、Atom……在业界经验上，Instagram 和 Dropbox 的项目从 py2 迁移到 py3 ，就是用的它来做保障。</p>
<p>接着看谷歌的 pytype ，据文档描述，它可以：</p>
<ul>
<li>标记常见错误，如拼写错误、函数调用错误</li>
<li>加强自定义的类型注解</li>
<li>支持对 pyi 文件生成类型注解</li>
</ul>
<p>查看文档，我发现它有个功能还挺人性化的，即“<strong>错误降噪</strong> ”，对于那些不必修改的错误，可以添加注释，来消除类型检查。</p>
<p>此外，还有一个考虑也不错，为了写类型检查，模块中可能会额外引入其它的模块，对于后者，pytype 有办法隐藏它，只在做类型检查时才加载。</p>
<p>最后，要介绍的是脸书的 pyre-check，它是去年开源的，也曾收获一片好评（说不定正是因为它，微软才上马了 pyright 项目也说不定）。</p>
<p>基本的功能点大同小异，不过它也是有亮点的。pyre-check 可集成<code>Watchman</code> 模块，该“观察者”会监听代码文件，跟踪所做的修改。微软的 pyright 有个 watch 模式，应该是吸收了这点，而且更加好用（因为不需要额外安装 Watchman 和其它依赖）。</p>
<p>pyre-check 还有个亮点，它有个<code>query</code> 参数，可以对源码做局部区域性的检查，例如查询某行中一个表达式的类型、查询一个类的全部方法并返回成列表，等等，这样可以避免做全面的检查。</p>
<p>4 种类型检查工具介绍完毕，下面是一份概要对比：</p>
<p><img src="http://ww1.sinaimg.cn/large/68b02e3bgy1g1gmi46ke4j20x205at98.jpg" alt></p>
<p>至于它们的性能如何，是否真如 pyright 所说，它的速度是其它几个的 5 倍呢？感兴趣的同学们可以去试试。有什么使用体会，欢迎留言与我交流。</p>
<p><strong>项目地址：</strong> </p>
<p><a href="https://github.com/python/mypy" target="_blank" rel="noopener">https://github.com/python/mypy</a></p>
<p><a href="https://github.com/Microsoft/pyright" target="_blank" rel="noopener">https://github.com/Microsoft/pyright</a></p>
<p><a href="https://github.com/google/pytype" target="_blank" rel="noopener">https://github.com/google/pytype</a></p>
<p><a href="https://github.com/facebook/pyre-check" target="_blank" rel="noopener">https://github.com/facebook/pyre-check</a></p>
<p><img src="http://ww1.sinaimg.cn/large/68b02e3bgy1g08dfkg8sdj2076076t96.jpg" alt></p>
<p>公众号【<strong>Python猫</strong>】， 专注Python技术、数据科学和深度学习，力图创造一个有趣又有用的学习分享平台。本号连载优质的系列文章，有喵星哲学猫系列、Python进阶系列、好书推荐系列、优质英文推荐与翻译等等，欢迎关注哦。PS：后台回复“<strong>爱学习</strong>”，免费获得一份学习大礼包。</p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://chinesehuazhou.github.io/2019/05/03/辨析 Python 神奇的 eval() 与 exec()/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="John Doe">
      <meta itemprop="description" content>
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="豌豆花下猫">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2019/05/03/辨析 Python 神奇的 eval() 与 exec()/" itemprop="url">未命名</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2019-05-03T21:21:22+08:00">
                2019-05-03
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="深度辨析-Python-的-eval-与-exec"><a href="#深度辨析-Python-的-eval-与-exec" class="headerlink" title="深度辨析 Python 的 eval() 与 exec()"></a>深度辨析 Python 的 eval() 与 exec()</h1><p>Python 提供了很多内置的工具函数（Built-in Functions），在最新的 Python 3 官方文档中，它列出了 69 个。</p>
<p>大部分函数是我们经常使用的，例如 print()、open() 与 dir()，而有一些函数虽然不常用，但它们在某些场景下，却能发挥出不一般的作用。内置函数们能够被“提拔”出来，这就意味着它们皆有独到之处，有用武之地。</p>
<p>因此，掌握内置函数的用法，就成了我们应该点亮的技能。</p>
<p>在《<a href="https://mp.weixin.qq.com/s/4eWQmJ15QZabNViePCDmNw" target="_blank" rel="noopener">Python进阶：如何将字符串常量转为变量？</a>》这篇文章中，我提到过 eval() 和 exec() ，但对它们并不太了解。为了弥补这方面知识，我就重新学习了下。这篇文章是一份超级详细的学习记录，系统、全面而深入地辨析了这两大函数。</p>
<h2 id="1、eval-的基本用法"><a href="#1、eval-的基本用法" class="headerlink" title="1、eval 的基本用法"></a>1、eval 的基本用法</h2><p>语法：eval(<em>expression</em>, <em>globals=None</em>, <em>locals=None</em>)</p>
<p>它有三个参数，其中 expression 是一个字符串类型的表达式或代码对象，用于做运算；globals 与 locals  是可选参数，默认值是 None。</p>
<p>具体而言，expression 只能是单个表达式，不支持复杂的代码逻辑，例如赋值操作、循环语句等等。（PS：单个表达式并不意味着“简单无害”，参见下文第 4 节）</p>
<p>globals 用于指定运行时的全局命名空间，类型是字典，缺省时使用的是当前模块的内置命名空间。locals 指定运行时的局部命名空间，类型是字典，缺省时使用 globals 的值。两者都缺省时，则遵循 eval 函数执行时的作用域。值得注意的是，这两者不代表真正的命名空间，只在运算时起作用，运算后则销毁。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">x = 10</span><br><span class="line"></span><br><span class="line">def func():</span><br><span class="line">    y = 20</span><br><span class="line">    a = eval(&apos;x + y&apos;)</span><br><span class="line">    print(&apos;a: &apos;, a)</span><br><span class="line">    b = eval(&apos;x + y&apos;, &#123;&apos;x&apos;: 1, &apos;y&apos;: 2&#125;)</span><br><span class="line">    print(&apos;x: &apos; + str(x) + &apos; y: &apos; + str(y))</span><br><span class="line">    print(&apos;b: &apos;, b)</span><br><span class="line">    c = eval(&apos;x + y&apos;, &#123;&apos;x&apos;: 1, &apos;y&apos;: 2&#125;, &#123;&apos;y&apos;: 3, &apos;z&apos;: 4&#125;)</span><br><span class="line">    print(&apos;x: &apos; + str(x) + &apos; y: &apos; + str(y))</span><br><span class="line">    print(&apos;c: &apos;, c)</span><br><span class="line"></span><br><span class="line">func()</span><br></pre></td></tr></table></figure>
<p>输出结果：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">a:  30</span><br><span class="line">x: 10 y: 20</span><br><span class="line">b:  3</span><br><span class="line">x: 10 y: 20</span><br><span class="line">c:  4</span><br></pre></td></tr></table></figure>
<p>由此可见，当指定了命名空间的时候，变量会在对应命名空间中查找。而且，它们的值不会覆盖实际命名空间中的值。</p>
<h2 id="2、exec-的基本用法"><a href="#2、exec-的基本用法" class="headerlink" title="2、exec 的基本用法"></a>2、exec 的基本用法</h2><p>语法：exec(<em>object</em>[, <em>globals</em>[, <em>locals</em>]])</p>
<p>在 Python2 中 exec 是个语句，而 Python3 将其改造成一个函数，就像 print 一样。exec() 与 eval() 高度相似，三个参数的意义和作用相近。</p>
<p>主要的区别是，exec() 的第一个参数不是表达式，而是代码块，这意味着两点：一是它不能做表达式求值并返回出去，二是它可以执行复杂的代码逻辑，相对而言功能更加强大，例如，当代码块中赋值了新的变量时，该变量<strong>可能</strong> 在函数外的命名空间中存活下来。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; x = 1</span><br><span class="line">&gt;&gt;&gt; y = exec(&apos;x = 1 + 1&apos;)</span><br><span class="line">&gt;&gt;&gt; print(x)</span><br><span class="line">&gt;&gt;&gt; print(y)</span><br><span class="line">2</span><br><span class="line">None</span><br></pre></td></tr></table></figure>
<p>可以看出，exec() 内外的命名空间是相通的，变量由此传递出去，而不像 eval() 函数，需要一个变量来接收函数的执行结果。</p>
<h2 id="3、一些细节辨析"><a href="#3、一些细节辨析" class="headerlink" title="3、一些细节辨析"></a>3、一些细节辨析</h2><p>两个函数都很强大，它们将字符串内容当做有效的代码执行。这是一种<strong>字符串驱动的事件</strong> ，意义重大。然而，在实际使用过程中，存在很多微小的细节，此处就列出我所知道的几点吧。</p>
<p>常见用途：将字符串转成相应的对象，例如 string 转成 list ，string 转成 dict，string 转 tuple 等等。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; a = &quot;[[1,2], [3,4], [5,6], [7,8], [9,0]]&quot;</span><br><span class="line">&gt;&gt;&gt; print(eval(a))</span><br><span class="line">[[1, 2], [3, 4], [5, 6], [7, 8], [9, 0]]</span><br><span class="line">&gt;&gt;&gt; a = &quot;&#123;&apos;name&apos;: &apos;Python猫&apos;, &apos;age&apos;: 18&#125;&quot;</span><br><span class="line">&gt;&gt;&gt; print(eval(a))</span><br><span class="line">&#123;&apos;name&apos;: &apos;Python猫&apos;, &apos;age&apos;: 18&#125;</span><br><span class="line"></span><br><span class="line"># 与 eval 略有不同</span><br><span class="line">&gt;&gt;&gt; a = &quot;my_dict = &#123;&apos;name&apos;: &apos;Python猫&apos;, &apos;age&apos;: 18&#125;&quot;</span><br><span class="line">&gt;&gt;&gt; exec(a)</span><br><span class="line">&gt;&gt;&gt; print(my_dict)</span><br><span class="line">&#123;&apos;name&apos;: &apos;Python猫&apos;, &apos;age&apos;: 18&#125;</span><br></pre></td></tr></table></figure>
<p>eval() 函数的返回值是其 expression 的执行结果，在某些情况下，它会是 None，例如当该表达式是 print() 语句，或者是列表的 append() 操作时，这类操作的结果是 None，因此 eval() 的返回值也会是 None。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; result = eval(&apos;[].append(2)&apos;)</span><br><span class="line">&gt;&gt;&gt; print(result)</span><br><span class="line">None</span><br></pre></td></tr></table></figure>
<p>exec() 函数的返回值只会是 None，与执行语句的结果无关，所以，将 exec() 函数赋值出去，就没有任何必要。所执行的语句中，如果包含 return 或 yield ，它们产生的值也无法在 exec 函数的外部起作用。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; result = exec(&apos;1 + 1&apos;)</span><br><span class="line">&gt;&gt;&gt; print(result)</span><br><span class="line">None</span><br></pre></td></tr></table></figure>
<p>两个函数中的 globals 和 locals 参数，起到的是白名单的作用，通过限定命名空间的范围，防止作用域内的数据被滥用。</p>
<p>conpile() 函数编译后的 code 对象，可作为 eval 和 exec 的第一个参数。compile() 也是个神奇的函数，我翻译的上一篇文章《<a href="https://mp.weixin.qq.com/s/o-HuE3VxgHedfe8X5fUrMA" target="_blank" rel="noopener">Python骚操作：动态定义函数</a>》就演示了一个动态定义函数的操作。</p>
<p>吊诡的局部命名空间：前面讲到了 exec() 函数内的变量是可以改变原有命名空间的，然而也有例外。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">def foo():</span><br><span class="line">    exec(&apos;y = 1 + 1\nprint(y)&apos;)</span><br><span class="line">    print(locals())</span><br><span class="line">    print(y)</span><br><span class="line"></span><br><span class="line">foo()</span><br></pre></td></tr></table></figure>
<p>按照前面的理解，预期的结果是局部变量中会存入变量 y，因此两次的打印结果都会是 2，然而实际上的结果却是：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">2</span><br><span class="line">&#123;&apos;y&apos;: 2&#125;</span><br><span class="line">Traceback (most recent call last):</span><br><span class="line">...(略去部分报错信息)</span><br><span class="line">    print(y)</span><br><span class="line">NameError: name &apos;y&apos; is not defined</span><br></pre></td></tr></table></figure>
<p>明明看到了局部命名空间中有变量 y，为何会报错说它未定义呢？</p>
<p>原因与 Python 的编译器有关，对于以上代码，编译器会先将 foo 函数解析成一个 ast（抽象语法树），然后将所有变量节点存入栈中，此时 exec() 的参数只是一个字符串，整个就是常量，并没有作为代码执行，因此 y 还不存在。直到解析第二个 print() 时，此时第一次出现变量 y ，但因为没有完整的定义，所以 y 不会被存入局部命名空间。</p>
<p>在运行期，exec() 函数动态地创建了局部变量 y ，然而由于 Python 的实现机制是“<strong>运行期的局部命名空间不可改变</strong> ”，也就是说这时的 y 始终无法成为局部命名空间的一员，当执行 print() 时也就报错了。</p>
<p>至于为什么 locals() 取出的结果有 y，为什么它不能代表真正的局部命名空间？为什么局部命名空间无法被动态修改？可以查看我之前分享的《<a href="https://mp.weixin.qq.com/s/f9BBe2W1X1p7NcHg665I4A" target="_blank" rel="noopener">Python 动态赋值的陷阱</a>》，另外，官方的 bug 网站中也有对此问题的讨论，查看地址：<a href="https://bugs.python.org/issue4831" target="_blank" rel="noopener">https://bugs.python.org/issue4831</a></p>
<p>若想把 exec() 执行后的 y 取出来的话，可以这样：<code>z = locals()[&#39;y&#39;]</code> ，然而如果不小心写成了下面的代码，则会报错：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">def foo():</span><br><span class="line">    exec(&apos;y = 1 + 1&apos;)</span><br><span class="line">    y = locals()[&apos;y&apos;]</span><br><span class="line">    print(y)</span><br><span class="line">    </span><br><span class="line">foo()</span><br><span class="line"></span><br><span class="line">#报错：KeyError: &apos;y&apos;</span><br><span class="line">#把变量 y 改为其它变量则不会报错</span><br></pre></td></tr></table></figure>
<p><code>KeyError</code> 指的是在字典中不存在对应的 key 。本例中 y 作了声明，却因为循环引用而无法完成赋值，即 key 值对应的 value 是个无效值，因此读取不到，就报错了。</p>
<p>此例还有 4 个变种，我想用一套自恰的说法来解释它们，但尝试了很久，未果。留个后话吧，等我想明白，再单独写一篇文章。</p>
<h2 id="4、为什么要慎用-eval-？"><a href="#4、为什么要慎用-eval-？" class="headerlink" title="4、为什么要慎用 eval() ？"></a>4、为什么要慎用 eval() ？</h2><p>很多动态的编程语言中都会有 eval() 函数，作用大同小异，但是，无一例外，人们会告诉你说，避免使用它。</p>
<p>为什么要慎用 eval() 呢？主要出于安全考虑，对于不可信的数据源，eval 函数很可能会招来代码注入的问题。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; eval(&quot;__import__(&apos;os&apos;).system(&apos;whoami&apos;)&quot;)</span><br><span class="line">desktop-fa4b888\pythoncat</span><br><span class="line">&gt;&gt;&gt; eval(&quot;__import__(&apos;subprocess&apos;).getoutput(&apos;ls ~&apos;)&quot;)</span><br><span class="line">#结果略，内容是当前路径的文件信息</span><br></pre></td></tr></table></figure>
<p>在以上例子中，我的隐私数据就被暴露了。而更可怕的是，如果将命令改为<code>rm -rf ~</code> ，那当前目录的所有文件都会被删除干净。</p>
<p>针对以上例子，有一个限制的办法，即指定 globals 为 <code>{&#39;__builtins__&#39;: None}</code> 或者 <code>{&#39;__builtins__&#39;: {}}</code> 。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; s = &#123;&apos;__builtins__&apos;: None&#125;</span><br><span class="line">&gt;&gt;&gt; eval(&quot;__import__(&apos;os&apos;).system(&apos;whoami&apos;)&quot;, s)</span><br><span class="line">#报错：TypeError: &apos;NoneType&apos; object is not subscriptable</span><br></pre></td></tr></table></figure>
<p><code>__builtins__</code> 包含了内置命名空间中的名称，在控制台中输入 dir(__builtins__) ，就能发现很多内置函数、异常和其它属性的名称。在默认情况下，eval 函数的 globals 参数会隐式地携带<code>__builtins__</code> ，即使是令 globals 参数为 {} 也如此，所以如果想要禁用它，就得显式地指定它的值。</p>
<p>上例将它映射成 None，就意味着限定了 eval 可用的内置命名空间为 None，从而限制了表达式调用内置模块或属性的能力。</p>
<p>但是，这个办法还不是万无一失的，因为仍有手段可以发起攻击。</p>
<p>某位漏洞挖掘高手在他的博客中分享了一个思路，令人大开眼界。其核心的代码是下面这句，你可以试试执行，看看输出的是什么内容。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; ().__class__.__bases__[0].__subclasses__()</span><br></pre></td></tr></table></figure>
<p>关于这句代码的解释，以及更进一步的利用手段，详见博客。（地址：<a href="https://www.tuicool.com/articles/jeaqe2n）" target="_blank" rel="noopener">https://www.tuicool.com/articles/jeaqe2n）</a></p>
<p>另外还有一篇博客，不仅提到了上例的手段，还提供了一种新的思路：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">#警告：千万不要执行如下代码，后果自负。</span><br><span class="line">&gt;&gt;&gt; eval(&apos;(lambda fc=(lambda n: [c 1=&quot;c&quot; 2=&quot;in&quot; 3=&quot;().__class__.__bases__[0&quot; language=&quot;for&quot;][/c].__subclasses__() if c.__name__ == n][0]):fc(&quot;function&quot;)(fc(&quot;code&quot;)(0,0,0,0,&quot;KABOOM&quot;,(),(),(),&quot;&quot;,&quot;&quot;,0,&quot;&quot;),&#123;&#125;)())()&apos;, &#123;&quot;__builtins__&quot;:None&#125;)</span><br></pre></td></tr></table></figure>
<p>这行代码会导致 Python 直接 crash 掉。具体分析在：<a href="https://segmentfault.com/a/1190000011532358" target="_blank" rel="noopener">https://segmentfault.com/a/1190000011532358</a></p>
<p>除了黑客的手段，简单的内容也能发起攻击。像下例这样的写法， 将在短时间内耗尽服务器的计算资源。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; eval(&quot;2 ** 888888888&quot;, &#123;&quot;__builtins__&quot;:None&#125;, &#123;&#125;)</span><br></pre></td></tr></table></figure>
<p>如上所述，我们直观地展示了 eval() 函数的危害性，然而，即使是 Python 高手们小心谨慎地使用，也不能保证不出错。</p>
<p>在官方的 dumbdbm 模块中，曾经（2014年）发现一个安全漏洞，攻击者通过伪造数据库文件，可以在调用 eval() 时发起攻击。（详情：<a href="https://bugs.python.org/issue22885）" target="_blank" rel="noopener">https://bugs.python.org/issue22885）</a></p>
<p>无独有偶，在上个月（2019.02），有核心开发者针对 Python 3.8 也提出了一个安全问题，提议不在 logging.config 中使用 eval() 函数，目前该问题还是 open 状态。（详情：<a href="https://bugs.python.org/issue36022）" target="_blank" rel="noopener">https://bugs.python.org/issue36022）</a></p>
<p>如此种种，足以说明为什么要慎用 eval() 了。同理可证，exec() 函数也得谨慎使用。</p>
<h2 id="5、安全的替代用法"><a href="#5、安全的替代用法" class="headerlink" title="5、安全的替代用法"></a>5、安全的替代用法</h2><p>既然有种种安全隐患，为什么要创造出这两个内置方法呢？为什么要使用它们呢？</p>
<p>理由很简单，因为 Python 是一门灵活的动态语言。与静态语言不同，动态语言支持动态地产生代码，对于已经部署好的工程，也可以只做很小的局部修改，就实现 bug 修复。</p>
<p>那有什么办法可以相对安全地使用它们呢？</p>
<p>ast 模块的 <code>literal()</code> 是 eval() 的安全替代，与 eval() 不做检查就执行的方式不同，ast.literal() 会先检查表达式内容是否有效合法。它所允许的字面内容如下：</p>
<blockquote>
<p>strings, bytes, numbers, tuples, lists, dicts, sets, booleans, 和 None</p>
</blockquote>
<p>一旦内容非法，则会报错：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">import ast</span><br><span class="line">ast.literal_eval(&quot;__import__(&apos;os&apos;).system(&apos;whoami&apos;)&quot;)</span><br><span class="line"></span><br><span class="line">报错：ValueError: malformed node or string</span><br></pre></td></tr></table></figure>
<p>不过，它也有缺点：AST 编译器的栈深（stack depth）有限，解析的字符串内容太多或太复杂时，可能导致程序崩溃。</p>
<p>至于 exec() ，似乎还没有类似的替代方法，毕竟它本身可支持的内容是更加复杂多样的。</p>
<p>最后是一个建议：搞清楚它们的区别与运行细节（例如前面的局部命名空间内容），谨慎使用，限制可用的命名空间，对数据源作充分校验。</p>
<p><strong>关联阅读：</strong> </p>
<p><a href="https://mp.weixin.qq.com/s/f9BBe2W1X1p7NcHg665I4A" target="_blank" rel="noopener">Python 动态赋值的陷阱</a></p>
<p><a href="https://mp.weixin.qq.com/s/o-HuE3VxgHedfe8X5fUrMA" target="_blank" rel="noopener">Python骚操作：动态定义函数</a></p>
<p><a href="https://mp.weixin.qq.com/s/EsWmCbH3RtL_QpafyMryOw" target="_blank" rel="noopener">Python与家国天下</a></p>
<p><a href="https://mp.weixin.qq.com/s/4eWQmJ15QZabNViePCDmNw" target="_blank" rel="noopener">Python进阶：如何将字符串常量转为变量？</a></p>
<p><a href="https://docs.python.org/3/library/ast.html#ast.literal_eval" target="_blank" rel="noopener">https://docs.python.org/3/library/ast.html#ast.literal_eval</a></p>
<p><img src="http://ww1.sinaimg.cn/large/68b02e3bgy1g08dfkg8sdj2076076t96.jpg" alt></p>
<p>公众号【<strong>Python猫</strong>】， 专注Python技术、数据科学和深度学习，力图创造一个有趣又有用的学习分享平台。本号连载优质的系列文章，有喵星哲学猫系列、Python进阶系列、好书推荐系列、优质英文推荐与翻译等等，欢迎关注哦。PS：后台回复“<strong>爱学习</strong>”，免费获得一份学习大礼包。</p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://chinesehuazhou.github.io/2019/05/03/超强汇总：学习Python列表，只需这篇文章就够了/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="John Doe">
      <meta itemprop="description" content>
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="豌豆花下猫">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2019/05/03/超强汇总：学习Python列表，只需这篇文章就够了/" itemprop="url">未命名</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2019-05-03T21:21:22+08:00">
                2019-05-03
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h2 id="超强汇总：学习Python列表，只需这篇文章就够了"><a href="#超强汇总：学习Python列表，只需这篇文章就够了" class="headerlink" title="超强汇总：学习Python列表，只需这篇文章就够了"></a>超强汇总：学习Python列表，只需这篇文章就够了</h2><hr>
<p>千里之行，始于足下。要练成一双洞悉一切的眼睛，还是得先把基本功扎扎实实地学好。今天，本喵带大家仔细温习一下Python的列表。温故而知新，不亦说乎。</p>
<p>当然，温习的同时也要发散思考，因为有些看似无关紧要的、约定俗成的语言习惯，例如数组索引为何从0开始，其背后可能大有来历。知其然，亦需知其所以然啊喵喵喵~~~</p>
<p>最后，在基础知识之上，更要探索进阶，例如学习生成器表达式，这样既能更扎实地掌握基础，又能融会贯通，获得更全面的认知升级。</p>
<h2 id="Python的列表是怎样滴？"><a href="#Python的列表是怎样滴？" class="headerlink" title="Python的列表是怎样滴？"></a>Python的列表是怎样滴？</h2><p>列表（list）是一种有序的集合，可以随时添加、查找和删除元素。</p>
<p>列表支持加入不同数据类型的元素：数字、字符串、列表、元组等。</p>
<p>列表通过有序的索引可遍历所有的元素，从前往后数，索引是[0,n-1]，从后往前数，索引是[-1, -n]，其中n是列表的长度。</p>
<p>列表可以是不含元素的空列表，也可以包含超级多的元素（在内存大小支持的情况下）。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">list_a = []   <span class="comment"># 空列表，即len(list_a) == 0</span></span><br><span class="line">list_b = [<span class="number">2018</span>, <span class="number">10</span>, <span class="string">'2018-10-1'</span>, [<span class="string">'hi'</span>, <span class="number">1</span>, <span class="number">2</span>], (<span class="number">33</span>, <span class="number">44</span>)]</span><br><span class="line"><span class="comment"># list_b 长度为5，包含2个数字元素、1个字符串元素、1个列表元素和1个元组元素</span></span><br><span class="line">len(list_b) == <span class="number">5</span></span><br><span class="line">list_b[<span class="number">0</span>] == list_b[<span class="number">-5</span>] == <span class="number">2018</span></span><br><span class="line">lits_b[<span class="number">3</span>] == list_b[<span class="number">-2</span>] == [<span class="string">'hi'</span>, <span class="number">1</span>, <span class="number">2</span>] </span><br><span class="line">lits_b[<span class="number">4</span>] == list_b[<span class="number">-1</span>] == (<span class="number">33</span>, <span class="number">44</span>)</span><br></pre></td></tr></table></figure>
<h2 id="Python中怎么操作列表？"><a href="#Python中怎么操作列表？" class="headerlink" title="Python中怎么操作列表？"></a>Python中怎么操作列表？</h2><p><strong>1）创建列表：</strong></p>
<p>用中括号[]包裹元素，元素使用逗号分隔。</p>
<p>用list()方法，转化生成列表。</p>
<p>列表生成式/列表解析式/列表推导式，生成列表。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">list_a = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>]</span><br><span class="line">list_b = list(<span class="string">"abc"</span>) <span class="comment"># list_b == ['a', 'b', 'c']</span></span><br><span class="line">list_c = list((<span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>)) <span class="comment"># list_c == [4, 5, 6]</span></span><br><span class="line">list_d = [i <span class="keyword">for</span> i <span class="keyword">in</span> list_a]  <span class="comment"># list_d == [1, 2, 3]</span></span><br><span class="line">list_e = [i*j <span class="keyword">for</span> i <span class="keyword">in</span> list_a <span class="keyword">for</span> j <span class="keyword">in</span> list_c] <span class="comment"># list_e == [4,5,6,10,12,12,15,18]</span></span><br><span class="line">list_f = [i*j <span class="keyword">for</span> i,j <span class="keyword">in</span> zip(list_a,list_c)] <span class="comment"># list_f == [4, 10, 18]</span></span><br><span class="line">list_g = [i <span class="keyword">for</span> i <span class="keyword">in</span> list_a <span class="keyword">if</span> i%<span class="number">2</span> == <span class="number">0</span>] <span class="comment"># list_g == [2]</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 结合range()函数，range(start, stop[, step])</span></span><br><span class="line">list_h = list(range(<span class="number">3</span>)) <span class="comment"># list_h == [0, 1, 2]</span></span><br><span class="line">list_i = list(range(<span class="number">3</span>,<span class="number">7</span>)) <span class="comment"># list_i == [3, 4, 5, 6]</span></span><br><span class="line">list_j = list(range(<span class="number">3</span>,<span class="number">9</span>,<span class="number">2</span>)) <span class="comment"># list_j == [3, 5, 7]</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 找出100以内的能够被3整除的正整数</span></span><br><span class="line">list_k = list(range(<span class="number">3</span>,<span class="number">100</span>,<span class="number">3</span>)) <span class="comment"># list_k == [3, 6, 9, ..., 96, 99]</span></span><br></pre></td></tr></table></figure>
<p><strong>2）扩充列表：</strong></p>
<p>用append()方法，在列表尾部添加单个新元素。</p>
<p>用insert()方法，在列表中指定位置添加元素。</p>
<p>用 “+” 运算符，将两个列表拼接出一个新列表。</p>
<p>用extend()方法，在一个列表后面拼接进另一个列表。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 以下分别添加2个元素</span></span><br><span class="line">list_a = []</span><br><span class="line">list_a.append(<span class="string">'happy'</span>)  <span class="comment"># list_a == ['happy']</span></span><br><span class="line">list_a.insert(<span class="number">0</span>, <span class="string">'very'</span>) <span class="comment"># list_a == ['very', 'happy']</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 以下两种扩充列表方式</span></span><br><span class="line">list_1 = [<span class="string">'I'</span>, <span class="string">'am'</span>]</span><br><span class="line">list_2 = [<span class="string">'very'</span>, <span class="string">'happy'</span>]</span><br><span class="line">list_3 = list_1 + list_2  <span class="comment"># 新列表 list_3 == ['I', 'am', 'very', 'happy']</span></span><br><span class="line">list_1.extend(list_2)  <span class="comment"># 原列表1扩充，list_1 == ['I', 'am', 'very', 'happy']</span></span><br></pre></td></tr></table></figure>
<p><strong>3）删减列表与销毁列表：</strong></p>
<p>用del list[m] 语句，删除指定索引m处的元素。</p>
<p>用remove()方法，删除指定值的元素（第一个匹配项）。</p>
<p>用pop()方法，取出并删除列表末尾的单个元素。</p>
<p>用pop(m)方法，取出并删除索引值为m的元素。</p>
<p>用clear()方法，清空列表的元素。（杯子还在，水倒空了）</p>
<p>用del list 语句，销毁整个列表。（杯子和水都没有了）</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 以下4种删除列表元素方式</span></span><br><span class="line">list_1 = list_2 = list_3 = list_4 = [<span class="string">'I'</span>, <span class="string">'am'</span>, <span class="string">'very'</span>, <span class="string">'happy'</span>]</span><br><span class="line"><span class="keyword">del</span> list_1[<span class="number">0</span>]  <span class="comment"># list_1 == ['am', 'very', 'happy']</span></span><br><span class="line">list_2.remove(<span class="string">'I'</span>) <span class="comment"># list_2 == ['am', 'very', 'happy']</span></span><br><span class="line">list_3.pop()  <span class="comment"># list_3 == ['I', 'am', 'very']</span></span><br><span class="line">list_4.pop(<span class="number">0</span>)  <span class="comment"># list_4 == ['am', 'very', 'happy']</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 清空与销毁</span></span><br><span class="line">list_a = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>]</span><br><span class="line">list_b = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>]</span><br><span class="line">list_b.clear()   <span class="comment"># list_b == []</span></span><br><span class="line"><span class="keyword">del</span> list_a  <span class="comment"># 没有list_a了，再使用则会报错</span></span><br></pre></td></tr></table></figure>
<p><strong>4）列表切片：</strong></p>
<p>基本含义：<strong>从第i位索引起，向右取到后n位元素为止，按m间隔过滤</strong></p>
<p>基本格式：[i : i+n : m] ；i 是切片的起始索引值，为列表首位时可省略；i+n 是切片的结束位置，为列表末位时可省略；m 可以不提供，默认值是1，不允许为0，当m为负数时，列表翻转。注意：这些值都可以大于列表长度，不会报越界。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">li = [1, 4, 5, 6, 7, 9, 11, 14, 16]</span><br><span class="line"></span><br><span class="line"># 以下写法都可以表示整个列表，其中 X &gt;= len(li)</span><br><span class="line">li[0:X] == li[0:] == li[:X] == li[:] == li[::] == li[-X:X] == li[-X:]</span><br><span class="line"></span><br><span class="line">li[1:5] == [4,5,6,7] # 从1起，取5-1位元素</span><br><span class="line">li[1:5:2] == [4,6] # 从1起，取5-1位元素，按2间隔过滤</span><br><span class="line">li[-1:] == [16] # 取倒数第一个元素</span><br><span class="line">li[-4:-2] == [9, 11] # 从倒数第四起，取-2-(-4)=2位元素</span><br><span class="line">li[:-2] == li[-len(li):-2] == [1,4,5,6,7,9,11] # 从头开始，取-2-(-len(li))=7位元素</span><br><span class="line"></span><br><span class="line"># 注意列表先翻转，再截取</span><br><span class="line">li[::-1] == [16,14,11,9,7,6,5,4,1] # 翻转整个列表</span><br><span class="line">li[::-2] == [16,11,7,5,1] # 翻转整个列表，再按2间隔过滤</span><br><span class="line">li[:-5:-1] == [16,14,11,9] # 翻转整个列表，取-5-(-len(li))=4位元素</span><br><span class="line">li[:-5:-3] == [16,9] # 翻转整个列表，取-5-(-len(li))=4位元素，再按3间隔过滤</span><br><span class="line"></span><br><span class="line">li[::0]  # 报错（ValueError: slice step cannot be zero）</span><br></pre></td></tr></table></figure>
<p><strong>5) 其它操作：</strong></p>
<p>用len()方法，统计全部元素的个数。</p>
<p>用count()方法，统计指定值的元素的个数。</p>
<p>用max()方法，统计元素中的最大值（要求元素类型相同；数字类型直接比较，其它类型比较id）</p>
<p>用min()方法，统计元素中的最小值（要求元素类型相同；数字类型直接比较，其它类型比较id）</p>
<p>用index()方法，查找指定值的元素的索引位置（第一个匹配项）。</p>
<p>用reverse()方法，翻转列表中的元素。</p>
<p>用copy()方法，浅拷贝并生成新的列表。</p>
<p>用deepcopy()方法，深拷贝并生成新的列表。</p>
<p>用sort()方法，在原列表基础上进行排序。</p>
<p>用sorted()方法，将新列表基础上对原列表的元素进行排序。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">list_1 = [<span class="number">2018</span>, <span class="number">10</span>, <span class="string">'2018-10-1'</span>, [<span class="string">'hi'</span>, <span class="number">1</span>, <span class="number">2</span>], (<span class="number">33</span>, <span class="number">44</span>)]</span><br><span class="line">len(list_1) == <span class="number">5</span></span><br><span class="line">list_1.count(<span class="number">10</span>) == <span class="number">1</span> <span class="comment"># 元素10的数量为1</span></span><br><span class="line">list_1.index(<span class="number">10</span>) == <span class="number">1</span> <span class="comment"># 元素10的索引为1</span></span><br><span class="line">list_1.reverse() <span class="comment"># list_1 == [(33, 44), ['hi', 1, 2], '2018-10-1', 10, 2018]</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># 比较浅拷贝与深拷贝</span></span><br><span class="line"><span class="keyword">import</span> copy</span><br><span class="line">list_a = [<span class="number">2018</span>, <span class="number">10</span>, <span class="string">'2018-10-1'</span>, [<span class="string">'hi'</span>, <span class="number">1</span>, <span class="number">2</span>], (<span class="number">33</span>, <span class="number">44</span>)]</span><br><span class="line">list_b = [<span class="string">'hi'</span>, <span class="number">1</span>, <span class="number">2</span>]</span><br><span class="line">list_c = list_a.copy() <span class="comment"># list_c == [2018, 10, '2018-10-1', ['hi', 1, 2], (33, 44)]</span></span><br><span class="line">list_d = copy.deepcopy(list_a) <span class="comment"># list_d == [2018, 10, '2018-10-1', ['hi', 1, 2], (33, 44)]</span></span><br><span class="line"><span class="comment"># 改变原列表中的可变对象元素</span></span><br><span class="line">list_a[<span class="number">3</span>].append(<span class="string">'new'</span>) <span class="comment"># list_a == [2018, 10, '2018-10-1', ['hi', 1, 2, 'new'], (33, 44)]</span></span><br><span class="line"><span class="comment"># 浅拷贝中的可变对象会随原列表变化而变化</span></span><br><span class="line">list_c == [<span class="number">2018</span>, <span class="number">10</span>, <span class="string">'2018-10-1'</span>, [<span class="string">'hi'</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="string">'new'</span>], (<span class="number">33</span>, <span class="number">44</span>)]</span><br><span class="line"><span class="comment"># 深拷贝中的可变对象不会随原列表变化而变化</span></span><br><span class="line">list_d == [<span class="number">2018</span>, <span class="number">10</span>, <span class="string">'2018-10-1'</span>, [<span class="string">'hi'</span>, <span class="number">1</span>, <span class="number">2</span>], (<span class="number">33</span>, <span class="number">44</span>)]</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># 比较sort() 与 sorted()</span></span><br><span class="line">list_1 = list_2 = [<span class="number">2</span>,<span class="number">1</span>,<span class="number">4</span>,<span class="number">6</span>,<span class="number">5</span>,<span class="number">3</span>]</span><br><span class="line">list_1.sort() <span class="comment"># 原列表变化：list_1 == [1,2,3,4,5,6]</span></span><br><span class="line">list_3 = sorted(list_2) <span class="comment"># 原列表不变：list_2 == [2,1,4,6,5,3]; list_3 == [1,2,3,4,5,6]</span></span><br></pre></td></tr></table></figure>
<h2 id="Python列表索引为何从0始？"><a href="#Python列表索引为何从0始？" class="headerlink" title="Python列表索引为何从0始？"></a>Python列表索引为何从0始？</h2><p>权威解释来自Guido van Rossum（Python之父）的博文：《Why Python uses 0-based indexing》</p>
<p>一句话总结：索引从0开始，切片用法很优雅。</p>
<p>翻译精华如下：</p>
<blockquote>
<p>我决定在Python中使用0-based索引方式的一个原因，就是切片语法(slice notation)。</p>
<p>让我们来先看看切片的用法。可能最常见的用法，就是“取前n位元素”或“从第i位索引起，取后n位元素”(前一种用法，实际上是i==起始位的特殊用法)。如果这两种用法实现时可以不在表达式中出现难看的+1或-1，那将会非常的优雅。</p>
<p>使用0-based的索引方式、半开区间切片和缺省匹配区间的话（Python最终采用这样的方式），上面两种情形的切片语法就变得非常漂亮：a[:n]和a[i:i+n]，前者是a[0:n]的缩略写法。</p>
<p>如果使用1-based的索引方式，那么，想让a[:n]表达“取前n个元素”的意思，你要么使用闭合区间切片语法，要么在切片语法中使用切片起始位和切片长度作为切片参数。半开区间切片语法如果和1-based的索引方式结合起来，则会变得不优雅。而使用闭合区间切片语法的话，为了从第i位索引开始取后n个元素，你就得把表达式写成a[i:i+n-1]。</p>
<p>……</p>
<p>特别是当两个切片操作位置邻接时，第一个切片操作的终点索引值是第二个切片的起点索引值时，太漂亮了，无法舍弃。例如，你想将一个字符串以i，j两个位置切成三部分，这三部分的表达式将会是a[:i]，a[i:j]和a[j:]。</p>
</blockquote>
<h2 id="其它编程语言的索引？"><a href="#其它编程语言的索引？" class="headerlink" title="其它编程语言的索引？"></a>其它编程语言的索引？</h2><p>索引从0开始的编程语言：C、C++、Python、Java、PHP、Ruby、Javascript…</p>
<p>索引从1开始的编程语言：ABC、Matlab、VB、易语言、大部分shell语言…</p>
<p>索引从其它值开始的编程语言：Pascal、Lua…</p>
<p>还有像表示星期、月份等序列结构的数据，各种编程语言也划分成了不同阵营。</p>
<p>它们出于何种考虑？</p>
<p>C语言：索引从0开始，可以大大提升内存寻址计算的效率，详细分析参考《<a href="https://blog.csdn.net/bufanq/article/details/51330197" target="_blank" rel="noopener">C语言数组元素下标为何从0开始</a>》</p>
<p>大部分shell语言：大多数是从1开始，来源参考<a href="https://unix.stackexchange.com/questions/252368/is-there-a-reason-why-the-first-element-of-a-zsh-array-is-indexed-by-1-instead-o" target="_blank" rel="noopener">stackexchange这篇问答</a></p>
<p>Pascal、Lua：默认从1开始，但支持改变起始索引值，原因据说是对非专业的开发者更友好，来源参考<a href="https://www.zhihu.com/question/19675689/answer/19174752" target="_blank" rel="noopener">这篇知乎问答</a></p>
<p>以上列举的原因是最审慎的、体面的解释，话题应该到此终结，因为“索引应该从几开始最好”这个问题的破坏性不亚于“哪种编程语言是最好的”……</p>
<h2 id="优雅漂亮的结尾：生成器表达式"><a href="#优雅漂亮的结尾：生成器表达式" class="headerlink" title="优雅漂亮的结尾：生成器表达式"></a>优雅漂亮的结尾：生成器表达式</h2><p>列表生成式是一种漂亮优雅的东西，然而它有一个致命的缺点：它一次性把所有元素加载到内存中，当列表过长的时候，便会占据过多的内存资源，而且，我们通常仅需要使用少数的元素，这样未使用的元素所占据的绝大部分的内存，就成了不必要的支出。</p>
<p><strong>生成器是一种更高级更优雅的东西，它使用“懒加载”的原理，并不生成完整的列表，而是迭代地、即时地、按需地生成元素，这样不仅能极大地节省内存空间，而且，在理论上，它可以生成一个无穷大的列表！</strong></p>
<p>大多数生成器是以函数来实现的，然而，它并不返回（return）一个值，而是生成（yield）一个值，并挂起程序。然后，通过next()方法生成并马上返回一个元素，或者通过for循环，逐一生成和返回全部元素。</p>
<p>next()效率太低，且调用次数越界时会抛出StopIteration的异常，而for循环会自动捕捉这个异常，并停止调用，所以使用更佳。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 计算斐波那契数列的生成器</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">fibon</span><span class="params">(n)</span>:</span></span><br><span class="line">a = b = <span class="number">1</span></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> range(n):</span><br><span class="line"><span class="keyword">yield</span> a  <span class="comment"># 使用yield</span></span><br><span class="line">a, b = b, a + b</span><br><span class="line"></span><br><span class="line"><span class="comment"># 计算前1000000个数，通过next()函数，按顺序每次生成一个数</span></span><br><span class="line">g = fibon(<span class="number">1000000</span>)</span><br><span class="line">next(g)  <span class="comment"># 1</span></span><br><span class="line">next(g)  <span class="comment"># 1</span></span><br><span class="line">next(g)  <span class="comment"># 2</span></span><br><span class="line">next(g)  <span class="comment"># 3</span></span><br><span class="line">next(g)  <span class="comment"># 5</span></span><br><span class="line"><span class="comment"># 以此类推，但若调用超过1000000次，就会报异常StopIteration</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 计算前1000000个数，通过for循环逐一打印生成数</span></span><br><span class="line"><span class="keyword">for</span> x <span class="keyword">in</span> fibon(<span class="number">1000000</span>):</span><br><span class="line">print(x)</span><br></pre></td></tr></table></figure>
<p>生成器表达式与列表生成式极其形似，只是把[]改成了()，但背后的原理大不相同。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">l = [x*<span class="number">2</span> <span class="keyword">for</span> x <span class="keyword">in</span> range(<span class="number">5</span>)]  <span class="comment"># 列表生成式，4以内整数的2倍数</span></span><br><span class="line">g = (x*<span class="number">2</span> <span class="keyword">for</span> x <span class="keyword">in</span> range(<span class="number">5</span>))  <span class="comment"># 生成器表达式</span></span><br><span class="line">type(l)   <span class="comment"># 结果：&lt;type 'list'&gt;</span></span><br><span class="line">type(g)   <span class="comment"># 结果：&lt;type 'generator'&gt;</span></span><br><span class="line"></span><br><span class="line">print(l)  <span class="comment"># 结果：[0,2,4,6,8]</span></span><br><span class="line">print(g)  <span class="comment"># 结果：&lt;generator object at 0x000002173F0EBC50&gt;</span></span><br><span class="line">next(g)   <span class="comment"># 0</span></span><br><span class="line">next(g)   <span class="comment"># 2</span></span><br><span class="line">next(g)   <span class="comment"># 4</span></span><br><span class="line">next(g)   <span class="comment"># 6</span></span><br><span class="line">next(g)   <span class="comment"># 8</span></span><br><span class="line">next(g)   <span class="comment"># Traceback (most recent call last): ....StopIteration</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> x <span class="keyword">in</span> g:</span><br><span class="line">print(x, end=<span class="string">' '</span>)  <span class="comment"># 结果：0 2 4 6 8</span></span><br></pre></td></tr></table></figure>
<hr>
<p>本文原创并首发于微信公众号【Python猫】，后台回复“爱学习”，免费获得20本精选电子书。</p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://chinesehuazhou.github.io/2019/05/03/给Python初学者的文件读写指南/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="John Doe">
      <meta itemprop="description" content>
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="豌豆花下猫">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2019/05/03/给Python初学者的文件读写指南/" itemprop="url">未命名</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2019-05-03T21:21:22+08:00">
                2019-05-03
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h2 id="给Python初学者的文件读写指南（含基础与进阶，建议收藏）"><a href="#给Python初学者的文件读写指南（含基础与进阶，建议收藏）" class="headerlink" title="给Python初学者的文件读写指南（含基础与进阶，建议收藏）"></a>给Python初学者的文件读写指南（含基础与进阶，建议收藏）</h2><hr>
<p>对于初学者来说，一份详尽又清晰明白的指南很重要。今天，猫猫跟大家一起，好好学习Python文件读写的内容，这部分内容特别常用，掌握后对工作和实战都大有益处。学习是循序渐进的过程，欲速则不达。文章较长，建议大家收藏，以备复习查阅哦。</p>
<p>1、如何将列表数据写入文件？<br>2、如何从文件中读取内容？<br>3、多样需求的读写任务<br>4、从with语句到上下文管理器</p>
<h2 id="如何将列表数据写入文件？"><a href="#如何将列表数据写入文件？" class="headerlink" title="如何将列表数据写入文件？"></a>如何将列表数据写入文件？</h2><p>首先，我们来看看下面这段代码，并思考：这段代码有没有问题，如果有问题的话，要怎么改？<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">li = [&apos;python&apos;,&apos; is&apos;,&apos; a&apos;,&apos; cat&apos;]</span><br><span class="line">with open(&apos;test.txt&apos;,&apos;w&apos;) as f:</span><br><span class="line">    f.write(li)</span><br></pre></td></tr></table></figure></p>
<p>现在公布答案，这段代码会报错：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">TypeError  Traceback (most recent call last)</span><br><span class="line">&lt;ipython-input-6-57e0c2f5a453&gt; in &lt;module&gt;()</span><br><span class="line">      1 with open(&apos;test.txt&apos;,&apos;w&apos;) as f:</span><br><span class="line">----&gt; 2     f.write(li)</span><br><span class="line"></span><br><span class="line">TypeError: write() argument must be str, not list</span><br></pre></td></tr></table></figure></p>
<p>以上代码的想法是将list列表内容写入txt文件中，但是报错 TypeError: write() argument must be str。就是说，write()方法必须接受字符串（str）类型的参数。</p>
<p>Python中内置了str()方法，可以返回字符串版本的对象（Return a string version of object）。所以，上面的例子中，我们试试把 f.write(li) 改为 f.write(str(li)) ，先做一下字符串类型的转化看看。代码略。</p>
<p>这次没有报错了，但是打开文件就傻眼了吧，写入的内容是“[‘python’,’ is’,’ a’,’ cat’]”。怎么才能写成“python is a cat”呢？<br>文件写操作还有一个writelines()方法，它接收的参数是由字符串组成的序列（sequence），实际写入的效果是将全部字符串拼接在一起。字符串本身也是一种序列，所以当参数是字符串的时候，writelines()方法等价于write()。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"># 以下3种写法等价，都是写入字符串“python is a cat”</span><br><span class="line">In [20]:  with open(&apos;test.txt&apos;,&apos;w&apos;) as f:</span><br><span class="line">    ...:      f.writelines([&apos;python&apos;,&apos; is&apos;,&apos; a&apos;,&apos; cat&apos;])</span><br><span class="line">    ...:      f.writelines(&apos;python is a cat&apos;)</span><br><span class="line">    ...:      f.write(&apos;python is a cat&apos;)</span><br><span class="line"></span><br><span class="line"># 以下2种写法等价，都是写入列表的字符串版本“[&apos;python&apos;,&apos; is&apos;,&apos; a&apos;,&apos; cat&apos;]”</span><br><span class="line">In [21]:  with open(&apos;test.txt&apos;,&apos;w&apos;) as f:</span><br><span class="line">    ...:      f.write(str([&apos;python&apos;,&apos; is&apos;,&apos; a&apos;,&apos; cat&apos;]))</span><br><span class="line">    ...:      f.writelines(str([&apos;python&apos;,&apos; is&apos;,&apos; a&apos;,&apos; cat&apos;]))</span><br><span class="line">    </span><br><span class="line"># 作为反例，以下写法都是错误的：</span><br><span class="line">In [22]:  with open(&apos;test.txt&apos;,&apos;w&apos;) as f:</span><br><span class="line">    ...:      f.writelines([2018,&apos;is&apos;,&apos;a&apos;,&apos;cat&apos;]) # 含非字符串</span><br><span class="line">    ...:      f.write([&apos;python&apos;,&apos;is&apos;,&apos;a&apos;,&apos;cat&apos;]) # 非字符串</span><br></pre></td></tr></table></figure>
<p>由上可知，当多段分散的字符串存在于列表中的时候，要用writelines()方法，如果字符串是一整段，那直接使用write()方法。如果要以整个列表的形式写入文件，就使用str()方法做下转化。</p>
<p>这个问题还没结束，如果列表中就是有元素不是字符串，而且要把全部元素取出来，怎么办呢？</p>
<p>那就不能直接使用write()和writelines()了，需要先用for循环，把每个元素取出来，逐一str()处理。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">In [37]: content=[1,&apos; is&apos;,&apos; everything&apos;]</span><br><span class="line">In [38]: with open(&apos;test.txt&apos;,&apos;w&apos;) as f:</span><br><span class="line">    ...:     for i in content:</span><br><span class="line">    ...:         f.write(str(i))</span><br></pre></td></tr></table></figure>
<p>需要注意的是，writelines()不会自动换行。如果要实现列表元素间的换行，一个办法是在每个元素后面加上换行符“\n”，如果不想改变元素，最好是用for循环，在写入的时候加在末尾：for i in content:  f.writelines(str(i)+“\n”)</p>
<p>引申一下，经过实验，数字及元祖类型也可以作为write()的参数，不需转化。但是dict字典类型不可以，需要先用str()处理一下。字典类型比较特殊，最好是用json.dump()方法写到文件，具体操作方法以及注意事项，请看喵喵之前发的《<a href="https://mp.weixin.qq.com/s/hR2Z_duLXnN0fQ3khDPiPQ" target="_blank" rel="noopener">假期玩得开心也不忘充电，学习Python操作JSON，网络数据交换不用愁</a>》</p>
<p>总结一下，write()接收字符串参数，适用于一次性将全部内容写入文件；writelines()接收参数是由字符串组成的序列，适用于将列表内容逐行写入文件。str()返回Python对象的字符串版本，使用需注意。</p>
<h2 id="如何从文件中读取内容？"><a href="#如何从文件中读取内容？" class="headerlink" title="如何从文件中读取内容？"></a>如何从文件中读取内容？</h2><p>从文件中读取内容有如下方法：</p>
<blockquote>
<p>file.read([size])<br>从文件读取指定的字节数，如果未给定或为负则读取所有。</p>
<p>file.readline([size])<br>读取整行，包括 “\n” 字符。</p>
<p>file.readlines([sizeint])<br>读取所有行并返回列表，若给定sizeint&gt;0，则是设置一次读多少字节，这是为了减轻读取压力。</p>
</blockquote>
<p>简而言之，在不传参数的情况下，read()对应write()，读取全部内容；readlines()对应writelines()，读取全部内容（含换行符）并以列表形式返回，每个换行的内容作为列表的一个元素。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">In [47]: with open(&apos;test.txt&apos;,&apos;r&apos;) as f:</span><br><span class="line">    ...:     print(f.read())</span><br><span class="line">1 is everything.</span><br><span class="line">python is a cat.</span><br><span class="line">this is the end.</span><br><span class="line"></span><br><span class="line">In [48]: with open(&apos;test.txt&apos;,&apos;r&apos;) as f:</span><br><span class="line">    ...:     print(f.readlines())</span><br><span class="line">[&apos;1 is everything.\n&apos;, &apos;python is a cat.\n&apos;, &apos;this is the end.&apos;]</span><br></pre></td></tr></table></figure></p>
<p>但是，以上两个方法有个缺点，当文件过大的时候，一次性读取太多内容，会对内存造成极大压力。读操作还有一个readline()方法，可以逐行读取。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">In [49]: with open(&apos;test.txt&apos;,&apos;r&apos;) as f:</span><br><span class="line">    ...:     print(f.readline())</span><br><span class="line">1 is everything.</span><br></pre></td></tr></table></figure></p>
<p>readline()读取第一行就返回，再次调用f.readline()，会读取下一行。</p>
<p>喵喵，是否感觉跟《<a href="https://mp.weixin.qq.com/s/OKf7N3xxrS0tJ_K8Srw-jA" target="_blank" rel="noopener">超强汇总：学习Python列表，只需这篇文章就够了</a>》学习过的生成器很像，需要不停调用next()获取下一行。</p>
<p>这么看来，readline()太笨拙了。那么，有什么办法可以优雅地读取文件内容呢？</p>
<p>回过头来看readlines()方法，它返回的是一个列表。这不奇怪么，好端端的内容为啥要返回成列表呢？</p>
<p>再想想writelines()方法，把字符串列表写入文件正是这家伙干的事，readlines()方法恰恰是它的逆操作！而writelines()方法要配合for循环，所以我们把readlines()与for循环结合，看看会怎样。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">In [61]: with open(&apos;test.txt&apos;,&apos;r&apos;) as f:</span><br><span class="line">    ...:     for line in f.readlines():</span><br><span class="line">    ...:         print(line)</span><br><span class="line">1 is everything.</span><br><span class="line"></span><br><span class="line">python is a cat.</span><br><span class="line"></span><br><span class="line">this is the end.</span><br><span class="line"></span><br><span class="line"># 读取内容包含换行符，所以要strip()去掉换行符</span><br><span class="line">In [62]: with open(&apos;test.txt&apos;,&apos;r&apos;) as f:</span><br><span class="line">    ...:     for line in f.readlines():</span><br><span class="line">    ...:         print(line.strip())</span><br><span class="line">1 is everything.</span><br><span class="line">python is a cat.</span><br><span class="line">this is the end.</span><br></pre></td></tr></table></figure>
<p>总结一下，readline()比较鸡肋，不咋用；read()适合读取内容较少的情况，或者是需要一次性处理全部内容的情况；而readlines()用的较多，比较灵活，因为for循环是一种迭代器，每次加载部分内容，既减少内存压力，又方便逐行对数据处理。</p>
<h2 id="多样需求的读写任务"><a href="#多样需求的读写任务" class="headerlink" title="多样需求的读写任务"></a>多样需求的读写任务</h2><p>前两部分讲了文件读写的几大核心方法，它们能够起作用的前提就是，需要先打开一个文件对象，因为只有在文件操作符的基础上才可以进行读或者写的操作。</p>
<p>打开文件用的是open()方法，所以我们再继续讲讲这个方法。open() 方法用于打开一个文件，并返回文件对象，在对文件进行处理过程都需要使用到这个函数，如果该文件无法被打开，会抛出 OSError。</p>
<blockquote>
<p>open(file, mode=’r’, buffering=-1, encoding=None, errors=None, newline=None, closefd=True, opener=None)</p>
</blockquote>
<p>open()方法的参数里file（文件）是必需的，其它参数最常用的是mode（模式）和encoding（编码）。</p>
<p>先说说encoding，一般来说，打开文件的编码方式以操作系统的默认编码为准，中文可能会出现乱码，需要加encoding=’utf-8’。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">In [63]: with open(&apos;test.txt&apos;,&apos;r&apos;) as f:</span><br><span class="line">    ...:     for line in f.readlines():</span><br><span class="line">    ...:         print(line.strip())</span><br><span class="line">-----------------------</span><br><span class="line">UnicodeDecodeError     Traceback (most recent call last)</span><br><span class="line">&lt;ipython-input-63-731a4f9cf707&gt; in &lt;module&gt;()</span><br><span class="line">      1 with open(&apos;test.txt&apos;,&apos;r&apos;) as f:</span><br><span class="line">----&gt; 2     for line in f.readlines():</span><br><span class="line">      3         print(line.strip())</span><br><span class="line">UnicodeDecodeError: &apos;gbk&apos; codec can&apos;t decode byte 0xa4 in position 26: illegal multibyte sequence</span><br><span class="line"></span><br><span class="line">In [65]: with open(&apos;test.txt&apos;,&apos;r&apos;,encoding=&apos;utf-8&apos;) as f:</span><br><span class="line">    ...:     for line in f.readlines():</span><br><span class="line">    ...:         print(line.strip())</span><br><span class="line">爱猫猫</span><br><span class="line">python is a cat.</span><br></pre></td></tr></table></figure>
<p>再说mode，它指定文件打开的模式。</p>
<blockquote>
<p>‘r’： 以只读模式打开（缺省模式）（必须保证文件存在）<br>‘w’：以只写模式打开。若文件存在，则清空文件，然后重新创建；若不存在，则新建文件。<br>‘a’：以追加模式打开。若文件存在，则会追加到文件的末尾；若文件不存在，则新建文件。<br>常见的mode组合<br>‘r’或’rt’：     默认模式，文本读模式<br>‘w’或’wt’：  以文本写模式打开（打开前文件会被清空）<br>‘rb’：          以二进制读模式打开<br>‘ab’：         以二进制追加模式打开<br>‘wb’：        以二进制写模式打开（打开前文件会被清空）<br>‘r+’：         以文本读写模式打开，默认写的指针开始指在文件开头, 因此会覆写文件<br>‘w+’：        以文本读写模式打开（打开前文件会被清空）<br>‘a+’：        以文本读写模式打开（写只能写在文件末尾）<br>‘rb+’：       以二进制读写模式打开<br>‘wb+’：     以二进制读写模式打开（打开前文件会被清空）<br>‘ab+’：      以二进制读写模式打开</p>
</blockquote>
<p>喵喵，初看起来，模式很多，但是，它们只是相互组合罢了。建议记住最基本的w、r、a，遇到特殊场景，再翻看一下就好了。</p>
<h2 id="从with语句到上下文管理器"><a href="#从with语句到上下文管理器" class="headerlink" title="从with语句到上下文管理器"></a>从with语句到上下文管理器</h2><p>基础部分讲完了，下面是进阶部分。知其然，更要知其所以然。</p>
<p>1、with语句是初学者必会常识</p>
<p>首先，要解释一下为啥前文直接就用了with语句。with语句是读写文件时的优雅写法，这已经默认是Python初学者必会的常识了。如果你还不会，先看看用和不用with语句的对比：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"># 不用with语句的正确写法</span><br><span class="line">try:</span><br><span class="line">    f = open(&apos;test.txt&apos;,&apos;w&apos;)</span><br><span class="line">    f.writelines([&apos;python&apos;,&apos; is&apos;,&apos; a&apos;,&apos; cat&apos;])</span><br><span class="line">finally:</span><br><span class="line">    if f:</span><br><span class="line">        f.close()</span><br><span class="line"></span><br><span class="line"># 使用with语句的正确写法</span><br><span class="line">with open(&apos;test.txt&apos;,&apos;w&apos;) as f:</span><br><span class="line">    f.writelines([&apos;python&apos;,&apos; is&apos;,&apos; a&apos;,&apos; cat&apos;])</span><br></pre></td></tr></table></figure>
<p>因为文件对象会占用操作系统的资源，并且操作系统同一时间能打开的文件数量是有限的，所以open()方法之后一定要调用close()方法。另外，读写操作可能出现IO异常的情况，所以要加try…finally，保证无论如何，都会调用到close()方法。</p>
<p>这样写万无一失，但是实在繁琐，一不小心还可能漏写或者写错。而with语句会保证调用close()，只需一行代码，简直不要太优雅！所以，with语句是Python初学者必会技能。</p>
<p>2、什么是上下文管理器？</p>
<p>下面，重头戏来了，什么是上下文管理器（context manager）？</p>
<blockquote>
<p>上下文管理器是这样一个对象：它定义程序运行时需要建立的上下文，处理程序的进入和退出，实现了上下文管理协议，即在对象中定义了 <strong>enter</strong>() 和 <strong>exit</strong>() 方法。<br><strong>enter</strong>()：进入运行时的上下文，返回运行时上下文相关的对象，with 语句中会将这个返回值绑定到目标对象。<br><strong>exit</strong>(exception_type, exception_value, traceback)：退出运行时的上下文，定义在块执行（或终止）之后上下文管理器应该做什么。它可以处理异常、清理现场或者处理 with 块中语句执行完成之后需要处理的动作。</p>
</blockquote>
<p>注意enter和exit的前后有两个下划线，Python中自带了很多类似的方法，它们是很神秘又很强大的存在，江湖人常常称其为“黑魔法”。例如，迭代器协议就实现了<strong>iter</strong>方法。</p>
<p>在Python的内置类型中，很多类型都是支持上下文管理协议的，例如file，thread.LockType，threading.Lock等等。上下文管理器无法独立使用，它们要与with相结合，with语句可以在代码块运行前进入一个运行时上下文（执行<strong>enter</strong>方法），并在代码块结束后退出该上下文（执行<strong>exit</strong>方法）。</p>
<p>with 语句适用于对资源进行访问的场合，确保不管使用过程中是否发生异常都会执行必要的“清理”操作，释放资源，比如文件使用后自动关闭、线程中锁的自动获取和释放等。</p>
<p>3、自定义上下文管理器</p>
<p>除了Python的内置类型，任何人都可以定义自己的上下文管理器。下面是一个示例：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">class OpenFile(object):</span><br><span class="line">    def __init__(self,filename,mode):</span><br><span class="line">        self.filename=filename</span><br><span class="line">        self.mode=mode</span><br><span class="line">    def __enter__(self):</span><br><span class="line">        self.f=open(self.filename,self.mode)</span><br><span class="line">        self.f.write(&quot;enter now\n&quot;)</span><br><span class="line">        return self.f  #作为as说明符指定的变量的值</span><br><span class="line">    def __exit__(self,type,value,tb):</span><br><span class="line">        self.f.write(&quot;exit now&quot;)</span><br><span class="line">        self.f.close()</span><br><span class="line">        return False   #异常会被传递出上下文</span><br><span class="line">with OpenFile(&apos;test.txt&apos;,&apos;w&apos;) as f:</span><br><span class="line">    f.write(&apos;Hello World!\n&apos;)</span><br></pre></td></tr></table></figure>
<p>最终写入文件的结果是：</p>
<blockquote>
<p>enter now<br>Hello World!<br>exit now</p>
</blockquote>
<p>上下文管理器必须同时提供 <strong>enter</strong>() 和 <strong>exit</strong>() 方法的定义，缺少任何一个都会导致 AttributeError。</p>
<p>上下文管理器在执行过程中可能会出现异常，<strong>exit</strong>() 的返回值会决定异常的处理方式：返回值等于 False，那么这个异常将被重新抛出到上层；返回值等于 True，那么这个异常就被忽略，继续执行后面的代码。<strong>exit</strong>() 有三个参数(exception_type, exception_value, traceback)，即是异常的相关信息。</p>
<p>4、contextlib实现上下文管理器</p>
<p>上例中，自定义上下文管理器的写法还是挺繁琐的，而且只能用于类级别。为了更好地辅助上下文管理，Python 内置提供了 contextlib 模块，进而可以很方便地实现函数级别的上下文管理器。</p>
<p>该模块本质上是通过装饰器(decorators)和生成器(generators)来实现上下文管理器，可以直接作用于函数/对象，而不用去关心 <strong>enter</strong>() 和 <strong>exit</strong>() 方法的具体实现。</p>
<p>先把上面的例子改造一下，然后我们再对照着解释：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">from contextlib import contextmanager</span><br><span class="line"></span><br><span class="line">@contextmanager</span><br><span class="line">def open_file(name):</span><br><span class="line">    ff = open(name, &apos;w&apos;)</span><br><span class="line">    ff.write(&quot;enter now\n&quot;)</span><br><span class="line">    try:</span><br><span class="line">        yield ff</span><br><span class="line">    except RuntimeError:</span><br><span class="line">        pass</span><br><span class="line">    ff.write(&quot;exit now&quot;)</span><br><span class="line">    ff.close()</span><br><span class="line"></span><br><span class="line">with open_file(&apos;test.txt&apos;) as f:</span><br><span class="line">    f.write(&apos;Hello World!\n&apos;)</span><br></pre></td></tr></table></figure>
<p>contextmanager是要使用的装饰器，yield关键字将普通的函数变成了生成器。yield的返回值（ff）等于上例<strong>enter</strong>()的返回值，也就是as语句的值（f），而yield前后的内容，分别是<strong> enter</strong>() 和 <strong>exit</strong>() 方法里的内容。使用contextlib，可以避免类定义、<strong>enter</strong>() 和 <strong>exit</strong>()方法，但是需要我们捕捉可能的异常（例如，yield只能返回一个值，否则会导致异常 RuntimeError），所以try…except语句不能忽略。</p>
<p>-—————-</p>
<p>本文原创并首发于微信公众号【Python猫】，后台回复“爱学习”，免费获得20本精选电子书。</p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://chinesehuazhou.github.io/2019/05/03/来自Kenneth Reitz大神的建议：避免不必要的面向对象编程/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="John Doe">
      <meta itemprop="description" content>
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="豌豆花下猫">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2019/05/03/来自Kenneth Reitz大神的建议：避免不必要的面向对象编程/" itemprop="url">未命名</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2019-05-03T21:21:22+08:00">
                2019-05-03
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h2 id="来自Kenneth-Reitz大神的建议：避免不必要的面向对象编程"><a href="#来自Kenneth-Reitz大神的建议：避免不必要的面向对象编程" class="headerlink" title="来自Kenneth Reitz大神的建议：避免不必要的面向对象编程"></a>来自Kenneth Reitz大神的建议：避免不必要的面向对象编程</h2><p>你也许见过很多人对于Python的评价，他们说Python是“脚本语言”和“胶水语言”，在某种程度上，他们说的是对的。但是，如果你学习过Python，你会知道Python也支持面向对象的编程，更有甚者，在Python中所有东西都是对象。</p>
<p>事实上，Python有着很强大的支持面向对象编程的能力，比如我们刚介绍过的pathlib模块（<a href="https://mp.weixin.qq.com/s/2zGUfwIYY4EVJ0NNyJkNRQ" target="_blank" rel="noopener">点链接回顾</a>），它就是一个用面向对象思想来处理文件系统的模块。</p>
<p>可以说，Python是“能屈能伸”吧，小打小闹的时候开箱即用轻松上手，认真严肃起来耍大刀也是虎虎生风不遑多让。</p>
<p>只不过，面向对象就一定是好事么？支持面向对象编程，就一定要时刻这样用么？</p>
<p>下面段落出自《Python最佳实践指南》，这是由圈内大神Kenneth Reitz发起和维护的开源项目（文末附了相关链接），让我们一起来看看K神提出的建议。</p>
<h2 id="Kenneth-Reitz大神的建议"><a href="#Kenneth-Reitz大神的建议" class="headerlink" title="Kenneth Reitz大神的建议"></a>Kenneth Reitz大神的建议</h2><p>Python 有时被描述为一种面向对象的编程语言。这可能对大家有些误导，需要加以澄清。</p>
<p>在 Python 中，所有东西都视为一个对象，并且可以按对象处理。当我们说，函数是“一级”对象，就是将函数视为对象的意思。函数、类、字符串，甚至类型都是 Python 中的对象：像任何对象一样，它们有一个类型，可以作为函数参数传递，并且它们可能有方法和属性。按这种理解， Python 是一种面向对象的语言。</p>
<p>但是，<strong>与 Java 不同， Python 并没有将面向对象的编程作为主要的编程范例来实施。</strong> Python 项目不采用面向对象的方式是完全可行的，即不使用或很少使用类定义、类继承或特定于面向对象编程的任何其他机制。</p>
<p>此外，从 <a href="http://docs.python-guide.org/en/latest/writing/structure/#modules" target="_blank" rel="noopener">模块</a> 部分可以看出， Python 处理模块和名称空间的方式为开发人员提供了一种自然的方法来确保抽象层的封装和分离，这两者都是使用面向对象的最常见原因。因此，当业务模型不需要面向对象时， Python 程序员有更大的自由来不使用面向对象编程。</p>
<p><strong>基于一些因素的考虑，我们应避免不必要的面向对象编程。</strong> 当我们想将一些状态和功能粘合在一起时，定义自定义类是很有用的。在函数编程的讨论中，我们指出，“不必要的面向对象编程”这个问题出自方程的“状态”部分。</p>
<p>在某些体系结构中，例如典型的 web 应用程序，会生成多个 Python 进程实例，以响应可能同时发生的外部请求。在这种情况下，将一些状态保存到实例对象中，意味着保留一些关于世界的静态信息，这很容易出现并发或竞争问题。有时，在对象的初始化（通常用 <code>__init__()</code> 方法来完成）状态和实际使用对象方法的状态之间，世界信息可能已经改变，保持的状态可能已经过时。例如，一个请求加载了内存中的某一项，并将其标记为由用户读取。而另一个请求同时要求删除该项，这可能发生在第一个进程加载该项之后，然后我们必须将其标记为已删除对象。</p>
<p><strong>上述以及其他问题引出了这样的想法：使用无状态函数是一种更好的编程范例。</strong> </p>
<p><strong>另一种说法是建议尽可能少的使用具有隐式上下文和副作用的函数和程序。</strong>函数的隐式上下文由全局变量和持久层中的数据项（使用方法访问）组成。副作用是指函数对其隐式上下文所做的更改。如果函数会保存或删除全局变量或持久层中的数据，则称它有副作用。</p>
<p>将有上下文和副作用的函数与逻辑函数（称为纯函数）隔离开来，可以获得以下好处：</p>
<ul>
<li>纯函数是确定性的：给定一个固定的输入，输出始终是相同的。</li>
<li>纯函数需要重构或优化时，更容易更改或替换。</li>
<li>纯函数更易于使用单元测试进行测试：对于复杂的上下文设置和事后的数据清理的需求更少。</li>
<li>纯函数更容易操作、修饰和传递。</li>
</ul>
<p>总之，针对某些体系结构，由于没有上下文或副作用，<strong>纯函数是比类和对象更有效的构建块</strong> 。</p>
<p>显然，面向对象编程在许多情况下是有用的，甚至是必要的，例如在开发图形化桌面应用程序或游戏时，被操作的东西（窗口、按钮、化身、车辆）在计算机内存中具有相对较长的寿命。</p>
<h2 id="猫猫的思考"><a href="#猫猫的思考" class="headerlink" title="猫猫的思考"></a>猫猫的思考</h2><p>以上就是K神的建议。他在后半段提到了纯函数（pure functions），这让猫猫联想到了函数式编程（Functional Programming），但纯函数似乎是一种更具普遍性的东西，它就像是一种数学上的定义。纯函数真的有那么神么？</p>
<p>于是，猫猫去google了“纯函数”。没想到，排在前面的结果竟然全跟Javascript相关。</p>
<p><img src="C:\Users\yunpoyue\Desktop\备用资料\纯函数.PNG" alt="纯函数"></p>
<p>除去维基百科的条目，第一个答案指向了一本GitBook《JS函数式编程指南》，好奇的猫猫点进去看了，结果大为叹服！建议大家有条件的话都去读一下（链接见文末，不懂js也不影响理解）。</p>
<p>非常巧合的是，这本书的作者也发表了他对于面向对象编程的看法：</p>
<blockquote>
<p>我最喜欢的名言之一是 Erlang 语言的作者 Joe Armstrong 说的这句话：“面向对象语言的问题是，它们永远都要随身携带那些隐式的环境。你只需要一个香蕉，但却得到一个拿着香蕉的大猩猩…以及整个丛林”。</p>
</blockquote>
<p>读完《纯函数的好处》章节，猫猫提炼了几条笔记。一方面是为了加强对纯函数的理解，在实战中规避一些“不纯”的用法，另一方面，也提出了几个思考和疑问，今后在学习Python的过程中，留神找到答案：</p>
<p>1、避免使用不纯的函数。JS中的splice是个不纯的函数，那Python中是否也有这样的函数呢？</p>
<p>2、下例中第一个是不纯的，因为函数的结果取决于minimum这个可变变量，换句话说，它取决于系统状态（system state）；这一点令人沮丧，因为它引入了外部的环境，从而增加了认知负荷（cognitive load）。（题外话：这个例子，猫猫大有感触。公司有个项目的老版本代码中，充斥了各种全局变量，小伙伴们在维护时吃了好多苦头！）JS中可以用Object.freeze 方法令minimum成为不可变对象，Python中有类似的实现么？</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">// 不纯的</span><br><span class="line">var minimum = 21;</span><br><span class="line">var checkAge = function(age) &#123;</span><br><span class="line">  return age &gt;= minimum;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">// 纯的</span><br><span class="line">var checkAge = function(age) &#123;</span><br><span class="line">  var minimum = 21;</span><br><span class="line">  return age &gt;= minimum;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>3、不纯函数会带来“副作用”，其“作用”本身没有坏处，但其“副”是滋生bug的温床。并不是说，要禁止使用一切副作用，而是说，要让它们在可控的范围内发生。坚持这种「相同输入得到相同输出」的原则。</p>
<p>4、纯函数实际上就是数学定义中的函数。<strong>“函数是不同数值之间的特殊关系：每一个输入值返回且只返回一个输出值。”</strong> </p>
<p>5、追求“纯”的理由：可缓存性（有点像生成器，延迟执行）、可移植性／自文档化（因其完全自给自足，依赖关系明确）、可测试性（为函数式环境定制的测试工具，JS中有Quickcheck，Python中有么？）、合理性（引用透明性：一段代码可以替换成它执行所得的结果，而且是在不改变整个程序行为的前提下替换）、并行代码（纯函数根本不需要访问共享的内存，而且纯函数也不会因副作用而进入竞争态（race condition））。</p>
<p>今天的分享就到这了，最后再啰嗦几句。本篇文章里，一句Python代码都没有，真的是够“干”的了。猫猫有时候挺喜欢看这样的文章，因为它会带给你思想上的启迪，就像是绝世高人在传授秘籍心法一样。所以，猫猫也喜欢转述和思考这类问题，比如之前发过的一篇《<a href="https://mp.weixin.qq.com/s/OKf7N3xxrS0tJ_K8Srw-jA" target="_blank" rel="noopener">超强汇总：学习Python列表，只需这篇文章就够了</a>》，就不仅仅有代码层面的内容，还特意加入了Guido老爹关于Python列表索引为何从0开始的解释，以及其它编程语言对索引值的考虑。</p>
<p>不记得在哪里曾看到过一句话，送予大家共勉：</p>
<blockquote>
<p>如果一个人眼里只看得见代码，那他跟咸（ma）鱼（nong）有啥区别？</p>
</blockquote>
<p>最后的最后：由于开通得晚，公众号没有留言功能，你若觉得本文对你有帮助，欢迎点赞支持哦。最后的PS：后台回复“爱学习”，免费获得20本精选电子书。</p>
<p>扩展阅读：<br>Python最佳实践指南（中文）：</p>
<p><a href="https://pythoncaff.com/docs/python-guide/2018" target="_blank" rel="noopener">https://pythoncaff.com/docs/python-guide/2018</a></p>
<p><a href="https://pythonguidecn.readthedocs.io/zh/latest/" target="_blank" rel="noopener">https://pythonguidecn.readthedocs.io/zh/latest/</a></p>
<p>Python最佳实践指南（英文）:<br><a href="https://docs.python-guide.org/" target="_blank" rel="noopener">https://docs.python-guide.org/</a></p>
<p>JS 函数式编程指南：<br><a href="https://llh911001.gitbooks.io/mostly-adequate-guide-chinese/content/ch3.html" target="_blank" rel="noopener">https://llh911001.gitbooks.io/mostly-adequate-guide-chinese/content/ch3.html</a></p>
<hr>
<p>本文原创并首发于微信公众号【Python猫】，后台回复“爱学习”，免费获得20本精选电子书。</p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://chinesehuazhou.github.io/2019/05/03/学习Python，怎能不懂点PEP呢？/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="John Doe">
      <meta itemprop="description" content>
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="豌豆花下猫">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2019/05/03/学习Python，怎能不懂点PEP呢？/" itemprop="url">未命名</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2019-05-03T21:21:22+08:00">
                2019-05-03
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h2 id="学习Python，怎能不懂点PEP呢？"><a href="#学习Python，怎能不懂点PEP呢？" class="headerlink" title="学习Python，怎能不懂点PEP呢？"></a>学习Python，怎能不懂点PEP呢？</h2><p>或许你是一个初入门Python的小白，完全不知道PEP是什么。又或许你是个学会了Python的熟手，见过几个PEP，却不知道这玩意背后是什么。那正好，本文将系统性地介绍一下PEP，与大家一起加深对PEP的了解。</p>
<p>目前，国内各类教程不可胜数，虽然或多或少会提及PEP，但笼统者多、局限于某个PEP者多，能够详细而全面地介绍PEP的文章并不多。</p>
<p><strong>本文的目的是：尽量全面地介绍PEP是什么，告诉大家为什么要去阅读PEP，以及列举了一些我认为是必读的PEP，最后，则是搜罗了几篇PEP的中文翻译，希望能为Python学习资料的汉化，做点抛砖引玉的贡献。</strong></p>
<h2 id="PEP是什么？"><a href="#PEP是什么？" class="headerlink" title="PEP是什么？"></a>PEP是什么？</h2><p>PEP的全称是<code>Python Enhancement Proposals</code>，其中Enhancement是增强改进的意思，Proposals则可译为提案或建议书，所以合起来，比较常见的翻译是<code>Python增强提案</code>或<code>Python改进建议书</code>。</p>
<p>我个人倾向于前一个翻译，因为它更贴切。Python核心开发者主要通过邮件列表讨论问题、提议、计划等，PEP通常是汇总了多方信息，经过了部分核心开发者review和认可，最终形成的正式文档，起到了对外公示的作用，所以我认为翻译成“提案”更恰当。</p>
<p>PEP的官网是：<a href="https://www.python.org/dev/peps/，这也就是PEP" target="_blank" rel="noopener">https://www.python.org/dev/peps/，这也就是PEP</a> 0 的地址。其它PEP的地址是将编号拼接在后面，例如：<a href="https://www.python.org/dev/peps/pep-0020/" target="_blank" rel="noopener">https://www.python.org/dev/peps/pep-0020/</a> 就是PEP 20 的链接，以此类推。</p>
<p>第一个PEP诞生于2000年，现在正好是18岁成年。到目前为止，它拥有478个“兄弟姐妹”。</p>
<p>官方将PEP分成三类:</p>
<blockquote>
<p>I - Informational PEP</p>
<p>P - Process PEP</p>
<p>S - Standards Track PEP</p>
</blockquote>
<p>其含义如下:</p>
<p>信息类：这类PEP就是提供信息，有告知类信息，也有指导类信息等等。例如PEP 20（The Zen of Python，即著名的Python之禅）、PEP 404 (Python 2.8 Un-release Schedule，即宣告不会有Python2.8版本)。</p>
<p>流程类：这类PEP主要是Python本身之外的周边信息。例如PEP 1（PEP Purpose and Guidelines，即关于PEP的指南）、PEP 347（Migrating the Python CVS to Subversion，即关于迁移Python代码仓）。</p>
<p>标准类：这类PEP主要描述了Python的新功能和新实践（implementation），是数量最多的提案。例如我之前推文《<a href="https://mp.weixin.qq.com/s/Whrd6NiD4Y2Z-YSCy4XJ1w" target="_blank" rel="noopener">详解Python拼接字符串的七种方式</a>》提到过的f-string方式，它出自PEP 498（Literal String Interpolation，字面字符串插值）。</p>
<p>每个PEP最初都是一个草案（Draft），随后会经历一个过程，因此也就出现了不同的状态。以下是一个流程图：</p>
<p><img src="https://www.python.org/m/dev/peps/pep-0001/pep-0001-process_flow.png" alt="PEP process flow diagram"></p>
<blockquote>
<p>A – Accepted (Standards Track only) or Active proposal 已接受（仅限标准跟踪）或有效提案</p>
<p>D – Deferred proposal 延期提案</p>
<p>F – Final proposal 最终提案</p>
<p>P – Provisional proposal 暂定提案</p>
<p>R – Rejected proposal 被否决的提案</p>
<p>S – Superseded proposal 被取代的提案</p>
<p>W – Withdrawn proposal 撤回提案</p>
</blockquote>
<p>在PEP 0（Index of Python Enhancement Proposals (PEPs)）里，官方列举了所有的PEP，你可以按序号、按类型以及按状态进行检索。而在PEP 1（PEP Purpose and Guidelines）里，官方详细说明了PEP的意图、如何提交PEP、如何修复和更新PEP、以及PEP评审的机制等等。</p>
<h2 id="为什么要读PEP？"><a href="#为什么要读PEP？" class="headerlink" title="为什么要读PEP？"></a>为什么要读PEP？</h2><p>无论你是刚入门Python的小白、有一定经验的从业人员，还是资深的黑客，都应该阅读Python增强提案。</p>
<p>依我之见，阅读PEP至少有如下好处:</p>
<p>（1）了解Python有哪些特性，它们与其它语言特性的差异，为什么要设计这些特性，是怎么设计的，怎样更好地运用它们；</p>
<p>（2）跟进社区动态，获知业内的最佳实践方案，调整学习方向，改进工作业务的内容；</p>
<p>（3）参与热点议题讨论，或者提交新的PEP，为Python社区贡献力量。</p>
<p>说到底，学会用Python编程，只是掌握了皮毛。PEP提案是深入了解Python的途径，是真正掌握Python语言的一把钥匙，也是得心应手使用Python的一本指南。</p>
<h2 id="哪些PEP是必读的？"><a href="#哪些PEP是必读的？" class="headerlink" title="哪些PEP是必读的？"></a>哪些PEP是必读的？</h2><p>如前所述，PEP提案已经累积产生了478个，我们并不需要对每个PEP都熟知，没有必要。下面，我列举了一些PEP，推荐大家一读：</p>
<p>PEP 0 – Index of Python Enhancement Proposals<br>PEP 7 – Style Guide for C Code，C扩展<br>PEP 8 – Style Guide for Python Code，Python编码规范（必读）<br>PEP 20 – The Zen of Python，Python之禅<br>PEP 202 – List Comprehensions，列表生成式<br>PEP 274 – Dict Comprehensions，字典生成式<br>PEP 234 – Iterators，迭代器<br>PEP 257 – Docstring Conventions，文档注释规范<br>PEP 279 – The enumerate() built-in function，enumerate枚举<br>PEP 282 – A Logging System，日志模块<br>PEP 285 – Adding a bool type，布尔值（建议阅读《<a href="https://mp.weixin.qq.com/s/YQbk0smMTCexsi3Ytd2AzA" target="_blank" rel="noopener">Python对象的身份迷思：从全体公民到万物皆数</a>》）<br>PEP 289 – Generator Expressions，生成器表达式<br>PEP 318 – Decorators for Functions and Methods，装饰器<br>PEP 342 – Coroutines via Enhanced Generators，协程<br>PEP 343 – The “with” Statement，with语句<br>PEP 380 – Syntax for Delegating to a Subgenerator，yield from语法<br>PEP 405 – Python Virtual Environments，虚拟环境<br>PEP 471 – os.scandir() function，遍历目录<br>PEP 484 – Type Hints，类型约束<br>PEP 492 – Coroutines with async and await syntax，async/await语法<br>PEP 498 – Literal String Interpolation Python，字面字符串插值<br>PEP 525 – Asynchronous Generators，异步生成器<br>PEP 572 – Assignment Expressions，表达式内赋值（最具争议）<br>PEP 3105 – Make print a function，print改为函数<br>PEP 3115 – Metaclasses in Python 3000，元类<br>PEP 3120 – Using UTF-8 as the default source encoding，默认UTF-8<br>PEP 3333 – Python Web Server Gateway Interface v1.0.1，Web开发<br>PEP 8000 – Python Language Governance Proposal Overview，GvR老爹推出决策层后，事关新决策方案</p>
<p>关于PEP，知乎上有两个问题，推荐大家关注：哪些PEP值得阅读（<a href="https://dwz.cn/7CHMBlLu），如何看待PEP" target="_blank" rel="noopener">https://dwz.cn/7CHMBlLu），如何看待PEP</a> 572（<a href="https://dwz.cn/L46jpzMB）。" target="_blank" rel="noopener">https://dwz.cn/L46jpzMB）。</a></p>
<h2 id="对PEP的贡献"><a href="#对PEP的贡献" class="headerlink" title="对PEP的贡献"></a>对PEP的贡献</h2><p>虽无确切数据作证，我国Python开发者的数量应该比任何国家都多。然而，纵观PEP 0 里面列举的200多个PEP作者，我只看到了一个像是汉语拼音的国人名字（不排除看漏，或者使用了英文名的）。反差真是太大了。</p>
<p>我特别希望，国内的Python黑客们的名字，能越来越多地出现在那个列表里，出现在Python核心开发者的列表里。</p>
<p>此外，关于对PEP的贡献，还有一种很有效的方式，就是将PEP翻译成中文，造福国内的Python学习社区。经过一番搜索，我还没有看到系统性翻译PEP的项目，只找到了零星的对于某个PEP的翻译。</p>
<p>我用心搜集了几篇中文翻译成果，分享给大家：</p>
<p>PEP8 <a href="https://dwz.cn/W01HexFD" target="_blank" rel="noopener">https://dwz.cn/W01HexFD</a><br>PEP257 <a href="https://dwz.cn/JLctlNLC" target="_blank" rel="noopener">https://dwz.cn/JLctlNLC</a><br>PEP328 <a href="https://dwz.cn/4vCQJpEP" target="_blank" rel="noopener">https://dwz.cn/4vCQJpEP</a><br>PEP333 <a href="https://dwz.cn/TAXIZdzc" target="_blank" rel="noopener">https://dwz.cn/TAXIZdzc</a><br>PEP484 <a href="https://dwz.cn/dSLZgg5B" target="_blank" rel="noopener">https://dwz.cn/dSLZgg5B</a><br>PEP492 <a href="http://t.cn/EALeaL0" target="_blank" rel="noopener">http://t.cn/EALeaL0</a><br>PEP541 <a href="https://dwz.cn/ce98vc27" target="_blank" rel="noopener">https://dwz.cn/ce98vc27</a><br>PEP3107 <a href="http://suo.im/4xFESR" target="_blank" rel="noopener">http://suo.im/4xFESR</a><br>PEP3333 <a href="https://dwz.cn/si3xylgw" target="_blank" rel="noopener">https://dwz.cn/si3xylgw</a></p>
<p>最后，表达一下我的私心：</p>
<p>（1）希望本文能给大家带来知识和见识的增长，激发一些小伙伴的学习热情 </p>
<p>（2）希望有小伙伴去翻译更多的PEP，造福Python的中文学习社区</p>
<p>-—————-<br>原文链接：<a href="https://mp.weixin.qq.com/s/oRoBxZ2-IyuPOf_MWyKZyw" target="_blank" rel="noopener">https://mp.weixin.qq.com/s/oRoBxZ2-IyuPOf_MWyKZyw</a><br>本文原创并首发于微信公众号【Python猫】，后台回复“爱学习”，免费获得20+本精选电子书。</p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://chinesehuazhou.github.io/2019/05/03/学习Python操作JSON，网络数据交换不用愁/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="John Doe">
      <meta itemprop="description" content>
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="豌豆花下猫">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2019/05/03/学习Python操作JSON，网络数据交换不用愁/" itemprop="url">未命名</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2019-05-03T21:21:22+08:00">
                2019-05-03
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h2 id="学习Python操作JSON，网络数据交换不用愁"><a href="#学习Python操作JSON，网络数据交换不用愁" class="headerlink" title="学习Python操作JSON，网络数据交换不用愁"></a>学习Python操作JSON，网络数据交换不用愁</h2><hr>
<p>今天，本喵带大家学学Python中操纵JSON的知识。学完本文，你可以学到如下内容：</p>
<p>1、JSON是什么？<br>2、JSON与XML的优劣差异？<br>3、将Python对象编码成JSON字符串<br>4、将已编码的JSON字符串解码为Python对象<br>5、解决JSON中文乱码问题</p>
<h2 id="JSON是什么？"><a href="#JSON是什么？" class="headerlink" title="JSON是什么？"></a>JSON是什么？</h2><p>JSON的全称是 JavaScript Object Notation，是一种轻量级的数据交换格式。最初，JSON 只是 JavaScript 的子集，但由于其简单易用而迅速走红。</p>
<p>现今大部分编程语言都支持对JSON的解析与生成，而近些年异军突起的NoSQL数据库也多参照JSON来设计数据存储格式，例如Mongodb的BSON（Binary JSON）。</p>
<p>JSON有以下六种数据类型：number、boolean、string、null、array、object。前三种很好理解，第四个null对应Python的None，最后两种，对应Python的列表和字典。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  &quot;name&quot;: &quot;小明&quot;,</span><br><span class="line">  &quot;age&quot;: 14,</span><br><span class="line">  &quot;gender&quot;: true,</span><br><span class="line">  &quot;grade&quot;: null,</span><br><span class="line">  &quot;skills&quot;: [</span><br><span class="line">    &quot;JavaScript&quot;,</span><br><span class="line">    &quot;Java&quot;,</span><br><span class="line">    &quot;Python&quot;</span><br><span class="line">  ]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="JSON与XML的优劣差异？"><a href="#JSON与XML的优劣差异？" class="headerlink" title="JSON与XML的优劣差异？"></a>JSON与XML的优劣差异？</h2><p>在JSON出现之前，人们用XML在网络上交换数据，在JSON出现后，它基本上就取代了XML的位置。两者的共同之处显而易见，它们都是结构化的语言，都可以用于网络数据的交换。</p>
<p>两者最大的差异在于它们的“出身”不同，也就是它们被创造的目的不同。</p>
<p>XML是W3C（万维网联盟）发布的可扩展标记语言（Extensible Markup Language），最初设计来弥补HTML的不足，以强大的扩展性满足网络信息发布的需要，与它“同级”的有：XHTML\CSS\ECMAScript等。它包含DTD、XSD、XPath、XSL等一大堆复杂的规范，在数据存储、扩展及高级检索等方面都有作用。后来被用于网络数据交换，颇有点大材小用的意思，虽然可胜任，却也有点复杂和冗余。</p>
<p>而JSON是ECMAScript标准的子集，设计之初就是为了克服XML在数据交换上的劣势，所以一方面，它像XML一样具有简洁而清晰的层次结构，另一方面，它比XML小巧精致，更加适用于网络数据的传输。</p>
<p>JSON也不是没有缺点，当结构层级很多的时候，它会让人陷入繁琐复杂的数据节点查找中，在可读性上要比XML差。</p>
<h2 id="将Python对象编码成JSON字符串"><a href="#将Python对象编码成JSON字符串" class="headerlink" title="将Python对象编码成JSON字符串"></a>将Python对象编码成JSON字符串</h2><p>将python的对象转化为字符串，这个过程也称为序列化，与之相对，将JSON字符串转化为python对象，这个过程被称为反序列化。</p>
<p>序列化格式如下，json.dumps()把python对象序列化，json.dump() 先序列化，然后将内容存入文件：</p>
<ul>
<li>json.dumps(obj, *, skipkeys=False, ensure_ascii=True, check_circular=True, allow_nan=True, cls=None, indent=None, separators=None, default=None, sort_keys=False, **kw)</li>
<li>json.dump(obj, fp, *, skipkeys=False, ensure_ascii=True, check_circular=True, allow_nan=True, cls=None, indent=None, separators=None, default=None, sort_keys=False, **kw)<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">In [1]: import json</span><br><span class="line">In [2]: d = dict(name=&apos;Tom&apos;, age=&apos;8&apos;, score=88)</span><br><span class="line">In [3]: json.dumps(d)</span><br><span class="line">Out[3]: &apos;&#123;&quot;name&quot;: &quot;Tom&quot;, &quot;age&quot;: &quot;8&quot;, &quot;score&quot;: 88&#125;&apos;</span><br><span class="line">In [4]: with open(&apos;test.json&apos;, &apos;w&apos;) as f:</span><br><span class="line">   ...:     json.dump(d, f)</span><br></pre></td></tr></table></figure>
</li>
</ul>
<p>用的比较多的参数有：</p>
<ul>
<li>ensure_ascii=True 设置是否编码为ASCII，默认是，若False，则使用原编码格式</li>
<li>indent=None 设置打印时缩进，默认不缩进</li>
<li>separators=None 设置分隔符，取值是(item_separator, dict_separator)元组，默认为(‘,’,’:’)，这表示keys之间用“,”隔开，而key和value之间用“:”隔开</li>
<li>sort_keys=False  设置按key值排序，默认不排序<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">In [15]: d = dict(name=&apos;Python猫&apos;, age=&apos;8&apos;, score=88)</span><br><span class="line"></span><br><span class="line">In [16]: json.dumps(d)</span><br><span class="line">Out[16]: &apos;&#123;&quot;name&quot;: &quot;Python\\u732b&quot;, &quot;age&quot;: &quot;8&quot;, &quot;score&quot;: 88&#125;&apos;</span><br><span class="line"></span><br><span class="line">In [17]: json.dumps(d, ensure_ascii=False, indent=4, sort_keys=True)</span><br><span class="line">Out[17]: &apos;&#123;\n    &quot;age&quot;: &quot;8&quot;,\n    &quot;name&quot;: &quot;Python猫&quot;,\n    &quot;score&quot;: 88\n&#125;&apos;</span><br><span class="line"></span><br><span class="line">In [18]: print(json.dumps(d, ensure_ascii=False, indent=4, sort_keys=True))</span><br><span class="line">&#123;</span><br><span class="line">    &quot;age&quot;: &quot;8&quot;,</span><br><span class="line">    &quot;name&quot;: &quot;Python猫&quot;,</span><br><span class="line">    &quot;score&quot;: 88</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ul>
<h2 id="将已编码的JSON字符串解码为Python对象"><a href="#将已编码的JSON字符串解码为Python对象" class="headerlink" title="将已编码的JSON字符串解码为Python对象"></a>将已编码的JSON字符串解码为Python对象</h2><p>反序列化格式如下，json.loads()从内存中读取内容解析，json.load() 从文件中读取内容解析：</p>
<ul>
<li>json.loads(s, *, encoding=None, cls=None, object_hook=None, parse_float=None, parse_int=None, parse_constant=None, object_pairs_hook=None, **kw)</li>
<li>json.load(fp, *, cls=None, object_hook=None, parse_float=None, parse_int=None, parse_constant=None, object_pairs_hook=None, **kw)<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">In [1]: import json</span><br><span class="line">In [2]: d = dict(name=&apos;Tom&apos;, age=&apos;8&apos;, score=88)</span><br><span class="line">In [3]: tom_json = json.dumps(d)</span><br><span class="line">In [4]: json.loads(tom_json)</span><br><span class="line">Out[4]: &#123;&apos;age&apos;: &apos;8&apos;, &apos;name&apos;: &apos;Tom&apos;, &apos;score&apos;: 88&#125;</span><br><span class="line">In [5]: with open(&apos;test.json&apos;, &apos;r&apos;) as f:</span><br><span class="line">   ...:     print(json.load(f))</span><br><span class="line">&#123;&apos;name&apos;: &apos;Tom&apos;, &apos;age&apos;: &apos;8&apos;, &apos;score&apos;: 88&#125;</span><br></pre></td></tr></table></figure>
</li>
</ul>
<p>json.loads()比json.load() 多了一个encoding参数，可以将传入的字符串重新编码。</p>
<h2 id="解决中文乱码问题"><a href="#解决中文乱码问题" class="headerlink" title="解决中文乱码问题"></a>解决中文乱码问题</h2><p>序列化的ensure_ascii参数与反序列化的encoding相对应，都是处理字符编码，一旦处理不好，就会导致中文乱码问题。</p>
<p>Python2的字符编码乱七八糟，也广被人诟病，如果不幸遇到Python2项目，可参照如下例子解决。字符串在Python2内部的表示是unicode编码。因此，在做编码转换时，需要以unicode作为中间编码，即先将其他编码的字符串解码（decode）成unicode，再从unicode编码（encode）成另一种编码。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"># -*- coding: utf-8 -*-</span><br><span class="line">m = &#123;&apos;a&apos; : &apos;你好&apos;&#125;</span><br><span class="line"></span><br><span class="line">print m</span><br><span class="line">=&gt;&#123;&apos;a&apos;: &apos;\xe4\xbd\xa0\xe5\xa5\xbd&apos;&#125;</span><br><span class="line"></span><br><span class="line">print json.dumps(m)</span><br><span class="line">=&gt;&#123;&quot;a&quot;: &quot;\u4f60\u597d&quot;&#125;</span><br><span class="line"></span><br><span class="line">print json.dumps(m,ensure_ascii=False)</span><br><span class="line">=&gt;&#123;&quot;a&quot;: &quot;浣犲ソ&quot;&#125;</span><br><span class="line"></span><br><span class="line">print json.dumps(m,ensure_ascii=False).decode(&apos;utf8&apos;).encode(&apos;gb2312&apos;)</span><br><span class="line">=&gt;&#123;&quot;a&quot;: &quot;你好&quot;&#125;</span><br></pre></td></tr></table></figure>
<p>Python3的默认编码格式是utf-8，以上例子，只需要ensure_ascii=False，就能解决。</p>
<p>-—————-</p>
<p>本文原创并首发于微信公众号【Python猫】，后台回复“爱学习”，免费获得20本精选电子书。</p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://chinesehuazhou.github.io/2019/05/03/如何给列表降维？sum()函数的妙用/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="John Doe">
      <meta itemprop="description" content>
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="豌豆花下猫">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2019/05/03/如何给列表降维？sum()函数的妙用/" itemprop="url">未命名</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2019-05-03T21:21:22+08:00">
                2019-05-03
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="如何给列表降维？sum-函数的妙用"><a href="#如何给列表降维？sum-函数的妙用" class="headerlink" title="如何给列表降维？sum()函数的妙用"></a>如何给列表降维？sum()函数的妙用</h1><p>上个月，学习群里的 S 同学问了个题目，大意可理解为<code>列表降维</code> ，例子如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">oldlist = [[1, 2, 3], [4, 5]]</span><br><span class="line"></span><br><span class="line"># 想得到结果：</span><br><span class="line">newlist = [1, 2, 3, 4, 5]</span><br></pre></td></tr></table></figure>
<p>原始数据是一个二维列表，目的是获取该列表中所有元素的具体值。从抽象一点的角度来理解，也可看作是列表解压或者列表降维。</p>
<p>这个问题并不难，但是，怎么写才比较优雅呢？</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"># 方法一，粗暴拼接法：</span><br><span class="line">newlist = oldlist[0] + oldlist[1]</span><br></pre></td></tr></table></figure>
<p>这种方法简单粗暴，需要拼接什么内容，就取出来直接拼接。然而，如果原列表有很多子列表，则这个方法就会变得繁琐了。</p>
<p>我们把原问题升级一下：<strong>一个二维列表包含 n 个一维列表元素，如何优雅地把这些子列表拼成一个新的一维列表？</strong> </p>
<p>方法一的做法需要写 n 个对象，以及 n - 1 次拼接操作。当然不可行。下面看看方法二：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"># 方法二，列表推导式：</span><br><span class="line">newlist = [i for j in range(len(oldlist)) for i in oldlist[j]]</span><br></pre></td></tr></table></figure>
<p>这个表达式中出现了两个 for 语句，在第一个 for 语句中，我们先取出原列表的长度，然后构造 range 对象，此时 j 的取值范围是 [0, n-1] 的闭区间。</p>
<p>在第二个 for 语句中，oldlist[j] 指的正是原列表的第 j 个子列表，<code>for i in oldlist[j]</code> 则会遍历取出 j 子列表的元素，由于 j 取值的区间正对应于原列表的全部索引值，所以，最终达到解题目的。</p>
<p>这种方法足够优雅了，而且理解也并不难。</p>
<p>然而，我们是否就能满足于此了呢？有没有其它奇技淫巧，哦不，是其它高级方法呢？F 同学贡献了一个思路：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"># 方法三，巧用sum：</span><br><span class="line">newlist = sum(oldlist,[])</span><br></pre></td></tr></table></figure>
<p>说实话，这个方法令我大感意外！sum() 函数不是用于求和的么？怎么竟然有此用法？</p>
<p>这个写法利用了什么原理呢？由于我开始时不知道 sum() 函数可以接收两个参数，不清楚它们是怎么用于计算的，所以一度很困惑。但是，当我知道 sum() 的完整用法时，我恍然大悟。</p>
<p>接下来也不卖关子了，直接揭晓吧。</p>
<p>语法： <code>sum(iterable[, start])</code> ，sum() 函数的第一个参数是可迭代对象，如列表、元组或集合等，第二个参数是起始值，默认为 0 。其用途是以 start 值为基础，再与可迭代对象的所有元素相“加”。</p>
<p>在上例中，执行效果是 oldlist 中的子列表逐一与第二个参数相加，而列表的加法相当于 extend 操作，所以最终结果是由 [] 扩充成的列表。</p>
<p>这里有两个关键点：<strong>sum() 函数允许带两个参数，且第二个参数才是起点。</strong> 可能 sum() 函数用于数值求和比较多，然而用于作列表的求和，就有奇效。它比列表推导式更加优雅简洁！</p>
<p>至此，前面的升级版问题就得到了很好的回答。简单回顾一下，s 同学最初的问题可以用三种方法实现，第一种方法中规中矩，第二种方法正道进阶，而第三种方法旁门左道（没有贬义，只是说它出人意料，却效果奇佳）。</p>
<p>这道并不算难的问题，在众人的讨论与分享后，竟还引出了很有价值的学习内容。前不久，同样是群内的一个问题，也产生了同样的学习效果，详见《<a href="https://mp.weixin.qq.com/s/4eWQmJ15QZabNViePCDmNw" target="_blank" rel="noopener">Python进阶：如何将字符串常量转为变量？</a>》。</p>
<p>我从中得到了一个启示：<strong>应该多角度地思考问题，设法寻求更优解，同时，基础知识应掌握牢固，并灵活贯通起来。</strong> </p>
<p>学无止境，这里我还想再开拓一下思路，看看能发现些什么。</p>
<p>1、如果原列表的元素除了列表，还有其它类型的元素，怎么把同类的元素归并在一起呢？</p>
<p>2、如果是一个三维或更高维的列表，怎么更好地把它们压缩成一维列表呢？</p>
<p>3、sum() 函数还有什么知识要点呢？</p>
<p>前两个问题增加了复杂度，解决起来似乎没有“灵丹妙药”了，只能用笨方法分别拆解，逐一解压。</p>
<p>第三个思考题是关于 sum() 函数本身的用法，我们看看官方文档是怎么说的：</p>
<blockquote>
<p>The <em>iterable</em>’s items are normally numbers, and the start value is not allowed to be a string.</p>
<p>For some use cases, there are good alternatives to <a href="https://docs.python.org/3/library/functions.html#sum" target="_blank" rel="noopener"><code>sum()</code></a>. The preferred, fast way to concatenate a sequence of strings is by calling <code>&#39;&#39;.join(sequence)</code>. To add floating point values with extended precision, see <a href="https://docs.python.org/3/library/math.html#math.fsum" target="_blank" rel="noopener"><code>math.fsum()</code></a>. To concatenate a series of iterables, consider using <a href="https://docs.python.org/3/library/itertools.html#itertools.chain" target="_blank" rel="noopener"><code>itertools.chain()</code></a>.</p>
</blockquote>
<p>sum() 的第二个参数不允许是字符串。如果用了，会报错：</p>
<blockquote>
<p>TypeError: sum() can’t sum strings [use ‘’.join(seq) instead]</p>
</blockquote>
<p>为什么不建议使用 sum() 来拼接字符串呢？哈哈，文档中建议使用 join() 方法，因为它更快。为了不给我们使用慢的方法，它竟特别限定不允许 sum() 的第二个参数是字符串。</p>
<p>文档还建议，在某些使用场景时，不要用 sum() ，例如当以扩展精度对浮点数求和时，推荐使用 <code>math.fsum()</code> ；当要拼接一系列的可迭代对象时，应考虑使用 <code>itertools.chain()</code> 。</p>
<p>浮点数的计算是个难题，我曾转载过一篇《<a href="https://mp.weixin.qq.com/s/4Se4j-_N0cXiWvoQSRHp1w" target="_blank" rel="noopener">如何在 Python 里面精确四舍五入？</a>》，对此有精彩分析。而<code>itertools.chain()</code> 可以将不同类型的可迭代对象串联成一个更大的迭代器，这在旧文《<a href="https://mp.weixin.qq.com/s/7MbRCn37fIIN42rLm6ho3g" target="_blank" rel="noopener">Python进阶：设计模式之迭代器模式</a>》中也有论及。</p>
<p>不经意间，sum() 函数的注意事项，竟把 Python 其它的进阶内容都联系起来了。小小的函数，竟成为学习之路上的一个枢纽。</p>
<p>前段时间，我还写过 range() 、locals() 和 eval() 等内置函数，也是通过一个问题点，而关联出多个知识点， 获益良多。这些内置函数/类的魔力可真不小啊。</p>
<p>本文到此结束，希望对你有所帮助。</p>
<p>本文原创并首发于公众号【<strong>Python猫</strong>】，未经授权，请勿转载。</p>
<p>原文地址：<a href="https://mp.weixin.qq.com/s/cr_noDx6s1sZ6Xt6PDpDVQ" target="_blank" rel="noopener">https://mp.weixin.qq.com/s/cr_noDx6s1sZ6Xt6PDpDVQ</a></p>
<p><img src="http://ww1.sinaimg.cn/large/68b02e3bly1g2aiq1kpa8j21hc0nmgs4.jpg" alt></p>
<p>公众号【<strong>Python猫</strong>】， 本号连载优质的系列文章，有喵星哲学猫系列、Python进阶系列、好书推荐系列、技术写作、优质英文推荐与翻译等等，欢迎关注哦。后台回复“<strong>爱学习</strong>”，免费获得一份学习大礼包。</p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
  </section>

  
  <nav class="pagination">
    <a class="extend prev" rel="prev" href="/page/2/"><i class="fa fa-angle-left"></i></a><a class="page-number" href="/">1</a><a class="page-number" href="/page/2/">2</a><span class="page-number current">3</span><a class="page-number" href="/page/4/">4</a><a class="page-number" href="/page/5/">5</a><a class="extend next" rel="next" href="/page/4/"><i class="fa fa-angle-right"></i></a>
  </nav>



          </div>
          


          

        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    
    <div class="sidebar-inner">

      

      

      <section class="site-overview-wrap sidebar-panel sidebar-panel-active">
        <div class="site-overview">
          <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
            
              <p class="site-author-name" itemprop="name">John Doe</p>
              <p class="site-description motion-element" itemprop="description"></p>
          </div>

          <nav class="site-state motion-element">

            
              <div class="site-state-item site-state-posts">
              
                <a href="/archives/">
              
                  <span class="site-state-item-count">44</span>
                  <span class="site-state-item-name">日志</span>
                </a>
              </div>
            

            

            

          </nav>

          

          

          
          

          
          

          

        </div>
      </section>

      

      

    </div>
  </aside>


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright">&copy; <span itemprop="copyrightYear">2019</span>
  <span class="with-love">
    <i class="fa fa-user"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">John Doe</span>

  
</div>


  <div class="powered-by">由 <a class="theme-link" target="_blank" href="https://hexo.io">Hexo</a> 强力驱动</div>



  <span class="post-meta-divider">|</span>



  <div class="theme-info">主题 &mdash; <a class="theme-link" target="_blank" href="https://github.com/iissnan/hexo-theme-next">NexT.Muse</a> v5.1.4</div>




        







        
      </div>
    </footer>

    
      <div class="back-to-top">
        <i class="fa fa-arrow-up"></i>
        
      </div>
    

    

  </div>

  

<script type="text/javascript">
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>









  












  
  
    <script type="text/javascript" src="/lib/jquery/index.js?v=2.1.3"></script>
  

  
  
    <script type="text/javascript" src="/lib/fastclick/lib/fastclick.min.js?v=1.0.6"></script>
  

  
  
    <script type="text/javascript" src="/lib/jquery_lazyload/jquery.lazyload.js?v=1.9.7"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/fancybox/source/jquery.fancybox.pack.js?v=2.1.5"></script>
  


  


  <script type="text/javascript" src="/js/src/utils.js?v=5.1.4"></script>

  <script type="text/javascript" src="/js/src/motion.js?v=5.1.4"></script>



  
  

  

  


  <script type="text/javascript" src="/js/src/bootstrap.js?v=5.1.4"></script>



  


  




	





  





  












  





  

  

  

  
  

  

  

  

</body>
</html>
