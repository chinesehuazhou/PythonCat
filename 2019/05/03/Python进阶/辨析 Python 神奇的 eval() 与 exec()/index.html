<!DOCTYPE html>



  


<html class="theme-next muse use-motion" lang="zh-Hans">
<head><meta name="generator" content="Hexo 3.8.0">
  <meta charset="UTF-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
<meta name="theme-color" content="#222">









<meta http-equiv="Cache-Control" content="no-transform">
<meta http-equiv="Cache-Control" content="no-siteapp">
















  
  
  <link href="/lib/fancybox/source/jquery.fancybox.css?v=2.1.5" rel="stylesheet" type="text/css">







<link href="/lib/font-awesome/css/font-awesome.min.css?v=4.6.2" rel="stylesheet" type="text/css">

<link href="/css/main.css?v=5.1.4" rel="stylesheet" type="text/css">


  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png?v=5.1.4">


  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png?v=5.1.4">


  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png?v=5.1.4">


  <link rel="mask-icon" href="/images/logo.svg?v=5.1.4" color="#222">





  <meta name="keywords" content="Hexo, NexT">










<meta name="description" content="深度辨析 Python 的 eval() 与 exec()Python 提供了很多内置的工具函数（Built-in Functions），在最新的 Python 3 官方文档中，它列出了 69 个。 大部分函数是我们经常使用的，例如 print()、open() 与 dir()，而有一些函数虽然不常用，但它们在某些场景下，却能发挥出不一般的作用。内置函数们能够被“提拔”出来，这就意味着它们皆有独到">
<meta property="og:type" content="article">
<meta property="og:title" content="豌豆花下猫">
<meta property="og:url" content="https://chinesehuazhou.github.io/2019/05/03/Python进阶/辨析 Python 神奇的 eval() 与 exec()/index.html">
<meta property="og:site_name" content="豌豆花下猫">
<meta property="og:description" content="深度辨析 Python 的 eval() 与 exec()Python 提供了很多内置的工具函数（Built-in Functions），在最新的 Python 3 官方文档中，它列出了 69 个。 大部分函数是我们经常使用的，例如 print()、open() 与 dir()，而有一些函数虽然不常用，但它们在某些场景下，却能发挥出不一般的作用。内置函数们能够被“提拔”出来，这就意味着它们皆有独到">
<meta property="og:locale" content="zh-Hans">
<meta property="og:image" content="http://ww1.sinaimg.cn/large/68b02e3bgy1g08dfkg8sdj2076076t96.jpg">
<meta property="og:updated_time" content="2019-03-24T14:39:49.781Z">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="豌豆花下猫">
<meta name="twitter:description" content="深度辨析 Python 的 eval() 与 exec()Python 提供了很多内置的工具函数（Built-in Functions），在最新的 Python 3 官方文档中，它列出了 69 个。 大部分函数是我们经常使用的，例如 print()、open() 与 dir()，而有一些函数虽然不常用，但它们在某些场景下，却能发挥出不一般的作用。内置函数们能够被“提拔”出来，这就意味着它们皆有独到">
<meta name="twitter:image" content="http://ww1.sinaimg.cn/large/68b02e3bgy1g08dfkg8sdj2076076t96.jpg">



<script type="text/javascript" id="hexo.configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '/',
    scheme: 'Muse',
    version: '5.1.4',
    sidebar: {"position":"left","display":"post","offset":12,"b2t":false,"scrollpercent":false,"onmobile":false},
    fancybox: true,
    tabs: true,
    motion: {"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},
    duoshuo: {
      userId: '0',
      author: '博主'
    },
    algolia: {
      applicationID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    }
  };
</script>



  <link rel="canonical" href="https://chinesehuazhou.github.io/2019/05/03/Python进阶/辨析 Python 神奇的 eval() 与 exec()/">





  <title> | 豌豆花下猫</title>
  








</head>

<body itemscope itemtype="http://schema.org/WebPage" lang="zh-Hans">

  
  
    
  

  <div class="container sidebar-position-left page-post-detail">
    <div class="headband"></div>

    <header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-wrapper">
  <div class="site-meta ">
    

    <div class="custom-logo-site-title">
      <a href="/" class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">豌豆花下猫</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
      
        <p class="site-subtitle"></p>
      
  </div>

  <div class="site-nav-toggle">
    <button>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
    </button>
  </div>
</div>

<nav class="site-nav">
  

  
    <ul id="menu" class="menu">
      
        
        <li class="menu-item menu-item-home">
          <a href="/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-home"></i> <br>
            
            首页
          </a>
        </li>
      
        
        <li class="menu-item menu-item-archives">
          <a href="/archives/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-archive"></i> <br>
            
            归档
          </a>
        </li>
      

      
    </ul>
  

  
</nav>



 </div>
    </header>

    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          <div id="content" class="content">
            

  <div id="posts" class="posts-expand">
    

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://chinesehuazhou.github.io/2019/05/03/Python进阶/辨析 Python 神奇的 eval() 与 exec()/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="John Doe">
      <meta itemprop="description" content>
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="豌豆花下猫">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline"></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2019-05-03T21:21:22+08:00">
                2019-05-03
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        <h1 id="深度辨析-Python-的-eval-与-exec"><a href="#深度辨析-Python-的-eval-与-exec" class="headerlink" title="深度辨析 Python 的 eval() 与 exec()"></a>深度辨析 Python 的 eval() 与 exec()</h1><p>Python 提供了很多内置的工具函数（Built-in Functions），在最新的 Python 3 官方文档中，它列出了 69 个。</p>
<p>大部分函数是我们经常使用的，例如 print()、open() 与 dir()，而有一些函数虽然不常用，但它们在某些场景下，却能发挥出不一般的作用。内置函数们能够被“提拔”出来，这就意味着它们皆有独到之处，有用武之地。</p>
<p>因此，掌握内置函数的用法，就成了我们应该点亮的技能。</p>
<p>在《<a href="https://mp.weixin.qq.com/s/4eWQmJ15QZabNViePCDmNw" target="_blank" rel="noopener">Python进阶：如何将字符串常量转为变量？</a>》这篇文章中，我提到过 eval() 和 exec() ，但对它们并不太了解。为了弥补这方面知识，我就重新学习了下。这篇文章是一份超级详细的学习记录，系统、全面而深入地辨析了这两大函数。</p>
<h2 id="1、eval-的基本用法"><a href="#1、eval-的基本用法" class="headerlink" title="1、eval 的基本用法"></a>1、eval 的基本用法</h2><p>语法：eval(<em>expression</em>, <em>globals=None</em>, <em>locals=None</em>)</p>
<p>它有三个参数，其中 expression 是一个字符串类型的表达式或代码对象，用于做运算；globals 与 locals  是可选参数，默认值是 None。</p>
<p>具体而言，expression 只能是单个表达式，不支持复杂的代码逻辑，例如赋值操作、循环语句等等。（PS：单个表达式并不意味着“简单无害”，参见下文第 4 节）</p>
<p>globals 用于指定运行时的全局命名空间，类型是字典，缺省时使用的是当前模块的内置命名空间。locals 指定运行时的局部命名空间，类型是字典，缺省时使用 globals 的值。两者都缺省时，则遵循 eval 函数执行时的作用域。值得注意的是，这两者不代表真正的命名空间，只在运算时起作用，运算后则销毁。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">x = 10</span><br><span class="line"></span><br><span class="line">def func():</span><br><span class="line">    y = 20</span><br><span class="line">    a = eval(&apos;x + y&apos;)</span><br><span class="line">    print(&apos;a: &apos;, a)</span><br><span class="line">    b = eval(&apos;x + y&apos;, &#123;&apos;x&apos;: 1, &apos;y&apos;: 2&#125;)</span><br><span class="line">    print(&apos;x: &apos; + str(x) + &apos; y: &apos; + str(y))</span><br><span class="line">    print(&apos;b: &apos;, b)</span><br><span class="line">    c = eval(&apos;x + y&apos;, &#123;&apos;x&apos;: 1, &apos;y&apos;: 2&#125;, &#123;&apos;y&apos;: 3, &apos;z&apos;: 4&#125;)</span><br><span class="line">    print(&apos;x: &apos; + str(x) + &apos; y: &apos; + str(y))</span><br><span class="line">    print(&apos;c: &apos;, c)</span><br><span class="line"></span><br><span class="line">func()</span><br></pre></td></tr></table></figure>
<p>输出结果：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">a:  30</span><br><span class="line">x: 10 y: 20</span><br><span class="line">b:  3</span><br><span class="line">x: 10 y: 20</span><br><span class="line">c:  4</span><br></pre></td></tr></table></figure>
<p>由此可见，当指定了命名空间的时候，变量会在对应命名空间中查找。而且，它们的值不会覆盖实际命名空间中的值。</p>
<h2 id="2、exec-的基本用法"><a href="#2、exec-的基本用法" class="headerlink" title="2、exec 的基本用法"></a>2、exec 的基本用法</h2><p>语法：exec(<em>object</em>[, <em>globals</em>[, <em>locals</em>]])</p>
<p>在 Python2 中 exec 是个语句，而 Python3 将其改造成一个函数，就像 print 一样。exec() 与 eval() 高度相似，三个参数的意义和作用相近。</p>
<p>主要的区别是，exec() 的第一个参数不是表达式，而是代码块，这意味着两点：一是它不能做表达式求值并返回出去，二是它可以执行复杂的代码逻辑，相对而言功能更加强大，例如，当代码块中赋值了新的变量时，该变量<strong>可能</strong> 在函数外的命名空间中存活下来。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; x = 1</span><br><span class="line">&gt;&gt;&gt; y = exec(&apos;x = 1 + 1&apos;)</span><br><span class="line">&gt;&gt;&gt; print(x)</span><br><span class="line">&gt;&gt;&gt; print(y)</span><br><span class="line">2</span><br><span class="line">None</span><br></pre></td></tr></table></figure>
<p>可以看出，exec() 内外的命名空间是相通的，变量由此传递出去，而不像 eval() 函数，需要一个变量来接收函数的执行结果。</p>
<h2 id="3、一些细节辨析"><a href="#3、一些细节辨析" class="headerlink" title="3、一些细节辨析"></a>3、一些细节辨析</h2><p>两个函数都很强大，它们将字符串内容当做有效的代码执行。这是一种<strong>字符串驱动的事件</strong> ，意义重大。然而，在实际使用过程中，存在很多微小的细节，此处就列出我所知道的几点吧。</p>
<p>常见用途：将字符串转成相应的对象，例如 string 转成 list ，string 转成 dict，string 转 tuple 等等。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; a = &quot;[[1,2], [3,4], [5,6], [7,8], [9,0]]&quot;</span><br><span class="line">&gt;&gt;&gt; print(eval(a))</span><br><span class="line">[[1, 2], [3, 4], [5, 6], [7, 8], [9, 0]]</span><br><span class="line">&gt;&gt;&gt; a = &quot;&#123;&apos;name&apos;: &apos;Python猫&apos;, &apos;age&apos;: 18&#125;&quot;</span><br><span class="line">&gt;&gt;&gt; print(eval(a))</span><br><span class="line">&#123;&apos;name&apos;: &apos;Python猫&apos;, &apos;age&apos;: 18&#125;</span><br><span class="line"></span><br><span class="line"># 与 eval 略有不同</span><br><span class="line">&gt;&gt;&gt; a = &quot;my_dict = &#123;&apos;name&apos;: &apos;Python猫&apos;, &apos;age&apos;: 18&#125;&quot;</span><br><span class="line">&gt;&gt;&gt; exec(a)</span><br><span class="line">&gt;&gt;&gt; print(my_dict)</span><br><span class="line">&#123;&apos;name&apos;: &apos;Python猫&apos;, &apos;age&apos;: 18&#125;</span><br></pre></td></tr></table></figure>
<p>eval() 函数的返回值是其 expression 的执行结果，在某些情况下，它会是 None，例如当该表达式是 print() 语句，或者是列表的 append() 操作时，这类操作的结果是 None，因此 eval() 的返回值也会是 None。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; result = eval(&apos;[].append(2)&apos;)</span><br><span class="line">&gt;&gt;&gt; print(result)</span><br><span class="line">None</span><br></pre></td></tr></table></figure>
<p>exec() 函数的返回值只会是 None，与执行语句的结果无关，所以，将 exec() 函数赋值出去，就没有任何必要。所执行的语句中，如果包含 return 或 yield ，它们产生的值也无法在 exec 函数的外部起作用。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; result = exec(&apos;1 + 1&apos;)</span><br><span class="line">&gt;&gt;&gt; print(result)</span><br><span class="line">None</span><br></pre></td></tr></table></figure>
<p>两个函数中的 globals 和 locals 参数，起到的是白名单的作用，通过限定命名空间的范围，防止作用域内的数据被滥用。</p>
<p>conpile() 函数编译后的 code 对象，可作为 eval 和 exec 的第一个参数。compile() 也是个神奇的函数，我翻译的上一篇文章《<a href="https://mp.weixin.qq.com/s/o-HuE3VxgHedfe8X5fUrMA" target="_blank" rel="noopener">Python骚操作：动态定义函数</a>》就演示了一个动态定义函数的操作。</p>
<p>吊诡的局部命名空间：前面讲到了 exec() 函数内的变量是可以改变原有命名空间的，然而也有例外。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">def foo():</span><br><span class="line">    exec(&apos;y = 1 + 1\nprint(y)&apos;)</span><br><span class="line">    print(locals())</span><br><span class="line">    print(y)</span><br><span class="line"></span><br><span class="line">foo()</span><br></pre></td></tr></table></figure>
<p>按照前面的理解，预期的结果是局部变量中会存入变量 y，因此两次的打印结果都会是 2，然而实际上的结果却是：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">2</span><br><span class="line">&#123;&apos;y&apos;: 2&#125;</span><br><span class="line">Traceback (most recent call last):</span><br><span class="line">...(略去部分报错信息)</span><br><span class="line">    print(y)</span><br><span class="line">NameError: name &apos;y&apos; is not defined</span><br></pre></td></tr></table></figure>
<p>明明看到了局部命名空间中有变量 y，为何会报错说它未定义呢？</p>
<p>原因与 Python 的编译器有关，对于以上代码，编译器会先将 foo 函数解析成一个 ast（抽象语法树），然后将所有变量节点存入栈中，此时 exec() 的参数只是一个字符串，整个就是常量，并没有作为代码执行，因此 y 还不存在。直到解析第二个 print() 时，此时第一次出现变量 y ，但因为没有完整的定义，所以 y 不会被存入局部命名空间。</p>
<p>在运行期，exec() 函数动态地创建了局部变量 y ，然而由于 Python 的实现机制是“<strong>运行期的局部命名空间不可改变</strong> ”，也就是说这时的 y 始终无法成为局部命名空间的一员，当执行 print() 时也就报错了。</p>
<p>至于为什么 locals() 取出的结果有 y，为什么它不能代表真正的局部命名空间？为什么局部命名空间无法被动态修改？可以查看我之前分享的《<a href="https://mp.weixin.qq.com/s/f9BBe2W1X1p7NcHg665I4A" target="_blank" rel="noopener">Python 动态赋值的陷阱</a>》，另外，官方的 bug 网站中也有对此问题的讨论，查看地址：<a href="https://bugs.python.org/issue4831" target="_blank" rel="noopener">https://bugs.python.org/issue4831</a></p>
<p>若想把 exec() 执行后的 y 取出来的话，可以这样：<code>z = locals()[&#39;y&#39;]</code> ，然而如果不小心写成了下面的代码，则会报错：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">def foo():</span><br><span class="line">    exec(&apos;y = 1 + 1&apos;)</span><br><span class="line">    y = locals()[&apos;y&apos;]</span><br><span class="line">    print(y)</span><br><span class="line">    </span><br><span class="line">foo()</span><br><span class="line"></span><br><span class="line">#报错：KeyError: &apos;y&apos;</span><br><span class="line">#把变量 y 改为其它变量则不会报错</span><br></pre></td></tr></table></figure>
<p><code>KeyError</code> 指的是在字典中不存在对应的 key 。本例中 y 作了声明，却因为循环引用而无法完成赋值，即 key 值对应的 value 是个无效值，因此读取不到，就报错了。</p>
<p>此例还有 4 个变种，我想用一套自恰的说法来解释它们，但尝试了很久，未果。留个后话吧，等我想明白，再单独写一篇文章。</p>
<h2 id="4、为什么要慎用-eval-？"><a href="#4、为什么要慎用-eval-？" class="headerlink" title="4、为什么要慎用 eval() ？"></a>4、为什么要慎用 eval() ？</h2><p>很多动态的编程语言中都会有 eval() 函数，作用大同小异，但是，无一例外，人们会告诉你说，避免使用它。</p>
<p>为什么要慎用 eval() 呢？主要出于安全考虑，对于不可信的数据源，eval 函数很可能会招来代码注入的问题。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; eval(&quot;__import__(&apos;os&apos;).system(&apos;whoami&apos;)&quot;)</span><br><span class="line">desktop-fa4b888\pythoncat</span><br><span class="line">&gt;&gt;&gt; eval(&quot;__import__(&apos;subprocess&apos;).getoutput(&apos;ls ~&apos;)&quot;)</span><br><span class="line">#结果略，内容是当前路径的文件信息</span><br></pre></td></tr></table></figure>
<p>在以上例子中，我的隐私数据就被暴露了。而更可怕的是，如果将命令改为<code>rm -rf ~</code> ，那当前目录的所有文件都会被删除干净。</p>
<p>针对以上例子，有一个限制的办法，即指定 globals 为 <code>{&#39;__builtins__&#39;: None}</code> 或者 <code>{&#39;__builtins__&#39;: {}}</code> 。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; s = &#123;&apos;__builtins__&apos;: None&#125;</span><br><span class="line">&gt;&gt;&gt; eval(&quot;__import__(&apos;os&apos;).system(&apos;whoami&apos;)&quot;, s)</span><br><span class="line">#报错：TypeError: &apos;NoneType&apos; object is not subscriptable</span><br></pre></td></tr></table></figure>
<p><code>__builtins__</code> 包含了内置命名空间中的名称，在控制台中输入 dir(__builtins__) ，就能发现很多内置函数、异常和其它属性的名称。在默认情况下，eval 函数的 globals 参数会隐式地携带<code>__builtins__</code> ，即使是令 globals 参数为 {} 也如此，所以如果想要禁用它，就得显式地指定它的值。</p>
<p>上例将它映射成 None，就意味着限定了 eval 可用的内置命名空间为 None，从而限制了表达式调用内置模块或属性的能力。</p>
<p>但是，这个办法还不是万无一失的，因为仍有手段可以发起攻击。</p>
<p>某位漏洞挖掘高手在他的博客中分享了一个思路，令人大开眼界。其核心的代码是下面这句，你可以试试执行，看看输出的是什么内容。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; ().__class__.__bases__[0].__subclasses__()</span><br></pre></td></tr></table></figure>
<p>关于这句代码的解释，以及更进一步的利用手段，详见博客。（地址：<a href="https://www.tuicool.com/articles/jeaqe2n）" target="_blank" rel="noopener">https://www.tuicool.com/articles/jeaqe2n）</a></p>
<p>另外还有一篇博客，不仅提到了上例的手段，还提供了一种新的思路：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">#警告：千万不要执行如下代码，后果自负。</span><br><span class="line">&gt;&gt;&gt; eval(&apos;(lambda fc=(lambda n: [c 1=&quot;c&quot; 2=&quot;in&quot; 3=&quot;().__class__.__bases__[0&quot; language=&quot;for&quot;][/c].__subclasses__() if c.__name__ == n][0]):fc(&quot;function&quot;)(fc(&quot;code&quot;)(0,0,0,0,&quot;KABOOM&quot;,(),(),(),&quot;&quot;,&quot;&quot;,0,&quot;&quot;),&#123;&#125;)())()&apos;, &#123;&quot;__builtins__&quot;:None&#125;)</span><br></pre></td></tr></table></figure>
<p>这行代码会导致 Python 直接 crash 掉。具体分析在：<a href="https://segmentfault.com/a/1190000011532358" target="_blank" rel="noopener">https://segmentfault.com/a/1190000011532358</a></p>
<p>除了黑客的手段，简单的内容也能发起攻击。像下例这样的写法， 将在短时间内耗尽服务器的计算资源。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; eval(&quot;2 ** 888888888&quot;, &#123;&quot;__builtins__&quot;:None&#125;, &#123;&#125;)</span><br></pre></td></tr></table></figure>
<p>如上所述，我们直观地展示了 eval() 函数的危害性，然而，即使是 Python 高手们小心谨慎地使用，也不能保证不出错。</p>
<p>在官方的 dumbdbm 模块中，曾经（2014年）发现一个安全漏洞，攻击者通过伪造数据库文件，可以在调用 eval() 时发起攻击。（详情：<a href="https://bugs.python.org/issue22885）" target="_blank" rel="noopener">https://bugs.python.org/issue22885）</a></p>
<p>无独有偶，在上个月（2019.02），有核心开发者针对 Python 3.8 也提出了一个安全问题，提议不在 logging.config 中使用 eval() 函数，目前该问题还是 open 状态。（详情：<a href="https://bugs.python.org/issue36022）" target="_blank" rel="noopener">https://bugs.python.org/issue36022）</a></p>
<p>如此种种，足以说明为什么要慎用 eval() 了。同理可证，exec() 函数也得谨慎使用。</p>
<h2 id="5、安全的替代用法"><a href="#5、安全的替代用法" class="headerlink" title="5、安全的替代用法"></a>5、安全的替代用法</h2><p>既然有种种安全隐患，为什么要创造出这两个内置方法呢？为什么要使用它们呢？</p>
<p>理由很简单，因为 Python 是一门灵活的动态语言。与静态语言不同，动态语言支持动态地产生代码，对于已经部署好的工程，也可以只做很小的局部修改，就实现 bug 修复。</p>
<p>那有什么办法可以相对安全地使用它们呢？</p>
<p>ast 模块的 <code>literal()</code> 是 eval() 的安全替代，与 eval() 不做检查就执行的方式不同，ast.literal() 会先检查表达式内容是否有效合法。它所允许的字面内容如下：</p>
<blockquote>
<p>strings, bytes, numbers, tuples, lists, dicts, sets, booleans, 和 None</p>
</blockquote>
<p>一旦内容非法，则会报错：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">import ast</span><br><span class="line">ast.literal_eval(&quot;__import__(&apos;os&apos;).system(&apos;whoami&apos;)&quot;)</span><br><span class="line"></span><br><span class="line">报错：ValueError: malformed node or string</span><br></pre></td></tr></table></figure>
<p>不过，它也有缺点：AST 编译器的栈深（stack depth）有限，解析的字符串内容太多或太复杂时，可能导致程序崩溃。</p>
<p>至于 exec() ，似乎还没有类似的替代方法，毕竟它本身可支持的内容是更加复杂多样的。</p>
<p>最后是一个建议：搞清楚它们的区别与运行细节（例如前面的局部命名空间内容），谨慎使用，限制可用的命名空间，对数据源作充分校验。</p>
<p><strong>关联阅读：</strong> </p>
<p><a href="https://mp.weixin.qq.com/s/f9BBe2W1X1p7NcHg665I4A" target="_blank" rel="noopener">Python 动态赋值的陷阱</a></p>
<p><a href="https://mp.weixin.qq.com/s/o-HuE3VxgHedfe8X5fUrMA" target="_blank" rel="noopener">Python骚操作：动态定义函数</a></p>
<p><a href="https://mp.weixin.qq.com/s/EsWmCbH3RtL_QpafyMryOw" target="_blank" rel="noopener">Python与家国天下</a></p>
<p><a href="https://mp.weixin.qq.com/s/4eWQmJ15QZabNViePCDmNw" target="_blank" rel="noopener">Python进阶：如何将字符串常量转为变量？</a></p>
<p><a href="https://docs.python.org/3/library/ast.html#ast.literal_eval" target="_blank" rel="noopener">https://docs.python.org/3/library/ast.html#ast.literal_eval</a></p>
<p><img src="http://ww1.sinaimg.cn/large/68b02e3bgy1g08dfkg8sdj2076076t96.jpg" alt></p>
<p>公众号【<strong>Python猫</strong>】， 专注Python技术、数据科学和深度学习，力图创造一个有趣又有用的学习分享平台。本号连载优质的系列文章，有喵星哲学猫系列、Python进阶系列、好书推荐系列、优质英文推荐与翻译等等，欢迎关注哦。PS：后台回复“<strong>爱学习</strong>”，免费获得一份学习大礼包。</p>

      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      
      
      

      
        <div class="post-nav">
          <div class="post-nav-next post-nav-item">
            
              <a href="/2019/05/03/Python进阶/超强汇总：学习Python列表，只需这篇文章就够了/" rel="next" title>
                <i class="fa fa-chevron-left"></i> 
              </a>
            
          </div>

          <span class="post-nav-divider"></span>

          <div class="post-nav-prev post-nav-item">
            
              <a href="/2019/05/03/写作与其它/介绍几款 Python 静态类型检查器/" rel="prev" title>
                 <i class="fa fa-chevron-right"></i>
              </a>
            
          </div>
        </div>
      

      
      
    </footer>
  </div>
  
  
  
  </article>



    <div class="post-spread">
      
    </div>
  </div>


          </div>
          


          

  



        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    
    <div class="sidebar-inner">

      

      
        <ul class="sidebar-nav motion-element">
          <li class="sidebar-nav-toc sidebar-nav-active" data-target="post-toc-wrap">
            文章目录
          </li>
          <li class="sidebar-nav-overview" data-target="site-overview-wrap">
            站点概览
          </li>
        </ul>
      

      <section class="site-overview-wrap sidebar-panel">
        <div class="site-overview">
          <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
            
              <p class="site-author-name" itemprop="name">John Doe</p>
              <p class="site-description motion-element" itemprop="description"></p>
          </div>

          <nav class="site-state motion-element">

            
              <div class="site-state-item site-state-posts">
              
                <a href="/archives/">
              
                  <span class="site-state-item-count">44</span>
                  <span class="site-state-item-name">日志</span>
                </a>
              </div>
            

            

            

          </nav>

          

          

          
          

          
          

          

        </div>
      </section>

      
      <!--noindex-->
        <section class="post-toc-wrap motion-element sidebar-panel sidebar-panel-active">
          <div class="post-toc">

            
              
            

            
              <div class="post-toc-content"><ol class="nav"><li class="nav-item nav-level-1"><a class="nav-link" href="#深度辨析-Python-的-eval-与-exec"><span class="nav-number">1.</span> <span class="nav-text">深度辨析 Python 的 eval() 与 exec()</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#1、eval-的基本用法"><span class="nav-number">1.1.</span> <span class="nav-text">1、eval 的基本用法</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#2、exec-的基本用法"><span class="nav-number">1.2.</span> <span class="nav-text">2、exec 的基本用法</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#3、一些细节辨析"><span class="nav-number">1.3.</span> <span class="nav-text">3、一些细节辨析</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#4、为什么要慎用-eval-？"><span class="nav-number">1.4.</span> <span class="nav-text">4、为什么要慎用 eval() ？</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#5、安全的替代用法"><span class="nav-number">1.5.</span> <span class="nav-text">5、安全的替代用法</span></a></li></ol></li></ol></div>
            

          </div>
        </section>
      <!--/noindex-->
      

      

    </div>
  </aside>


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright">&copy; <span itemprop="copyrightYear">2019</span>
  <span class="with-love">
    <i class="fa fa-user"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">John Doe</span>

  
</div>


  <div class="powered-by">由 <a class="theme-link" target="_blank" href="https://hexo.io">Hexo</a> 强力驱动</div>



  <span class="post-meta-divider">|</span>



  <div class="theme-info">主题 &mdash; <a class="theme-link" target="_blank" href="https://github.com/iissnan/hexo-theme-next">NexT.Muse</a> v5.1.4</div>




        







        
      </div>
    </footer>

    
      <div class="back-to-top">
        <i class="fa fa-arrow-up"></i>
        
      </div>
    

    

  </div>

  

<script type="text/javascript">
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>









  












  
  
    <script type="text/javascript" src="/lib/jquery/index.js?v=2.1.3"></script>
  

  
  
    <script type="text/javascript" src="/lib/fastclick/lib/fastclick.min.js?v=1.0.6"></script>
  

  
  
    <script type="text/javascript" src="/lib/jquery_lazyload/jquery.lazyload.js?v=1.9.7"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/fancybox/source/jquery.fancybox.pack.js?v=2.1.5"></script>
  


  


  <script type="text/javascript" src="/js/src/utils.js?v=5.1.4"></script>

  <script type="text/javascript" src="/js/src/motion.js?v=5.1.4"></script>



  
  

  
  <script type="text/javascript" src="/js/src/scrollspy.js?v=5.1.4"></script>
<script type="text/javascript" src="/js/src/post-details.js?v=5.1.4"></script>



  


  <script type="text/javascript" src="/js/src/bootstrap.js?v=5.1.4"></script>



  


  




	





  





  












  





  

  

  

  
  

  

  

  

</body>
</html>
