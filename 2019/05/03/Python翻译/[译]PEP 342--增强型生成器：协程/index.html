<!DOCTYPE html>



  


<html class="theme-next muse use-motion" lang="zh-Hans">
<head><meta name="generator" content="Hexo 3.8.0">
  <meta charset="UTF-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
<meta name="theme-color" content="#222">









<meta http-equiv="Cache-Control" content="no-transform">
<meta http-equiv="Cache-Control" content="no-siteapp">
















  
  
  <link href="/lib/fancybox/source/jquery.fancybox.css?v=2.1.5" rel="stylesheet" type="text/css">







<link href="/lib/font-awesome/css/font-awesome.min.css?v=4.6.2" rel="stylesheet" type="text/css">

<link href="/css/main.css?v=5.1.4" rel="stylesheet" type="text/css">


  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png?v=5.1.4">


  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png?v=5.1.4">


  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png?v=5.1.4">


  <link rel="mask-icon" href="/images/logo.svg?v=5.1.4" color="#222">





  <meta name="keywords" content="Hexo, NexT">










<meta name="description" content="[译]PEP 342–增强型生成器：协程PEP原文 ： https://www.python.org/dev/peps/pep-0342/ PEP标题： Coroutines via Enhanced Generators PEP作者： Guido van Rossum, Phillip J. Eby 创建日期： 2005-05-10 合入版本： 2.5 译者 ：豌豆花下猫（Python猫 公众号">
<meta property="og:type" content="article">
<meta property="og:title" content="豌豆花下猫">
<meta property="og:url" content="https://chinesehuazhou.github.io/2019/05/03/Python翻译/[译]PEP 342--增强型生成器：协程/index.html">
<meta property="og:site_name" content="豌豆花下猫">
<meta property="og:description" content="[译]PEP 342–增强型生成器：协程PEP原文 ： https://www.python.org/dev/peps/pep-0342/ PEP标题： Coroutines via Enhanced Generators PEP作者： Guido van Rossum, Phillip J. Eby 创建日期： 2005-05-10 合入版本： 2.5 译者 ：豌豆花下猫（Python猫 公众号">
<meta property="og:locale" content="zh-Hans">
<meta property="og:updated_time" content="2019-01-27T10:10:51.827Z">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="豌豆花下猫">
<meta name="twitter:description" content="[译]PEP 342–增强型生成器：协程PEP原文 ： https://www.python.org/dev/peps/pep-0342/ PEP标题： Coroutines via Enhanced Generators PEP作者： Guido van Rossum, Phillip J. Eby 创建日期： 2005-05-10 合入版本： 2.5 译者 ：豌豆花下猫（Python猫 公众号">



<script type="text/javascript" id="hexo.configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '/',
    scheme: 'Muse',
    version: '5.1.4',
    sidebar: {"position":"left","display":"post","offset":12,"b2t":false,"scrollpercent":false,"onmobile":false},
    fancybox: true,
    tabs: true,
    motion: {"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},
    duoshuo: {
      userId: '0',
      author: '博主'
    },
    algolia: {
      applicationID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    }
  };
</script>



  <link rel="canonical" href="https://chinesehuazhou.github.io/2019/05/03/Python翻译/[译]PEP 342--增强型生成器：协程/">





  <title> | 豌豆花下猫</title>
  








</head>

<body itemscope itemtype="http://schema.org/WebPage" lang="zh-Hans">

  
  
    
  

  <div class="container sidebar-position-left page-post-detail">
    <div class="headband"></div>

    <header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-wrapper">
  <div class="site-meta ">
    

    <div class="custom-logo-site-title">
      <a href="/" class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">豌豆花下猫</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
      
        <p class="site-subtitle"></p>
      
  </div>

  <div class="site-nav-toggle">
    <button>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
    </button>
  </div>
</div>

<nav class="site-nav">
  

  
    <ul id="menu" class="menu">
      
        
        <li class="menu-item menu-item-home">
          <a href="/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-home"></i> <br>
            
            首页
          </a>
        </li>
      
        
        <li class="menu-item menu-item-archives">
          <a href="/archives/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-archive"></i> <br>
            
            归档
          </a>
        </li>
      

      
    </ul>
  

  
</nav>



 </div>
    </header>

    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          <div id="content" class="content">
            

  <div id="posts" class="posts-expand">
    

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://chinesehuazhou.github.io/2019/05/03/Python翻译/[译]PEP 342--增强型生成器：协程/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="John Doe">
      <meta itemprop="description" content>
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="豌豆花下猫">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline"></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2019-05-03T21:21:22+08:00">
                2019-05-03
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        <h1 id="译-PEP-342–增强型生成器：协程"><a href="#译-PEP-342–增强型生成器：协程" class="headerlink" title="[译]PEP 342–增强型生成器：协程"></a>[译]PEP 342–增强型生成器：协程</h1><p><strong>PEP原文 ：</strong> <a href="https://www.python.org/dev/peps/pep-0342/" target="_blank" rel="noopener">https://www.python.org/dev/peps/pep-0342/</a></p>
<p><strong>PEP标题：</strong> Coroutines via Enhanced Generators</p>
<p><strong>PEP作者：</strong> Guido van Rossum, Phillip J. Eby</p>
<p><strong>创建日期：</strong> 2005-05-10</p>
<p><strong>合入版本：</strong> 2.5</p>
<p><strong>译者</strong> ：<a href="https://zhuanlan.zhihu.com/pythonCat" target="_blank" rel="noopener">豌豆花下猫</a>（<strong>Python猫</strong> 公众号作者）</p>
<h2 id="目录"><a href="#目录" class="headerlink" title="目录"></a>目录</h2><ul>
<li>简介</li>
<li>动机</li>
<li>规格摘要</li>
<li>规格：将值发送到生成器<ul>
<li>新的生成器方法：send(value)</li>
<li>新的语法：yield 表达式</li>
</ul>
</li>
</ul>
<ul>
<li>规格：异常和清理<ul>
<li>新语法：yield 允许在<code>try-finally</code>中</li>
<li>新的生成器方法：throw（type，value = None，traceback = None）</li>
<li>新的标准异常：GeneratorExit</li>
<li>新的生成器方法：close()</li>
<li>新的生成器方法：<code>__del__()</code></li>
</ul>
</li>
<li>可选的扩展<ul>
<li>扩展的 continue 表达式</li>
</ul>
</li>
<li>未决问题</li>
<li>示例</li>
<li>参考实现</li>
<li>致谢</li>
<li>参考文献</li>
<li>版权</li>
</ul>
<h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><p>这个 PEP 在生成器的 API 和语法方面，提出了一些增强功能，使得它们可以作为简单的协程使用。这基本上是将下述两个 PEP 的想法结合起来，如果它被采纳，那它们就是多余的了：</p>
<ul>
<li>PEP-288，关于生成器的属性特征与异常（Attributes and Exceptions）。当前 PEP 沿用了它的下半部分，即生成器的异常（事实上，throw() 的方法名就取自 PEP-288）。PEP-342 用 yield 表达式（这个概念来自 PEP-288 的早期版本）来替换了生成器的属性特征。</li>
<li>PEP-325，生成器支持释放资源。PEP-342 收紧了 PEP-325 中的一些松散的规范，使其更适用于实际的实现。</li>
</ul>
<p>（译注：PEP-288 和 PEP-325 都没有被采纳通过，它们的核心内容被集成到了 PEP-342里。）</p>
<h2 id="动机"><a href="#动机" class="headerlink" title="动机"></a>动机</h2><p>协程是表达许多算法的自然方式，例如模拟/仿真、游戏、异步 I/O、以及其它事件驱动编程或协同的多任务处理。Python 的生成器函数几乎就是协程——但不完全是——因为它们允许暂停来生成值，但又不允许在程序恢复时传入值或异常。它们也不允许在 try-finally 结构的 try 部分作暂停，因此很难令一个异常退出的（aborted）协程来清理自己。</p>
<p>同样地，当其它函数在执行时，生成器不能提供控制，除非这些函数本身是生成器，并且外部生成器之所以写了去 yield，是要为了响应内部生成器所 yield 的值。这使得即使是相对简单的实现（如异步通信）也变得复杂，因为调用任意函数，要么需要生成器变堵塞（block，即无法提供控制），要么必须在每个要调用的函数的周围，添加一大堆引用循环代码（a lot of boilerplate looping code）。</p>
<p>但是，如果有可能在生成器挂起的点上传递进来值或者异常，那么，一个简单的协程调度器或蹦床函数（<code>trampoline function</code>）就能使协程相互调用且不用阻塞——对异步应用程序有巨大好处。这些应用程序可以编写协程来运行非阻塞的 socket I/O，通过给 I/O 调度器提供控制，直到数据被发送或变为可用。同时，执行 I/O 的代码只需像如下方式操作，就能暂停执行，直到 nonblocking_read() 继续产生一个值：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">data = (yield nonblocking_read(my_socket, nbytes))</span><br></pre></td></tr></table></figure>
<p>换句话说， 通过给语言和生成器类型增加一些相对较小的增强，Python 不需要为整个程序编写一系列回调，就能支持异步操作，并且对于本该需要数百上千个协作式的多任务伪线程的（co-operatively multitasking pseudothreads）程序，也可以不需要使用资源密集型线程。因此，这些增强功能将给标准 Python 带来 Stackless Python 的许多优点，又无需对 CPython 核心及其 API 进行任何重大的修改。此外，这些增强在任何已经支持生成器的 Python 实现（例如 Jython）上都是可落实的。</p>
<h2 id="规格摘要"><a href="#规格摘要" class="headerlink" title="规格摘要"></a>规格摘要</h2><p>通过给生成器类型增加一些简单的方法，以及两个微小的语法调整，Python 开发者就能够使用生成器函数来实现协程与其它的协作式多任务。这些方法和调整是：</p>
<ol>
<li>重定义 yield 为表达式（expression），而不是语句（statement）。当前的 yield 语句将变成一个 yield 表达式，其值将被丢弃。每当通过正常的 next() 调用来恢复生成器时，yield 表达式的返回值是 None。</li>
<li>为生成器（generator-iterator）添加一个新的 send() 方法，它会恢复生成器，并且 send 一个值作为当前表达式的结果。send() 方法返回的是生成器产生的 next 值，若生成器没有产生值就退出的话，则抛出 <code>StopIteration</code> 。</li>
<li>为生成器（generator-iterator）添加一个新的 throw() 方法，它在生成器暂停处抛出异常，并返回生成器产生的下一个值，若生成器没有产生值就退出的话，则抛出 <code>StopIteration</code> （如果生成器没有捕获传入的异常，或者它引发了其它异常，则该异常会传递给调用者。）</li>
<li>为生成器（generator-iterator）添加一个新的 close() 方法，它在生成器暂停处引发 <code>GeneratorExit</code> 。如果生成器在之后引发 <code>StopIteration</code> （通过正常退出，或者已经被关闭）或 <code>GeneratorExit</code> （通过不捕获异常），则 close() 返回给其调用者。如果生成器产生一个值，则抛出 <code>RuntimeError</code>。如果生成器引发任何其它异常，也会传递给调用者。如果生成器已经退出（异常退出或正常退出），则 close() 不执行任何操作。</li>
<li>增加了支持，确保即使在生成器被垃圾回收时，也会调用 close()。</li>
<li>允许 yield 在 try-finally 块中使用，因为现在允许在 finally 语句中执行垃圾回收或显式地调用 close() 。</li>
</ol>
<p>实现了所有这些变更的原型补丁已经可用了，可作为当前 Python CVS HEAD 的 SourceForge 补丁。# 1223381</p>
<h2 id="设计规格：将值发送进生成器"><a href="#设计规格：将值发送进生成器" class="headerlink" title="设计规格：将值发送进生成器"></a>设计规格：将值发送进生成器</h2><h3 id="新的生成器方法：send-value"><a href="#新的生成器方法：send-value" class="headerlink" title="新的生成器方法：send(value)"></a>新的生成器方法：send(value)</h3><p>为生成器提出了一种新的方法，即 send() 。它只接收一个参数，并将它发送给生成器。调用 send(None) 完全等同于调用生成器的 next() 方法。使用其它参数调用 send() 也有同样的效果，不同的是，当前生成器表达式产生的值会不一样。</p>
<p>因为生成器在生成器函数体的头部执行，所以在刚刚创建生成器时不会有 yield 表达式来接收值，因此，当生成器刚启动时，禁止使用非 None 参数来调用 send() ，如果调用了，就会抛出 <code>TypeError</code> （可能是由于某种逻辑错误）。所以，在与协程通信前，必须先调用 next() 或 send(None) ，来将程序推进到第一个 yield 表达式。</p>
<p>与 next() 方法一样，send() 方法也返回生成器产生的下一个值，或者抛出 <code>StopIteration</code>  异常（当生成器正常退出，或早已退出时）。如果生成器出现未捕获的异常，则它会传给调用者。</p>
<h3 id="新语法：yield-表达式"><a href="#新语法：yield-表达式" class="headerlink" title="新语法：yield 表达式"></a>新语法：yield 表达式</h3><p>yield 语句（yield-statement）可以被用在赋值表达式的右侧；在这种情况下，它就是 yield 表达式（yield-expression）。除非使用非 None 参数调用 send() ，否则 yield 表达式的值就是 None。见下文。</p>
<p>yield 表达式必须始终用括号括起来，除非它是作为顶级表达式而出现在赋值表达式的右侧。所以，下面例子都是合法的：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">x = yield 42</span><br><span class="line">x = yield</span><br><span class="line">x = 12 + (yield 42)</span><br><span class="line">x = 12 + (yield)</span><br><span class="line">foo(yield 42)</span><br><span class="line">foo(yield)</span><br></pre></td></tr></table></figure>
<p>而下面的例子则是非法的（举了一些特例的原因是，当前的 <code>yield 12,42</code> 是合法的）：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">x = 12 + yield 42</span><br><span class="line">x = 12 + yield</span><br><span class="line">foo(yield 42, 12)</span><br><span class="line">foo(yield, 12)</span><br></pre></td></tr></table></figure>
<p>请注意，如今没有表达式的 yield-语句 和 yield-表达式是合法的。这意味着：当 next() 调用中的信息流被反转时，应该可以在不传递显式的值的情况下 yield （yield 当然就等同于 yield None）。</p>
<p>当调用 send(value) 时，它恢复的 yield 表达式将返回传入的值。当调用 next() 时，它恢复的 yield 表达式将返回 None。如果 yield-表达式（yield-expression）是一个 yield-语句（yield-statement），其返回值会被忽略，就类似于忽略用作语句的函数的返回值。</p>
<p>实际上，yield 表达式就像一个反函数调用（inverted function）；它所 yield 的值实际上是当前函数返回（生成）的，而它 return 的值则是通过 send() 传入的参数。</p>
<p>提示：这样的拓展语法，使得它非常地接近于 Ruby。这是故意的。请注意，Python 在阻塞时，通过使用 send(EXPR) 而不是 return EXPR 来传值给生成器，并且在生成器与阻塞之间传递控制权的底层机制完全不同。Python 中的阻塞不会被编译成 thunk，相反，yield 暂停生成器的执行进度。有一些不是这样的特例，在 Python 中，你不能保存阻塞以供后续调用，并且你无法测试是否存在着阻塞。（XXX - 关于阻塞的这些东西似乎不合适，或许 Guido 会编辑下，做澄清。）</p>
<h2 id="设计规格：异常和清理"><a href="#设计规格：异常和清理" class="headerlink" title="设计规格：异常和清理"></a>设计规格：异常和清理</h2><p>让生成器对象成为通过调用生成器函数而生成的迭代器。本节中的 g 指的都是生成器对象。</p>
<h3 id="新语法：yield-允许在-try-finally-里"><a href="#新语法：yield-允许在-try-finally-里" class="headerlink" title="新语法：yield 允许在 try-finally 里"></a>新语法：yield 允许在 try-finally 里</h3><p>生成器函数的语法被拓展了，允许在 try-finally 语句中使用 yield 语句。</p>
<h3 id="新的生成器方法：throw-type，value-None，traceback-None"><a href="#新的生成器方法：throw-type，value-None，traceback-None" class="headerlink" title="新的生成器方法：throw(type，value = None，traceback = None)"></a>新的生成器方法：throw(type，value = None，traceback = None)</h3><p><code>g.throw(type, value, traceback)</code> 会使生成器在挂起的点处抛出指定的异常（即在 yield 语句中，或在其函数体的头部、且还未调用 next() 时）。如果生成器捕获了异常，并生成了新的值，则它就是 g.throw() 的返回值。如果生成器没有捕获异常，那 throw() 也会抛出同样的异常（它溜走了）。如果生成器抛出其它异常（包括返回时产生的 StopIteration），那该异常会被 throw() 抛出。总之，throw() 的行为类似于 next() 或 send()，除了它是在挂起点处抛出异常。如果生成器已经处于关闭状态，throw() 只会抛出经过它的异常，而不去执行生成器的任何代码。</p>
<p>抛出异常的效果完全像它所声明的那样：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">raise type, value, traceback</span><br></pre></td></tr></table></figure>
<p>会在暂停点执行。type 参数不能是 None，且 type 与 value 的类型必须得兼容。如果 value 不是 type 的实例（instance），则按照 raise 语句创建异常实例的规则，用 value 来生成新的异常实例。如果提供了 traceback 参数，则它必须是有效的 Python 堆栈（traceback）对象，否则会抛出 TypeError 。</p>
<p>注释：选择 throw() 这个名称，有几个原因。Raise 是一个关键字，因此不能作为方法的名称。与 raise 不同（它在执行点处即时地抛出异常），throw() 首先恢复生成器，然后才抛出异常。单词 throw 意味着将异常抛在别处，并且跟其它语言相关联。</p>
<p>考虑了几个替代的方法名：<code>resolve()</code>, <code>signal()</code>, <code>genraise()</code>, <code>raiseinto()</code> 和 <code>flush()</code> 。没有一个像 throw() 那般合适。</p>
<h3 id="新的标准异常：GeneratorExit"><a href="#新的标准异常：GeneratorExit" class="headerlink" title="新的标准异常：GeneratorExit"></a>新的标准异常：GeneratorExit</h3><p>定义了一个新的标准异常 GeneratorExit，继承自 Exception。生成器应该继续抛出它（或者就不捕获它），或者通过抛出 StopIteration 来处理这个问题。</p>
<h3 id="新的生成器方法：close"><a href="#新的生成器方法：close" class="headerlink" title="新的生成器方法：close()"></a>新的生成器方法：close()</h3><p>g.close() 由以下伪代码定义：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">def close(self):</span><br><span class="line">    try:</span><br><span class="line">        self.throw(GeneratorExit)</span><br><span class="line">    except (GeneratorExit, StopIteration):</span><br><span class="line">        pass</span><br><span class="line">    else:</span><br><span class="line">        raise RuntimeError(&quot;generator ignored GeneratorExit&quot;)</span><br><span class="line">    # Other exceptions are not caught</span><br></pre></td></tr></table></figure>
<h3 id="新的生成器方法：-del"><a href="#新的生成器方法：-del" class="headerlink" title="新的生成器方法：__del__()"></a>新的生成器方法：<code>__del__()</code></h3><p><code>g.__ del __()</code> 是 g.close() 的装饰器。当生成器对象被作垃圾回收时，会调用它（在 CPython 中，则是它的引用计数变为零时）。如果 close() 引发异常， 异常的堆栈信息（traceback）会被打印到 sys.stderr 并被忽略掉；它不会退回到触发垃圾回收的地方。这与类实例在处理 <code>__del__()</code>的异常时的方法一样。</p>
<p>如果生成器对象被循环引用，则可能不会调用 <code>g.__del__()</code> 。这是当前 CPython 的垃圾收集器的表现。做此限制的原因是，GC 代码需要在一个任意点打破循环，以便回收它，在此之后，不允许 Python 代码“看到”形成循环的对象，因为它们可能处于无效的状态。被用于解开（hanging off）循环的对象不受此限制。</p>
<p>尽管实际上不太可能看到生成器被循环引用。但是，若将生成器对象存储在全局变量中，则会通过生成器框架的 f_globals 指针创建一个循环。另外，若在数据结构中存储对生成器对象的引用，且该数据结构被作为参数传递给生成器，这也会创造一个循环引用（例如，如果一个对象具有一个作为生成器的方法，并持有由该方法创建的运行中的迭代器的引用）。鉴于生成器的典型用法，这些情况都不太可能。</p>
<p>此外，CPython 在实现当前 PEP 时，每当由于错误或正常退出而终止执行时，会释放被生成器使用的框架对象（frame object）。这保证了那些无法被恢复的生成器不会成为无法回收的循环引用的部分。这就允许了其它代码在 try-finally 或 with 语句中使用 close() （参考 PEP-343），确保了给定的生成器会正确地完结。</p>
<h2 id="可选扩展"><a href="#可选扩展" class="headerlink" title="可选扩展"></a>可选扩展</h2><h3 id="扩展的-continue-语句"><a href="#扩展的-continue-语句" class="headerlink" title="扩展的 continue 语句"></a>扩展的 continue 语句</h3><p>本 PEP 的早期草案提出了一种新的 continue EXPR 语法，用于 for 循环（继承自 PEP-340），将 EXPR 的值传给被遍历的迭代器。此功能暂时被撤销了，因为本 PEP 的范围已经缩小，只关注将值传给生成器迭代器（generator-iterator），而非其它类型的迭代器。Python-Dev 邮件列表中的一些人也觉得为这个特定功能添加新语法是为时过早（would be premature at best）。</p>
<h2 id="未决问题"><a href="#未决问题" class="headerlink" title="未决问题"></a>未决问题</h2><p>Python-Dev 邮件的讨论提出了一些未决的问题。我罗列于此，附上我推荐的解决方案与它的动机。目前编写的 PEP 也反映了这种喜好的解决方案。</p>
<ol>
<li><p>当生成器产生另一个值作为对“GeneratorExit”异常的响应时，<code>close()</code>应该引发什么异常？</p>
<p>我最初选择了 TypeError ，因为它表示生成器函数发生了严重的错误行为，应该通过修改代码来修复。但是 PEP-343 中的 <code>with_template</code> 装饰器类使用了 RuntimeError 来进行类似处理。可以说它们都应该使用相同的异常。我宁愿不为此目的引入新的异常类，因为它不是我希望人们捕获的异常：我希望它变成一个 traceback 给程序员看到，然后进行修复。所以我觉得它们都应该抛出 RuntimeError 。有一些先例：在检测到无限递归的情况下，或者检测到未初始化的对象（由于各种各样的原因），核心 Python 代码会抛出该异常。</p>
</li>
<li><p>Oren Tirosh 建议将 send() 方法重命名为 feed() ，以便能跟 consumer 接口兼容（规范参见：<a href="http://effbot.org/zone/consumer.htm" target="_blank" rel="noopener">http://effbot.org/zone/consumer.htm</a>）。</p>
<p>然而，仔细观察 consumer 接口，似乎 feed() 所需的语义与 send() 不同，因为后者不能在刚启动的生成器上作有意义的调用。此外，当前定义的 consumer 接口不包含对 StopIteration 的处理。</p>
<p>因此，创建一个贴合 consumer 接口的简单的装饰器，来装饰生成器函数，似乎会更有用。举个例子，它可以用初始的 next() 调用给生成器预热（warm up），追踪 StopIteration，甚至可以通过重新调用生成器来提供 reset() 用途。</p>
</li>
</ol>
<h2 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h2><ol>
<li>一个简单的 consumer 装饰器，它使生成器函数在最初调用时，就自动地前进到第一个 yield 点：</li>
</ol>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">def consumer(func):</span><br><span class="line">    def wrapper(*args,**kw):</span><br><span class="line">        gen = func(*args, **kw)</span><br><span class="line">        gen.next()</span><br><span class="line">        return gen</span><br><span class="line">    wrapper.__name__ = func.__name__</span><br><span class="line">    wrapper.__dict__ = func.__dict__</span><br><span class="line">    wrapper.__doc__  = func.__doc__</span><br><span class="line">    return wrapper</span><br></pre></td></tr></table></figure>
<ol start="2">
<li>一个使用 consumer 装饰器创建反向生成器（reverse generator）的示例，该生成器接收图像并创建缩略图，再发送给其它 consumer。像这样的函数可以链接在一起，形成 consumer 间的高效处理流水线，且每个流水线都可以具有复杂的内部状态：</li>
</ol>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line">@consumer</span><br><span class="line">def thumbnail_pager(pagesize, thumbsize, destination):</span><br><span class="line">    while True:</span><br><span class="line">        page = new_image(pagesize)</span><br><span class="line">        rows, columns = pagesize / thumbsize</span><br><span class="line">        pending = False</span><br><span class="line">        try:</span><br><span class="line">            for row in xrange(rows):</span><br><span class="line">                for column in xrange(columns):</span><br><span class="line">                    thumb = create_thumbnail((yield), thumbsize)</span><br><span class="line">                    page.write(</span><br><span class="line">                        thumb, col*thumbsize.x, row*thumbsize.y )</span><br><span class="line">                    pending = True</span><br><span class="line">        except GeneratorExit:</span><br><span class="line">            # close() was called, so flush any pending output</span><br><span class="line">            if pending:</span><br><span class="line">                destination.send(page)</span><br><span class="line"></span><br><span class="line">            # then close the downstream consumer, and exit</span><br><span class="line">            destination.close()</span><br><span class="line">            return</span><br><span class="line">        else:</span><br><span class="line">            # we finished a page full of thumbnails, so send it</span><br><span class="line">            # downstream and keep on looping</span><br><span class="line">            destination.send(page)</span><br><span class="line"></span><br><span class="line">@consumer</span><br><span class="line">def jpeg_writer(dirname):</span><br><span class="line">    fileno = 1</span><br><span class="line">    while True:</span><br><span class="line">        filename = os.path.join(dirname,&quot;page%04d.jpg&quot; % fileno)</span><br><span class="line">        write_jpeg((yield), filename)</span><br><span class="line">        fileno += 1</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"># Put them together to make a function that makes thumbnail</span><br><span class="line"># pages from a list of images and other parameters.</span><br><span class="line">#</span><br><span class="line">def write_thumbnails(pagesize, thumbsize, images, output_dir):</span><br><span class="line">    pipeline = thumbnail_pager(</span><br><span class="line">        pagesize, thumbsize, jpeg_writer(output_dir)</span><br><span class="line">    )</span><br><span class="line"></span><br><span class="line">    for image in images:</span><br><span class="line">        pipeline.send(image)</span><br><span class="line"></span><br><span class="line">    pipeline.close()</span><br></pre></td></tr></table></figure>
<ol start="3">
<li>一个简单的协程调度器或蹦床（trampoline），它允许协程通过 yield 其它协程，来调用后者。被调用的协程所产生的非生成器的值，会被返回给调用方的协程。类似地，如果被调用的协程抛出异常，该异常也会传导给调用者。实际上，只要你用 yield 表达式来调用协程（否则会阻塞），这个例子就模拟了 Stackless Python 中使用的简单的子任务（tasklet）。这只是一个非常简单的例子，但也可以使用更复杂的调度程序。（例如，现有的 GTasklet 框架 (<a href="http://www.gnome.org/~gjc/gtasklet/gtasklets.html" target="_blank" rel="noopener">http://www.gnome.org/~gjc/gtasklet/gtasklets.html</a>) 和 peak.events 框架 (<a href="http://peak.telecommunity.com/" target="_blank" rel="noopener">http://peak.telecommunity.com/</a>) 已经实现类似的调度功能，但大多数因为无法将值或异常传给生成器，而必须使用很尴尬的解决方法。）</li>
</ol>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br></pre></td><td class="code"><pre><span class="line">import collections</span><br><span class="line"></span><br><span class="line">class Trampoline:</span><br><span class="line">    &quot;&quot;&quot;Manage communications between coroutines&quot;&quot;&quot;</span><br><span class="line"></span><br><span class="line">    running = False</span><br><span class="line"></span><br><span class="line">    def __init__(self):</span><br><span class="line">        self.queue = collections.deque()</span><br><span class="line"></span><br><span class="line">    def add(self, coroutine):</span><br><span class="line">        &quot;&quot;&quot;Request that a coroutine be executed&quot;&quot;&quot;</span><br><span class="line">        self.schedule(coroutine)</span><br><span class="line"></span><br><span class="line">    def run(self):</span><br><span class="line">        result = None</span><br><span class="line">        self.running = True</span><br><span class="line">        try:</span><br><span class="line">            while self.running and self.queue:</span><br><span class="line">               func = self.queue.popleft()</span><br><span class="line">               result = func()</span><br><span class="line">            return result</span><br><span class="line">        finally:</span><br><span class="line">            self.running = False</span><br><span class="line"></span><br><span class="line">    def stop(self):</span><br><span class="line">        self.running = False</span><br><span class="line"></span><br><span class="line">    def schedule(self, coroutine, stack=(), val=None, *exc):</span><br><span class="line">        def resume():</span><br><span class="line">            value = val</span><br><span class="line">            try:</span><br><span class="line">                if exc:</span><br><span class="line">                    value = coroutine.throw(value,*exc)</span><br><span class="line">                else:</span><br><span class="line">                    value = coroutine.send(value)</span><br><span class="line">            except:</span><br><span class="line">                if stack:</span><br><span class="line">                    # send the error back to the &quot;caller&quot;</span><br><span class="line">                    self.schedule(</span><br><span class="line">                        stack[0], stack[1], *sys.exc_info()</span><br><span class="line">                    )</span><br><span class="line">                else:</span><br><span class="line">                    # Nothing left in this pseudothread to</span><br><span class="line">                    # handle it, let it propagate to the</span><br><span class="line">                    # run loop</span><br><span class="line">                    raise</span><br><span class="line"></span><br><span class="line">            if isinstance(value, types.GeneratorType):</span><br><span class="line">                # Yielded to a specific coroutine, push the</span><br><span class="line">                # current one on the stack, and call the new</span><br><span class="line">                # one with no args</span><br><span class="line">                self.schedule(value, (coroutine,stack))</span><br><span class="line"></span><br><span class="line">            elif stack:</span><br><span class="line">                # Yielded a result, pop the stack and send the</span><br><span class="line">                # value to the caller</span><br><span class="line">                self.schedule(stack[0], stack[1], value)</span><br><span class="line"></span><br><span class="line">            # else: this pseudothread has ended</span><br><span class="line"></span><br><span class="line">        self.queue.append(resume)</span><br></pre></td></tr></table></figure>
<ol start="4">
<li>一个简单的 echo 服务器以及用蹦床原理实现的运行代码（假设存在 <code>nonblocking_read</code> 、<code>nonblocking_write</code>  和其它 I/O 协程，该例子在连接关闭时抛出 <code>ConnectionLost</code> ）：</li>
</ol>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"># coroutine function that echos data back on a connected</span><br><span class="line"># socket</span><br><span class="line">#</span><br><span class="line">def echo_handler(sock):</span><br><span class="line">    while True:</span><br><span class="line">        try:</span><br><span class="line">            data = yield nonblocking_read(sock)</span><br><span class="line">            yield nonblocking_write(sock, data)</span><br><span class="line">        except ConnectionLost:</span><br><span class="line">            pass  # exit normally if connection lost</span><br><span class="line"></span><br><span class="line"># coroutine function that listens for connections on a</span><br><span class="line"># socket, and then launches a service &quot;handler&quot; coroutine</span><br><span class="line"># to service the connection</span><br><span class="line">#</span><br><span class="line">def listen_on(trampoline, sock, handler):</span><br><span class="line">    while True:</span><br><span class="line">        # get the next incoming connection</span><br><span class="line">        connected_socket = yield nonblocking_accept(sock)</span><br><span class="line"></span><br><span class="line">        # start another coroutine to handle the connection</span><br><span class="line">        trampoline.add( handler(connected_socket) )</span><br><span class="line"></span><br><span class="line"># Create a scheduler to manage all our coroutines</span><br><span class="line">t = Trampoline()</span><br><span class="line"></span><br><span class="line"># Create a coroutine instance to run the echo_handler on</span><br><span class="line"># incoming connections</span><br><span class="line">#</span><br><span class="line">server = listen_on(</span><br><span class="line">    t, listening_socket(&quot;localhost&quot;,&quot;echo&quot;), echo_handler</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"># Add the coroutine to the scheduler</span><br><span class="line">t.add(server)</span><br><span class="line"></span><br><span class="line"># loop forever, accepting connections and servicing them</span><br><span class="line"># &quot;in parallel&quot;</span><br><span class="line">#</span><br><span class="line">t.run()</span><br></pre></td></tr></table></figure>
<h2 id="参考实现"><a href="#参考实现" class="headerlink" title="参考实现"></a>参考实现</h2><p>实现了本 PEP 中描述的所有功能的原型补丁已经可用，参见 SourceForge 补丁 1223381 （<a href="https://bugs.python.org/issue1223381" target="_blank" rel="noopener">https://bugs.python.org/issue1223381</a>）。</p>
<p>该补丁已提交到 CVS，2005年8月 01-02。</p>
<h2 id="致谢"><a href="#致谢" class="headerlink" title="致谢"></a>致谢</h2><p>Raymond Hettinger (<a href="https://www.python.org/dev/peps/pep-0288" target="_blank" rel="noopener">PEP 288</a>) 与 Samuele Pedroni (<a href="https://www.python.org/dev/peps/pep-0325" target="_blank" rel="noopener">PEP 325</a>) 第一个正式地提出将值或异常传递给生成器的想法，以及关闭生成器的能力。Timothy Delaney 建议了本 PEP 的标题，还有 Steven Bethard 帮忙编辑了早期的版本。另见 PEP-340 的致谢部分。</p>
<h2 id="参考文献"><a href="#参考文献" class="headerlink" title="参考文献"></a>参考文献</h2><p> TBD.</p>
<h2 id="版权"><a href="#版权" class="headerlink" title="版权"></a>版权</h2><p>本文档已经放置在公共领域。</p>
<p>源文档：<a href="https://github.com/python/peps/blob/master/pep-0342.txt" target="_blank" rel="noopener">https://github.com/python/peps/blob/master/pep-0342.txt</a></p>
<p>-—————（译文完）-——————-</p>
<p><strong>相关链接：</strong> </p>
<p><strong>PEP背景知识</strong> ：<a href="https://mp.weixin.qq.com/s/oRoBxZ2-IyuPOf_MWyKZyw" target="_blank" rel="noopener">学习Python，怎能不懂点PEP呢？</a></p>
<p><strong>PEP翻译计划</strong> ：<a href="https://github.com/chinesehuazhou/peps-cn" target="_blank" rel="noopener">https://github.com/chinesehuazhou/peps-cn</a></p>
<p><a href="https://mp.weixin.qq.com/s/vjQLlmH5QV-zAre7tVCxSA" target="_blank" rel="noopener">[译] PEP 255–简单的生成器</a></p>
<p><a href="https://mp.weixin.qq.com/s/fyzFo8btDelxZikMerm7Qg" target="_blank" rel="noopener">[译]PEP 525–异步生成器</a></p>
<p><strong>花下猫语：</strong> 唠叨几句吧，年前这几周事情太多了，挤着时间好歹是又翻译出一篇 PEP。与生成器密切相关的 PEP 已经完成 3/4，年后再译最后一篇（PEP-380）。当初翻译第一篇，完全是一时兴起，直觉这是一件有意义的事，现在呢，这个念头开始有点膨胀——我竟然在 Github 上建了个翻译项目。我深知，自己水平实在有限，因此不求得到多少认同吧。但行好事，莫问前程。不过，若有人帮着吆喝一声，也是极好的。 </p>
<p>-—————-</p>
<p>本文原创并首发于微信公众号【Python猫】，后台回复“爱学习”，免费获得20+本精选电子书。</p>

      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      
      
      

      
        <div class="post-nav">
          <div class="post-nav-next post-nav-item">
            
              <a href="/2019/05/03/Python翻译/[译] PEP 255--简单的生成器/" rel="next" title>
                <i class="fa fa-chevron-left"></i> 
              </a>
            
          </div>

          <span class="post-nav-divider"></span>

          <div class="post-nav-prev post-nav-item">
            
              <a href="/2019/05/03/Python翻译/别开心太早，Python 官方文档的翻译差远了/" rel="prev" title>
                 <i class="fa fa-chevron-right"></i>
              </a>
            
          </div>
        </div>
      

      
      
    </footer>
  </div>
  
  
  
  </article>



    <div class="post-spread">
      
    </div>
  </div>


          </div>
          


          

  



        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    
    <div class="sidebar-inner">

      

      
        <ul class="sidebar-nav motion-element">
          <li class="sidebar-nav-toc sidebar-nav-active" data-target="post-toc-wrap">
            文章目录
          </li>
          <li class="sidebar-nav-overview" data-target="site-overview-wrap">
            站点概览
          </li>
        </ul>
      

      <section class="site-overview-wrap sidebar-panel">
        <div class="site-overview">
          <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
            
              <p class="site-author-name" itemprop="name">John Doe</p>
              <p class="site-description motion-element" itemprop="description"></p>
          </div>

          <nav class="site-state motion-element">

            
              <div class="site-state-item site-state-posts">
              
                <a href="/archives/">
              
                  <span class="site-state-item-count">44</span>
                  <span class="site-state-item-name">日志</span>
                </a>
              </div>
            

            

            

          </nav>

          

          

          
          

          
          

          

        </div>
      </section>

      
      <!--noindex-->
        <section class="post-toc-wrap motion-element sidebar-panel sidebar-panel-active">
          <div class="post-toc">

            
              
            

            
              <div class="post-toc-content"><ol class="nav"><li class="nav-item nav-level-1"><a class="nav-link" href="#译-PEP-342–增强型生成器：协程"><span class="nav-number">1.</span> <span class="nav-text">[译]PEP 342–增强型生成器：协程</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#目录"><span class="nav-number">1.1.</span> <span class="nav-text">目录</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#简介"><span class="nav-number">1.2.</span> <span class="nav-text">简介</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#动机"><span class="nav-number">1.3.</span> <span class="nav-text">动机</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#规格摘要"><span class="nav-number">1.4.</span> <span class="nav-text">规格摘要</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#设计规格：将值发送进生成器"><span class="nav-number">1.5.</span> <span class="nav-text">设计规格：将值发送进生成器</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#新的生成器方法：send-value"><span class="nav-number">1.5.1.</span> <span class="nav-text">新的生成器方法：send(value)</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#新语法：yield-表达式"><span class="nav-number">1.5.2.</span> <span class="nav-text">新语法：yield 表达式</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#设计规格：异常和清理"><span class="nav-number">1.6.</span> <span class="nav-text">设计规格：异常和清理</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#新语法：yield-允许在-try-finally-里"><span class="nav-number">1.6.1.</span> <span class="nav-text">新语法：yield 允许在 try-finally 里</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#新的生成器方法：throw-type，value-None，traceback-None"><span class="nav-number">1.6.2.</span> <span class="nav-text">新的生成器方法：throw(type，value = None，traceback = None)</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#新的标准异常：GeneratorExit"><span class="nav-number">1.6.3.</span> <span class="nav-text">新的标准异常：GeneratorExit</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#新的生成器方法：close"><span class="nav-number">1.6.4.</span> <span class="nav-text">新的生成器方法：close()</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#新的生成器方法：-del"><span class="nav-number">1.6.5.</span> <span class="nav-text">新的生成器方法：__del__()</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#可选扩展"><span class="nav-number">1.7.</span> <span class="nav-text">可选扩展</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#扩展的-continue-语句"><span class="nav-number">1.7.1.</span> <span class="nav-text">扩展的 continue 语句</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#未决问题"><span class="nav-number">1.8.</span> <span class="nav-text">未决问题</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#示例"><span class="nav-number">1.9.</span> <span class="nav-text">示例</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#参考实现"><span class="nav-number">1.10.</span> <span class="nav-text">参考实现</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#致谢"><span class="nav-number">1.11.</span> <span class="nav-text">致谢</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#参考文献"><span class="nav-number">1.12.</span> <span class="nav-text">参考文献</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#版权"><span class="nav-number">1.13.</span> <span class="nav-text">版权</span></a></li></ol></li></ol></div>
            

          </div>
        </section>
      <!--/noindex-->
      

      

    </div>
  </aside>


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright">&copy; <span itemprop="copyrightYear">2019</span>
  <span class="with-love">
    <i class="fa fa-user"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">John Doe</span>

  
</div>


  <div class="powered-by">由 <a class="theme-link" target="_blank" href="https://hexo.io">Hexo</a> 强力驱动</div>



  <span class="post-meta-divider">|</span>



  <div class="theme-info">主题 &mdash; <a class="theme-link" target="_blank" href="https://github.com/iissnan/hexo-theme-next">NexT.Muse</a> v5.1.4</div>




        







        
      </div>
    </footer>

    
      <div class="back-to-top">
        <i class="fa fa-arrow-up"></i>
        
      </div>
    

    

  </div>

  

<script type="text/javascript">
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>









  












  
  
    <script type="text/javascript" src="/lib/jquery/index.js?v=2.1.3"></script>
  

  
  
    <script type="text/javascript" src="/lib/fastclick/lib/fastclick.min.js?v=1.0.6"></script>
  

  
  
    <script type="text/javascript" src="/lib/jquery_lazyload/jquery.lazyload.js?v=1.9.7"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/fancybox/source/jquery.fancybox.pack.js?v=2.1.5"></script>
  


  


  <script type="text/javascript" src="/js/src/utils.js?v=5.1.4"></script>

  <script type="text/javascript" src="/js/src/motion.js?v=5.1.4"></script>



  
  

  
  <script type="text/javascript" src="/js/src/scrollspy.js?v=5.1.4"></script>
<script type="text/javascript" src="/js/src/post-details.js?v=5.1.4"></script>



  


  <script type="text/javascript" src="/js/src/bootstrap.js?v=5.1.4"></script>



  


  




	





  





  












  





  

  

  

  
  

  

  

  

</body>
</html>
