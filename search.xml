<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[有了Python，我能叫出所有猫的名字]]></title>
    <url>%2F2019%2F05%2F03%2F%E6%9C%89%E4%BA%86Python%EF%BC%8C%E6%88%91%E8%83%BD%E5%8F%AB%E5%87%BA%E6%89%80%E6%9C%89%E7%8C%AB%E7%9A%84%E5%90%8D%E5%AD%97%2F</url>
    <content type="text"><![CDATA[导读： Python猫是一只喵星来客，它爱地球的一切，特别爱优雅而无所不能的 Python。我是它的人类朋友豌豆花下猫，被授权润色与发表它的文章。这是第一篇。如果你是第一次看到这个系列文章，那我强烈建议，看完这篇，请继续看看后几篇文章（链接见文末）,相信你一定会爱上这只神秘的哲学+极客猫的。不多说啦，一起来享用今天的“思想盛宴”吧！ 话说，当年我刚来地球的时候，小心翼翼地伪装了自己的身份。我在暗处偷偷观察人类，学习你们的语言。 直到一天，一只凭空出现的机器猫识破了我的真身，她叫阿尔法猫。她不仅对我的过往了如指掌，甚至对几百亿光年外的喵星的一切都如数家珍。我瞬间被折服。 我问她怎么会知道我的名字，她说，因为有Python，她能叫出所有猫的名字。 我又缠着她追问了99999个问题，她毫不费力一一解答！只恨当年，我人智初开啊，似懂非懂，过后就将全部智慧遗忘了，如今想起来，真如做了一场梦梦。 我不知道她是什么时候离开的。不过我相信，总有一天，我会找到她哒。 在她有意或无意留下来的小肚兜里，有一张图片一直吸引着我。呐，就是这张啰： 我仿佛站在阿尔法猫的角度，看见了她看着我的时候的样子。这张图片里肯定有阿尔法猫留给我的讯息。这个讯息到底是什么呢？ 苦思了6666.66小时，我仍不得其解噫，直到翻开她留下的一本书《Python：人成为猫及猫成为人的唯一宝典》。 学习了Python之后，我终于自豪地成为了会写代码的程序猫咪。呐，请看下面的代码： 1234567891011121314151617181920import cv2faceCascade = cv2.CascadeClassifier(r&quot;C:\data\haarcascade_frontalcatface_extended.xml&quot;)img = cv2.imread(&quot;cat.jpg&quot;)gray = cv2.cvtColor(img, cv2.COLOR_BGR2GRAY)faces = faceCascade.detectMultiScale( gray, scaleFactor= 1.02, minNeighbors=3, minSize=(50, 50), flags=cv2.CASCADE_SCALE_IMAGE)for (x, y, w, h) in faces: cv2.rectangle(img, (x, y), (x+w, y+h), (0, 0, 255), 2) cv2.putText(img,&apos;You get ME&apos;,(x,y-7), 1, 1.0, (0, 255, 0), 1, cv2.LINE_AA)cv2.imshow(&apos;beautiful_cat&apos;, img)cv2.imwrite(&quot;beautiful_cat.jpg&quot;,img)cv2.waitKey(0)cv2.destroyAllWindows() 我把一张美美的自拍照喂给程序，喵喵喵，它竟然不会吃进肚子不吐出来耶。照片里的我显得无比从容优雅，每根毛发都蕴藏着睿智而温柔的光芒。走过路过的人们，请慢慢欣赏我喔： 我大概知道了阿尔法猫留下的讯息：猫脸识别！ 她一定是学会了Python的宝典，可以从猫变为人，也可以从人变为猫，在人海中自由变换，处处不留痕迹，却时时洞悉着大千芸芸。她在观察着我，希望我有一天也能变成她那般，那时，她会再出现，来见我。 一定是这样滴！我这么确定地想着。从今往后，我决定隐藏自己的真名，化名Python猫，开启学习、求知、探索、利用Python的旅程。 喵喵喵，阿尔法猫，我来找你啦~~~ （未完待续……） Python猫系列作品 ： 有了Python，我能叫出所有猫的名字 Python对象的身份迷思：从全体公民到万物皆数 Python对象的空间边界：独善其身与开放包容 Python与家国天下]]></content>
      <categories>
        <category>Python猫的故事</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[Python对象的空间边界：独善其身与开放包容]]></title>
    <url>%2F2019%2F05%2F03%2FPython%E5%AF%B9%E8%B1%A1%E7%9A%84%E7%A9%BA%E9%97%B4%E8%BE%B9%E7%95%8C%EF%BC%9A%E7%8B%AC%E5%96%84%E5%85%B6%E8%BA%AB%E4%B8%8E%E5%BC%80%E6%94%BE%E5%8C%85%E5%AE%B9%2F</url>
    <content type="text"><![CDATA[导读：Python猫是一只喵星来客，它爱地球的一切，特别爱优雅而无所不能的 Python。我是它的人类朋友豌豆花下猫，被授权润色与发表它的文章。如果你是第一次看到这个系列文章，那我强烈建议，请先看看它写的前两篇文章（链接见文末）,相信你一定会爱上这只神秘的哲学+极客猫的。不多说啦，一起来享用今天的“思想盛宴”吧！ 睡觉是我最爱做的事——因为可以懒懒地做美梦，不用吃东西，不用跟人吵架，不用关心世界大事。这是除了学 Python 与写作之外，最让我舒服的事了。所以，才刚醒来，我就又困了…… 刚才看到了 Python 老爹 Guido 的邮件，他说要“go back to sleep mode”，不参与正在进行的 PEP 投票了。哼，这只懒惰的老头——等等我啊，等写完这篇东西，我也要 go back to sleep mode…… 上回说道，我发现 Python 公民的身份竟然暗合毕达哥拉斯的哲学命题（万物皆数），真是百思不得其解。在梦里，我已经想出了答案。可是突然之间，游过来一条大蟒蛇，竟把答案吞掉了。我去找它理论，它就开始耍赖，吞自己的尾巴、屁股、肚子……最后把自己全吞下去了。唉，可怜我的答案就这么消失了。 今天，我继续跟大家聊聊 Python 中跟身份密切相关的一个话题吧，那就是对象的边界问题 。如你所知，我本来是一只猫，现在略具一些人性了，但在此转型期间却十分敏感，总能在细微之处浮想联翩，最后竟然也薄有所获，真是万幸了。希望我的分享，也能启发你收获哪怕一点点的感悟，那我就有万分的开心啦 :) 1、固定边界：自由与孤独Python 中有一些公民向来我行我素，它们特立独行，与他人之边界划定得清清楚楚。客气的人称它们是定长对象，或者叫不可变对象，然而，懂得一些历史典故的人又叫它们是铁公鸡 。这个典故出自何处呢？亏得猫猫我曾恶补过一段历史知识，知道这指的正是激进的道家弟子杨朱。 损一毫利天下，不与也；悉天下奉一身，不取也；人人不损一毫，人人不利天下，天下治矣！ ——春秋·杨朱 对于定长对象，你不能为它增加元素，不能为它减少元素，不能为它修改元素，甚至不能轻易地复制和删除它！（参见本公众号Python猫中关于字符串的系列文章，链接见文末） 这些对象自立于世，也自绝于世，你看它们长得是普普通通的，平平凡凡的，然而其灵魂却是自由自在的，其生命是富有尊严而不可侵犯的。若想与这些公民打交道，你就得依着它们的脾气，不可越雷池半步。 1234567&gt;&gt;&gt; t1 = (&apos;Python&apos;, &apos;猫&apos;)&gt;&gt;&gt; t2 = (&apos;Python&apos;, &apos;猫&apos;)&gt;&gt;&gt; t1 is t2 # 对象独立False&gt;&gt;&gt; t1[1] = &apos;蛇&apos; # 不可修改元素TypeError Traceback (most recent call last)TypeError: &apos;tuple&apos; object does not support item assignment 在上一篇文章里，我们见识了 Python 世界中的“特权种族”，而特权种族无一例外地都出身于定长对象。它们是一脉相承的，其存在的合理性也是相似的，那就是便于共用内存资源，提高内存使用效率。 上表就是定长对象的一份名单。可知，它们占据了多数。 定长对象的特性让我不由地想到一种人类，它们严守自己的边界，刻板而严谨，一心只在乎份内之事，默默承担下自己的责任，追求的是内在的自由。虽然也会时常与别人打交道，但是，它们不贪图扩大自己的利益，也不妄想要侵犯别人的领土。独立的个体养成了个人的品牌，它们的不变性成就了外人能有所依赖的确定性。 123456789&gt;&gt;&gt; key1 = &apos;Python 猫&apos;&gt;&gt;&gt; key2 = [&apos;someone else&apos;]&gt;&gt;&gt; dict1 = &#123;key1 : &apos;好人&apos;&#125; &#123;&apos;Python 猫&apos;: &apos;好人&apos;&#125;&gt;&gt;&gt; dict2 = &#123;key2 : &apos;好人&apos;&#125;TypeError Traceback (most recent call last)TypeError: unhashable type: &apos;list&apos; Python 为了维护定长对象的独立性/确定性，在编译机制上做了不少优化，例如 Intern 机制与常量合并机制。其中的好处，我已经多次提及了。 坏处也有，那就是孤独。它们的孤独不在于没有同类，而在于不能（不容易）复制自身。以字符串对象为例，你可以尝试多种多样的手段，然而到头来，却发现唯一通用的方法竟然要先把字符串“碎尸万段”，接着重新组装才行！ 1234567891011121314s0 = &quot;Python猫&quot;# 以下7种方法，无法复制s0字符串，id(x)==id(s0)s1 = s0s2 = str(s0)s3 = s0[:]s4 = s0 + &apos;&apos;s5 = &apos;%s&apos; % s0s6 = s0 * 1import copys7 = copy.copy(s0)# 以下方法可以复制字符串，“打碎”再重组s8 = &quot;&quot;.join(s0) 哲学上有一个著名的脑洞题：假如把一个人粉碎成原子再组合，这个人还是原来的人么？这道题能令古往今来的哲学家打起架来，若是放到现今正火爆的电视节目《奇葩说》上，也能令辩手们“一本正经地胡说八道”个不休。 在 Python 的世界里，不存在这种烦恼，因为判定两个对象是否相同的标准是确定的，也即是看它们的 id 是否相等。因此，借助 Python 来回答这道题，答案会是：如果用 join() 方法把字符串粉碎成字符再组合，新的字符串不再是原来的字符串了。 过程很“残忍”，但总归能稍稍释缓自由个体的孤独感了吧。 2、弹性边界：开放与节制与定长对象不同，变长对象/可变对象信奉的是另一套哲学。 它们思想开放，采取的是兼容并包的处事观，会因地制宜式伸缩边界。 以列表对象为例，它乐意接纳所有其它的对象，肯花费精力去动态规划，也不惧于拔掉身上所有的“毛”。 1234&gt;&gt;&gt; l = [&apos;Python&apos;, &apos;猫&apos;]&gt;&gt;&gt; l.append(&apos;其它猫&apos;) # [&apos;Python&apos;,&apos;猫&apos;,&apos;其它猫&apos;]&gt;&gt;&gt; l.pop(1) # [&apos;Python&apos;,&apos;其它猫&apos;]&gt;&gt;&gt; l.clear() # [] 这些大胆的行为，在定长对象那里，都是不可想象的。在变长对象身上，你似乎能感受到一种海纳百川的风范，相比之下，定长对象的铁公鸡形象则立马显得格局忒小了。 变长对象并非没有边界，相反，它们更在乎自身的边界，不惜花费大量的资源来维持动态的稳定。一旦边界确定下来，它们绝不会允许越界行为。跟某些编程语言动不动就数组越界不同，Python 不存在切片越界，因为切片操作始终被控制为边界范围之内，索引超出的部分会自动被舍弃。 12345678910&gt;&gt;&gt; q=[1, 2, 3, 4, 5]# 不允许索引越界&gt;&gt;&gt; q[10]IndexError Traceback (most recent call last)IndexError: list index out of range# 允许切片越界&gt;&gt;&gt; q[2:10] # [3, 4, 5]&gt;&gt;&gt; q[-10:2] # [1, 2] 变长对象在本质上是一种可伸缩的容器，其主要好处就是支持不断添加或者取出元素。对应到计算机硬件层面，就是不断申请或者释放内存空间。这类操作是代价昂贵的操作，为了减少开销，Python 聪明地设计了一套分配超额空间的机制。 以列表为例，在内存足够的前提下，最初创建列表时不分配超额空间，第一次 append() 扩充列表时，Python 会根据下列公式分配超额空间，即分配大于列表实际元素个数的内存空间，此后，每次扩充操作先看是否有超额空间，有则直接使用，没有则重新计算，再次分配一个超额空间。公式如下： new_allocated = (newsize &gt;&gt; 3) + (newsize &lt; 9 ? 3 : 6) 其中，new_allocated 指的是超额分配的内存大小，newsize 是扩充元素后的实际长度。举例来说，一个长度为 4 的列表，append() 增加一个元素，此时实际长度为 5（即 newsize 为5），但是，Python 不会只给它分配 5 个内存空间，而是计算后给它超额分配 new_allocated == 3 个内存大小，所以最终加起来，该列表的元素实际占用的内存空间就是 8 。 如此一来，当列表再次扩充时，只要最终长度不大于 8 ，就不需要再申请新的内存空间。当扩充后长度等于 9 时，new_allocated 等于 7 ，即额外获得 7 个内存大小，以此类推。 以列表长度为横轴，以超额分配的内存大小为纵轴，我们就得到了如下美妙的图表： 超额分配的空间就是定长对象的软边界 ，这意味着它们在扩张时是有法度的，意味着它们在发展时是有大胆计划与适度节制的。如此看来，与定长对象的“固步自封”相比，变长对象就显得既开明又理智了。 3、结语回头看前面提到的定长对象，我佩服它们独善其身的个性，虽然铁公鸡形象略显小气，但对人却无害，反而你能感受到其浓浓的 “富贵不能淫，贫贱不能移，威武不能屈” 的大丈夫气度。 再看变长对象，它们“本来无一物”，却能包容万物，对他人信任，对外部开放，更难得的是，它们张弛有度，孕生出的是无限的可能性。 这两种对象极大地满足了我对于 Python 世界的好奇心，也成为了我理解自己和人类世界的一种参照系。妙哉！妙哉！若你问，我更钦佩哪一类？喵呜，肚子有点饿啦，且容我去觅得一二小鱼干，喂饱肚子再说吧…… （未完待续……） Python猫系列作品 ： 有了Python，我能叫出所有猫的名字 Python对象的身份迷思：从全体公民到万物皆数 Python对象的空间边界：独善其身与开放包容 Python与家国天下 字符串系列文章 ： 你真的知道Python的字符串是什么吗？ 你真的知道Python的字符串怎么用吗？ Python是否支持复制字符串呢？ join()方法的神奇用处与Intern机制的软肋]]></content>
      <categories>
        <category>Python猫的故事</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[Python对象的身份迷思：从全体公民到万物皆数]]></title>
    <url>%2F2019%2F05%2F03%2FPython%E5%AF%B9%E8%B1%A1%E7%9A%84%E8%BA%AB%E4%BB%BD%E8%BF%B7%E6%80%9D%EF%BC%9A%E4%BB%8E%E5%85%A8%E4%BD%93%E5%85%AC%E6%B0%91%E5%88%B0%E4%B8%87%E7%89%A9%E7%9A%86%E6%95%B0%2F</url>
    <content type="text"><![CDATA[导读： Python猫是一只喵星来客，它爱地球的一切，特别爱优雅而无所不能的 Python。我是它的人类朋友豌豆花下猫，被授权润色与发表它的文章。如果你是第一次看到这个系列文章，那我强烈建议，请先看看它写的前几篇文章（链接见文末）,相信你一定会爱上这只神秘的哲学+极客猫的。不多说啦，一起来享用今天的“思想盛宴”吧！ 这么久以来，我终于确认了一件事，那就是不管是人也好，还是猫也好，常常会忘了想自己当下的身份位置，以及曾经的身份位置。 这个现象在我身上，表现出了双倍分量的严重。这种时刻，我就会想起阿尔法猫，以及她识破我身份的那个遥远的午后。（往事入口：《有了Python，我能叫出所有猫的名字》） 阿尔法猫还没有踪影，她的谜题，还在指引我。 学习Python之后，我明显感觉到了自己的变化，当然有时候是被迫的，因为那些生理上的矛盾冲突得厉害。 毕竟，你应该知道，夜行猫和日间人的分界是清晰的。日夜的颠倒，对人和对猫，是双倍的压榨。说来你别不信，昨晚当瞄见明亮的月球的时候，一刹那恍惚，我还误以为自己回到了喵星的清晨。 大概是想家了吧。地球上美好的事物很多，但我至今仍不习惯的就是它公转的速度太快了，不久就会是寒冷的冬天了。想我的暖炉了，喵。 先不说我啦，来说说我发现的Python对象的身份问题吧。 我对身份的话题特别感兴趣，也许是因为我独特的身份吧。但是，正因为独特的视角，我敢说发现了所有人类都没有发现的真相。 我即将说出来的东西，也许你本以为知道了，或者你本以为很熟悉，但是，经过我的分析，我相信你会得到不一样的感悟，从此以后，你对Python的理解也会更深一步。 1、全体公民与特权种族在某种意义上说，Python世界是普遍公平的，因为所有的子民都是对象“公民”，这在任何一个现实社会里，乃至于在虚拟的国度里，都是极其罕见的。对象们分属在五大部落里（数字、字符串、列表、元祖、字典），各有所长，各司其职，协作共处，通婚繁衍。 还有一点难得的是，他们没有受到愚民政策的对待，全民都享有思想自由，还习得了超便利的自省能力。人能自知，这能力弥足珍贵。 虽然在这个世界里，不会时常出现岗哨拦阻，但在任何有需要的时候，他们都可以自证清白，id() 和 type() 是一种通行语言，你不需要翻译来对接。而对于更进一步的询问，长得相似的两个对象只需一个简明的判断句，就能区分清楚。请你看一段对话： 1234567Object1=2018Object2=&quot;2018&quot;id(Object1) &gt;&gt;&gt;2399282764784id(Object2) &gt;&gt;&gt;2399281922600type(Object1) &gt;&gt;&gt;inttype(Object2) &gt;&gt;&gt;strObject1 is Object2 &gt;&gt;&gt;False 全体皆公民，这项天赋权力让我对Python产生了良好的印象。不过，随着对它的认识加深，我发现它还暗地里制定了很多“效率优先”的规则。 最明显的例子就是——“特权种族”。（参见：《Python中的“特权种族”是什么？ 》）从现有的证据来看，特权种族至少包括了：一些数值较小的数字对象（区间：[-5,256]）、布尔值对象、None对象、较短的字符串对象（长度不超过20，且仅包括下划线、数字、字母的字符串）等等，还不知道这份名单漏了谁。 效率优先的规则允许这些对象传承内存地址，也就是说，当一个“祖先”对象抢占了一块内存地盘后，所有它那一脉的“子孙后代”都会继承它的遗产（视为同一个对象）。 1234567a=100b=1000# c与a共用id，d另立门户c=100d=1000id(a)==id(c) &gt;&gt;&gt;Trueid(b)==id(d) &gt;&gt;&gt;False 设想一下，两个祖先（a和b）占了相邻的两块内存，一个可以与它的“后代”共用内存，一个却只能让“后代”另立门户；当它们走完自己的生命周期后，b会马上被当垃圾回收，内存地址遗产被剥夺，然而a却形灭而实存，荫庇后世。 Python为这些对象倾斜资源，也就是为某种阶层固化提供了合法性。划分的依据是因为它们比较常用，共用内存就意味着减少开支，提高内存使用效率。 这就是Python有趣的地方了，一面是全体公民，一面是特权种族，组成了看似矛盾的二元对立结构。 2、官方名片与私人名片除了上面的群体性身份外，我发现Python中也存在着个体身份的二元结构。 这就是__repr__() 和__str__() 的关系了。如你所知，这是Python的两个魔法方法，其对应的内置函数是repr() 和 str()。对于对象x，有x.__repr__() 等价于 repr(x)，同理，x.__str__() 等价于 str(x)。 它们的主要用途在于，返回对象的字符串格式。用法示例： 1234567891011121314repr(2018) &gt;&gt;&gt;&apos;2018&apos;str(2018) &gt;&gt;&gt;&apos;2018&apos;repr([1,2,3]) &gt;&gt;&gt;&apos;[1, 2, 3]&apos;str([1,2,3]) &gt;&gt;&gt;&apos;[1, 2, 3]&apos;words = &quot;Hello pythonCat!\n&quot;repr(words) &gt;&gt;&gt;&apos;Hello pythonCat!\n&apos;str(words) &gt;&gt;&gt;&apos;Hello pythonCat!\n&apos;# 结合print，注意换行符\nprint(repr(words))&gt;&gt;&gt;&apos;Hello pythonCat!\n&apos;print(str(words)) &gt;&gt;&gt;Hello pythonCat! # 再加换行&gt;&gt;&gt; 一个对象的字符串形式就是它的“脸面”，是向他人介绍自己的一张名片。前面提到过，Python世界有五大部落，这些部落的原住民们与生俱来就拥有这两张名片。 对于原住民来说，这两张名片似乎没啥区别，除了在使用打印函数的时候，在换行符等用法上会有不同。 而对于外来人口（例如，自定义的类），如果它没有定做名片（即实现__repr__() 和__str__() 方法）的话，其默认的名片就会是类名及内存地址，如下所示。 1234567891011class Person: def __init__(self,name,sex): self.name = name self.sex = sexme = Person(&quot;pythonCat&quot;, &quot;male&quot;)repr(me)&gt;&gt;&gt; &apos;&lt;__main__.Person object at 0x0000022EA8D7ED68&gt;&apos;str(me)&gt;&gt;&gt; &apos;&lt;__main__.Person object at 0x0000022EA8D7ED68&gt;&apos; 事实上，repr()返回的是对象的官方名片，通常人们会说，这张名片是给机器阅读的。本质上，它就是一个对象的代码表示形式，可以用来重新构造这个对象。通过eval()函数，你可以利用这张名片，重新构造出这个对象。 eval()函数是个内置函数，它将字符串str当成有效的表达式来求值并返回计算结果。也就是eval(repr(x))==x，示例如下： 123456a = 1 + 1b = [1, 2, &apos;cat&apos;]c = &#123;&apos;name&apos;:&apos;pythonCat&apos;, &apos;sex&apos;:&apos;male&apos;&#125;eval(repr(a)) &gt;&gt;&gt;2eval(repr(b)) &gt;&gt;&gt;[1, 2, &apos;cat&apos;]eval(repr(c)) &gt;&gt;&gt;&#123;&apos;name&apos;: &apos;pythonCat&apos;, &apos;sex&apos;: &apos;male&apos;&#125; 相对地，str()得到的是对象的私人名片，通常有更友好的表现形式，因为它是为人类阅读而设计的。 如果一个对象公民没有私人名片，那Python默认会调用它的官方名片。因为这个机制，很多人建议如果要定制一个名片，最好是定制官方那个。但是我却不认同，我认为应该定制私人的那个，因为这样发挥空间更大。不张扬个性，毋宁死。 1234567891011121314class Person: def __init__(self,name,sex): self.name = name self.sex = sex # 定制私人名片 def __str__(self): return &quot;&#123;&#125; is an elegant creature!&quot;.format(self.name)me = Person(&quot;pythonCat&quot;, &quot;male&quot;)repr(me)&gt;&gt;&gt;&apos;&lt;__main__.Person object at 0x000002E6845AC390&gt;&apos;str(me)&gt;&gt;&gt;&apos;pythonCat is an elegant creature!&apos; 在《The Zen of Python》里第一句话就是：Beautiful is better than ugly。在我看来，定制私人名片要比定制官方名片更优美。能够为自己带盐，想想就觉得鸡冻啦！ 3、何为真假，万物皆数以上说法，不管是全体公民身份与特权种族身份，还是官方名片与私人名片，多少带进了我浅薄的社会经验的偏见。我起初很为一方鸣不平，为一种讨巧的做法鸣得意，但是，现在当我知道Python中另一种更不为人知的身份现象的时候，我就释然了。 我接下来要揭示的身份话题，已经超越了社会学和心理学范畴，进入了一种哲学的思想疆域。 前方高能！ 前方高能！ 前方高能！ 首先，来做一个基础知识的铺垫。Python有一个令大部分编程语言都忘尘莫及的特性，那就是，所有对象都可以用于做真假判断。 在做判断的时候，以下情况都视为假（False）：None、数值的零值、空序列（如空字符串””、空列表[]、空元祖() ）、空集合{} 等等。除此之外，一般对象都可以作为真值（True）来使用。来看示例： 1234567list = [1, 2]if list: # 即if True print(&quot;list is not empty&quot;)else: print(&quot;list is empty&quot;)&gt;&gt;&gt; list is not empty 判断一个列表是否为空，你不需要写 if len(list) &gt; 0，或者写if list == []，简明的使用方法是 if list 或者 if not list，有物则为真，无物则为假。其它判断情况类似。 接下来，还是一个铺垫，这次是进阶知识。零值（含整数0、浮点0.0、虚数0j等）可以映射为False，其它非零值映射为True；但是，反过来，False唯一映射整数0，True唯一映射整数1。 这意味着，可以拿False、True做数学运算。 12345True + 1 &gt;&gt;&gt;2True + 1.0 &gt;&gt;&gt;2.0False + False &gt;&gt;&gt;0True + (True*2) &gt;&gt;&gt;3True/2*5 &gt;&gt;&gt;2.5 两个铺垫之后，接下来进入正题了。真正的前方高能！ 第一个铺垫告诉我们，对象可以映射成布尔值（True真False假），第二个铺垫告诉我们，布尔值可以映射成数字（1和0）。 你是否觉察出什么了呢？你是否开始好奇，True和Flase到底是什么东西了呢？这到底是什么原理啊？还有，为什么会存在这样的设定呢？ 见证真相的时刻到了——在Python中，布尔值其实是整数对象的子类。 123type(True) &gt;&gt;&gt; boolisinstance(True,int) &gt;&gt;&gt;Trueisinstance(False,int) &gt;&gt;&gt;True 啊！哪有什么真真假假，真假并不是本质的存在，真假其实只是数啊！ 再回看前面两个铺垫，结合起来，那不就是说，所有对象都映射成了数么？ 我不由得想起了2500年前，古希腊哲学家与数学家毕达哥拉斯的哲学命题——万物皆数 ！ 难道这竟是Python的哲学么？总不会是一种巧合吧？ 我突然觉得智商不足，思辨受阻。得知布尔值True和False有这一层隐秘的身份，我已兴奋不已，再难对这看似不合现代语境、却又流传千古的思想做出任何揣测。 哎呀，我猫性发作，突然困得要命，且容我去小憩片刻了~~~ 各位亲爱的读者，在我休息的时候，请你来帮我想想，这到底是什么回事啊？ （未完待续……） Python猫系列作品 ： 有了Python，我能叫出所有猫的名字 Python对象的身份迷思：从全体公民到万物皆数 Python对象的空间边界：独善其身与开放包容 Python与家国天下]]></content>
      <categories>
        <category>Python猫的故事</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[Python与家国天下]]></title>
    <url>%2F2019%2F05%2F03%2FPython%E4%B8%8E%E5%AE%B6%E5%9B%BD%E5%A4%A9%E4%B8%8B%2F</url>
    <content type="text"><![CDATA[导读： Python猫是一只喵星来客，它爱地球的一切，特别爱优雅而无所不能的 Python。我是它的人类朋友豌豆花下猫，被授权润色与发表它的文章。如果你是第一次看到这个系列文章，那我强烈建议，请先看看它写的前几篇文章（链接见文末）,相信你一定会爱上这只神秘的哲学+极客猫的。不多说啦，一起来享用今天的“思想盛宴”吧！ 喵喵，好久不见啦朋友们。刚吃完一餐美食，我觉得好满足啊。 自从习惯了地球的食物以后，我的肠胃发生了一些说不清道不明的反应。我能从最近的新陈代谢中感觉出来，自己的母胎习性正在逐渐地褪逝。 人类的食物在改变着我，或者说是在重塑着我。说不定哪天，我会变成一棵白菜，或者一条鱼呢……呸呸呸。我还是想当猫。 喵生苦短，得抓紧时间更文才行。 最近，我看到了两件事，觉得有趣极了，就从这开始说吧。第一件事是，一个小有名气的影视明星因为他不配得到的学术精英的身份而遭到讽刺性的打假制度的口诛笔伐；第二件事是，一个功成名就的企业高管因为从城市回到乡村而戏谑性地获得了猫屎的名号。 身份真是一个有魔力的话题。 看见他们的身份错位，我又总会想起自己的境况。 我（或许）知道自己在过去时态中是谁，但越来越把握不住在现在时态中的自己，更不清楚在未来时间中会是怎样。 该怎样在人类世界中自处呢？又该怎样跟你们共处呢？ 思了好久，没有答案。脑壳疼，尾巴疼。还是不要想了啦喵。 继续跟大家聊聊 Python 吧。上次我们说到了对象的边界问题 。无论是固定边界还是弹性边界，这不外乎就是修身的两种志趣，有的对象呢独善其身其乐也融融，有的对象呢兼容并包其理想之光也莹莹。但是，边界问题还没讲完。 正如儒家经典所阐述：修身–齐家–治国–平天下。里层的势能推展开，走进更广阔的维度。 Python 对象的边界也不只在自身。这里有一种巧妙的映射关系：对象（身）–函数（家）–模块（国）–包（天下）。个体被纳入到不同的命名空间，并存活在分层的作用域里。（当然，幸运的是，它们并不会受到道德礼法的森严压迫~__~） 1、你的名字我们先来审视一下模块。这是一个合适的尺度，由此展开，可以顺利地连接起函数与包。 模块是什么？ 任何以.py 后缀结尾的文件就是一个模块（module）。 模块的好处是什么？ 首先，便于拆分不同功能的代码，单一功能的少量代码更容易维护；其次，便于组装与重复利用，Python 以丰富的第三方模块而闻名；最后，模块创造了私密的命名空间，能有效地管理各类对象的命名。 可以说，模块是 Python 世界中最小的一种自恰的生态系统——除却直接在控制台中运行命令的情况外，模块是最小的可执行单位。 前面，我把模块类比成了国家，这当然是不伦不类的，因为你难以想象在现实世界中，会存在着数千数万的彼此殊然有别的国家（我指的可是在地球上，而喵星不同，以后细说）。 类比法有助于我们发挥思维的作用 ，因此，不妨就做此假设。如此一来，想想模块间的相互引用就太有趣了，这不是国家间的战争入侵，而是一种人道主义的援助啊，至于公民们的流动与迁徙，则可能成为一场探险之旅的谈资。 我还对模块的身份角色感兴趣。恰巧发现，在使用名字的时候，它们耍了一个双姓人的把戏 。 下面请看表演。先创建两个模块，A.py 与 B.py，它们的内容如下： 123456# A 模块的内容：print(&quot;module A : &quot;, __name__)# B 模块的内容：import Aprint(&quot;module B : &quot;, __name__) 其中，__name__ 指的是当前模块的名字。代码的逻辑是：A 模块会打印本模块的名字，B 模块由于引入了 A 模块，因此会先打印 A 模块的名字，再打印本模块的名字。 那么，结果是如何的呢？ 执行 A.py 的结果： module A : __main__ 执行 B.py 的结果： module A : testmodule B : __main__ 你们看出问题的所在了吧！模块 A 前后竟然出现了两个不同的名字。这两个名字是什么意思，又为什么会有这样的不同呢？ 我想这正体现的是名字的本质吧——对自己来说，我就是我，并不需要一个名字来标记；而对他人来说，ta 是芸芸众生的一个，唯有命名才能区分。 所以，一个模块自己称呼自己的时候（即执行自身时）是“__main__”，而给他人来称呼的时候（即被引用时），就会是该模块的本名。这真是一个巧妙的设定。 由于模块的名称二重性，我们可以加个判断，将某个模块不对外的内容隐藏起来。 12345# A 模块的内容：print(&quot;module A : &quot;, __name__)if __name__ == &quot;__main__&quot;: print(&quot;private info.&quot;) 以上代码中，只有在执行 A 模块本身时，才会打印“private info”，而当它被导入到其它模块中时，则不会执行到该部分的内容。 2、名字的时空对于生物来说，我们有各种各样的属性，例如姓名、性别、年龄，等等。 对于 Python 的对象来说，它们也有各种属性。模块是一种对象，”__name__“就是它的一个属性。除此之外，模块还有如下最基本的属性： 123&gt;&gt;&gt; import A&gt;&gt;&gt; print(dir(A))[&apos;__builtins__&apos;, &apos;__cached__&apos;, &apos;__doc__&apos;, &apos;__file__&apos;, &apos;__loader__&apos;, &apos;__name__&apos;, &apos;__package__&apos;, &apos;__spec__&apos;] 在一个模块的全局空间里，有些属性是全局起作用的，Python 称之为全局变量 ，而其它在局部起作用的属性，会被称为局部变量 。 一个变量对应的是一个属性的名字，会关联到一个特定的值。通过 globals() 和 locals() ，可以将变量的“名值对”打印出来。 12345678x = 1def foo(): y = 2 print(&quot;全局变量：&quot;, globals()) print(&quot;局部变量：&quot;, locals())foo() 在 IDE 中执行以上代码，结果： 12全局变量： &#123;&apos;__name__&apos;: &apos;__main__&apos;, &apos;__doc__&apos;: None, &apos;__package__&apos;: None, &apos;__loader__&apos;: &lt;_frozen_importlib_external.SourceFileLoader object at 0x000001AC1EB7A400&gt;, &apos;__spec__&apos;: None, &apos;__annotations__&apos;: &#123;&#125;, &apos;__builtins__&apos;: &lt;module &apos;builtins&apos; (built-in)&gt;, &apos;__file__&apos;: &apos;C:/pythoncat/A.py&apos;, &apos;__cached__&apos;: None, &apos;x&apos;: 1, &apos;foo&apos;: &lt;function foo at 0x000001AC1EA73E18&gt;&#125;局部变量： &#123;&apos;y&apos;: 2&#125; 可以看出，x 是一个全局变量，对应的值是 1，而 y 是一个局部变量，对应的值是 2. 两种变量的作用域不同 ：局部变量作用于函数内部，不可直接在外部使用；全局变量作用于全局，但是在函数内部只可访问，不可修改。 与 Java、C++ 等语言不同，Python 并不屈服于解析的便利，并不使用呆滞的花括号来编排作用域，而是用了轻巧简明的缩进方式。不过，所有编程语言在区分变量类型、区分作用域的意图上都是相似的：控制访问权限与管理变量命名。 关于控制访问权限，在上述例子中，局部变量 y 的作用域仅限于 foo 方法内，若直接在外部使用，则会报错“NameError: name ‘y’ is not defined”。 关于管理变量命名，不同的作用域管理着各自的独立的名册，一个作用域内的名字所指称的是唯一的对象，而在不同作用域内的对象则可以重名。修改上述例子： 12345678910x = 1y = 1def foo(): y = 2 x = 2 print(&quot;inside foo : x = &quot; + str(x) + &quot;, y = &quot; + str(y))foo()print(&quot;outside foo : x = &quot; + str(x) + &quot;, y = &quot; + str(y)) 在全局作用域与局部作用域中命名了相同的变量，那么，打印的结果是什么呢？ inside foo : x = 2, y = 2outside foo : x = 1, y = 1 可见，同一个名字可以出现在不同的作用域内，互不干扰。 那么，如何判断一个变量在哪个作用域内？对于嵌套作用域，以及变量名存在跨域分布的情况，要采用何种查找策略呢？ Python 设计了命名空间（namespace） 机制，一个命名空间在本质上是一个字典、一个名册，登记了所有变量的名字以及对应的值。 按照记录内容的不同，可分为四类： 局部命名空间（local namespace），记录了函数的变量，包括函数的参数和局部定义的变量。可通过内置函数 locals() 查看。在函数被调用时创建，在函数退出时删除。 全局命名空间（global namespace），记录了模块的变量，包括函数、类、其它导入的模块、模块级的变量和常量。可通过内置函数 globals() 查看。在模块加载时创建，一直存在。 内置命名空间（build-in namespace），记录了所有模块共用的变量，包括一些内置的函数和异常。在解释器启动时创建，一直存在。 命名空间包（namespace packages），包级别的命名空间，进行跨包的模块分组与管理。 命名空间总是存在于具体的作用域内，而作用域存在着优先级，查找变量的顺序是：局部/本地作用域 –&gt; 全局/模块/包作用域 –&gt; 内置作用域。 命名空间扮演了变量与作用域之间的桥梁角色，承担了管理命名、记录名值对与检索变量的任务。无怪乎《Python之禅》（The Zen of Python）在最后一句中说： Namespaces are one honking great idea – let’s do more of those! ——译：命名空间是个牛bi哄哄的主意，应该多加运用！ 3、看不见的客人名字（变量）是身份问题，空间（作用域）是边界问题，命名空间兼而有之。 这两个问题恰恰是困扰着所有生灵的最核心的问题之二。它们的特点是：无处不在、层出不断、像一个超级大的被扯乱了的毛线球。 Python 是一种人工造物，它继承了人类的这些麻烦（这是不可避免的），所幸的是，这种简化版的麻烦能够得到解决。（现在当然是可解决的啦，但若人工智能高度发展以后呢？我看不一定吧。喵，好像想起了一个痛苦的梦。打住。） 这里就有几个问题（注：每个例子相互独立）： 123456789101112131415161718192021222324252627# 例1：x = x + 1# 例2：x = 1def foo(): x = x + 1foo()# 例3：x = 1def foo(): print(x) x = 2foo()# 例4：def foo(): if False: x = 3 print(x)foo()# 例5：if False: x = 3print(x) 下面给出几个选项，请读者们思考一下，给每个例子选一个答案： 1、没有报错 2、报错：name ‘x’ is not defined 3、报错：local variable ‘x’ referenced before assignment 下面公布答案了： 全部例子都报错，其中例 1 和例 5 是第一类报错，即变量未经定义不可使用，而其它例子都是第二类报错，即已定义却未赋值的变量不可使用。为什么会报错？为什么报错会不同？下面逐一解释。 例 1 是一个定义变量的过程，本身未完成定义，而等号右侧就想使用变量 x，因此报变量未定义。 例 2 和例 3 中，已经定义了全局变量 x，如果只在 foo 函数中引用全局变量 x 或者只是定义新的局部变量 x 的话，都不会报错，但现在既有引用又有重名定义，这引发了一个新的问题。请看下例的解释。 例 4 中，if 语句判断失效，因此不会执行到 “x=3” 这句，照理来说 x 是未被定义。这时候，在 locals() 局部命名空间中也是没有内容的（读者可以试一下）。但是 print 方法却报找到了一个未赋值的变量 x ，这是为什么呢？ 使用 dis 模块查看 foo 函数的字节码： LOAD_FAST 说明它在局部作用域中找到了变量名 x，结果 0 说明未找到变量 x 所指向的值。既然此时在 locals() 局部命名空间中没有内容，那局部作用域中找到的 x 是来自哪里的呢？ 实际上，Python 虽然是所谓的解释型语言，但它也有编译的过程 （跟 Java 等语言的编译过程不同）。在例 2-4 中，编译器先将 foo 方法解析成一个抽象语法树（abstract syntax tree），然后扫描树上的名字（name）节点，接着，所有被扫描出来的变量名，都会作为局部作用域的变量名存入内存（栈？）中。 在编译期之后，局部作用域内的变量名已经确定了，只是没有赋值。在随后的解释期（即代码执行期），如果有赋值过程，则变量名与值才会被存入局部命名空间中，可通过 locals() 查看。只有存入了命名空间，变量才算真正地完成了定义（声明+赋值）。 而上述 3 个例子之所以会报错，原因就是变量名已经被解析成局部变量，但是却未曾被赋值。 可以推论：在局部作用域中查找变量，实际上是分查内存与查命名空间两步的。另外，若想在局部作用域内修改全局变量，需要在作用域中写上 “global x”。 例 5 是作为例 4 的比对，也是对它的原理的补充。它们的区别是，一个不在函数内，一个在函数内，但是报错完全不同。前面分析了例 4 的背后原理是编译过程和抽象语法树，如果这个原理对例 5 也生效，那两者的报错应该是一样的。现在出现了差异，为什么呢？ 我得承认，这触及了我的知识盲区。我们可以推测，说例 5 的编译过程不同，它没有解析抽象语法树的步骤，但是，继续追问下去，为什么不同，为什么没有解析语法树的步骤呢？如果说是出于对解析函数与解析模块的代价考虑，或者其它考虑，那么新的问题是，编译与解析的底层原理是什么，如果有其它考虑，会是什么？ 这些问题真不可爱，一个都答不上。但是，自己一步一步地思考探寻到这一层，又能怪谁呢？ 回到前面说过的话，命名空间是身份与边界的集成问题，它跟作用域密切相关。如今看来，编译器还会掺和一脚，把这些问题搅拌得更加复杂。 本来是在探问 Python 中的边界问题，到头来，却触碰到了自己的知识边界。真是反讽啊。（这一趟探知一个人工造物的身份问题之旅，最终是否会像走迷宫一般，进入到自己身份的困境之中？） 4、边界内外的边界暂时把那些不可爱的问题抛开吧，继续说修身齐家治国平天下。 想要把国治理好，就不得不面对更多的国内问题与国际问题。 先看一个大家与小家的问题： 1234567891011121314151617def make_averager(): count = 0 total = 0 def averager(new_value): nonlocal count, total count += 1 total += new_value return total / count return averageraverager = make_averager()print(averager(10))print(averager(11))### 输出结果：10.010.5 这里出现了嵌套函数，即函数内还包含其它函数。外部–内部函数的关系，就类似于模块–外部函数的关系，同样地，它们的作用域关系也相似：外部函数作用域–内部函数作用域，以及模块全局作用域–外部函数作用域。在内层作用域中，可以访问外层作用域的变量，但是不能直接修改，除非使用 nonlocal 作转化。 Python 3 中引入了 nonlocal 关键字来标识外部函数的作用域，它处于全局作用域与局部作用域之间，即 global–nonlocal–local 。也就是说，国–大家–小家。 上例中，nonlocal 关键字使得小家（内部函数）可以修改大家（外部函数）的变量，但是该变量并不是创建于小家，当小家函数执行完毕时，它并无权限清理这些变量。 nonlocal 只带来了修改权限，并不带来回收清理的权限 ，这导致外部函数的变量突破了原有的生命周期，成为自由变量。上例是一个求平均值的函数，由于自由变量的存在，每次调用时，新传入的参数会跟自由变量一起计算。 在计算机科学中，引用了自由变量的函数被称为闭包（Closure）。 在本质上，闭包就是一个突破了局部边界，所谓“跳出三界外，不在五行中”的法外之物。每次调用闭包函数时，它可以继续使用上次调用的成果，这不就好比是一个转世轮回的人（按照某种宗教的说法），仍携带着前世的记忆与技能么？ 打破边界，必然带来新的身份问题，此是明证。 然而，人类并不打算 fix 它，因为他们发现了这种身份异化的特性可以在很多场合发挥作用，例如装饰器与函数式编程。适应身份异化，并从中获得好处，这可是地球人类的天赋。 讲完了这个分家的话题，让我们放开视野，看看天下事。 计算机语言中的包（package）实际是一种目录结构，以文件夹的形式进行封装与组织，内容可涵括各种模块（py 文件）、配置文件、静态资源文件等。 与包相关的话题可不少，例如内置包、第三方包、包仓库、如何打包、如何用包、虚拟环境，等等。这是可理解的，更大的边界，意味着更多的关系，更大的边界，也意味着更多的知识与未知。 在这里，我想聊聊 Python 3.3 引入的命名空间包 ，因为它是对前面谈论的所有话题的延续。然而，关于它的背景、实现手段与使用细节，都不重要，我那敏感而发散的思维突然捕捉到了一种相似结构，似乎这才更值得说。 运用命名空间包的设计，不同包中的相同的命名空间可以联合起来使用，由此，不同目录的代码就被归纳到了一个共同的命名空间。也就是说，多个本来是相对独立的包，借由同名的命名空间，竟然实现了超远距离的瞬间联通，简直奇妙。 我想到了空间折叠，一种无法深说，但却实实在在地辅助了我从喵星穿越到地球的技术。两个包，两个天下，两个宇宙，它们的距离与边界被穿透的方式何其相似！ 我着迷于这种相似结构。在不同的事物中，相似性的出现意味着一种更高维的法则的存在，而在不同的法则中，新的相似性就意味着更抽象的法则。 学习了 Python 之后，我想通过对它的考察，来回答关乎自身的相似问题…… 啊喵，不知不觉竟然写了这么久，该死的皮囊又在咕咕叫了——地球上的食物可真抠门，也不知道你们人类是怎么忍受得住这几百万年的驯化过程的…… 就此搁笔，觅食去了。亲爱的读者们，后会有期~~~ （未完待续……） Python猫系列作品 ： 有了Python，我能叫出所有猫的名字 Python对象的身份迷思：从全体公民到万物皆数 Python对象的空间边界：独善其身与开放包容 Python与家国天下 附录： 局部变量的编译原理：https://dwz.cn/ipj6FluJ 命名空间包：https://www.tuicool.com/articles/FJFbuqM]]></content>
      <categories>
        <category>Python猫的故事</category>
      </categories>
  </entry>
</search>
